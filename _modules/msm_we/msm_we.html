<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>msm_we.msm_we &mdash; msm_we 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> msm_we
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">msm_we</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Installation/Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_todos.html">TODOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">msm_we</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>msm_we.msm_we</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for msm_we.msm_we</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Main module.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="nb">type</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tqdm.auto</span> <span class="k">as</span> <span class="nn">tqdm</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partialmethod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">concurrent</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">westpa</span> <span class="kn">import</span> <span class="n">analysis</span>
<span class="kn">from</span> <span class="nn">westpa.core.binning</span> <span class="kn">import</span> <span class="n">RectilinearBinMapper</span><span class="p">,</span> <span class="n">VoronoiBinMapper</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span><span class="p">,</span> <span class="n">csr_matrix</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">IncrementalPCA</span> <span class="k">as</span> <span class="n">iPCA</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span> <span class="k">as</span> <span class="n">kmeans</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span> <span class="k">as</span> <span class="n">mini_kmeans</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">rich.logging</span> <span class="kn">import</span> <span class="n">RichHandler</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">RichHandler</span><span class="p">())</span>
<span class="n">log</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># Using the tkinter backend makes matplotlib run better on a cluster, maybe?</span>
<span class="c1"># import matplotlib</span>
<span class="c1"># matplotlib.use(&quot;TkAgg&quot;)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>
<span class="kn">import</span> <span class="nn">pyemma.coordinates</span> <span class="k">as</span> <span class="nn">coor</span>
<span class="kn">import</span> <span class="nn">pyemma.coordinates.clustering</span> <span class="k">as</span> <span class="nn">clustering</span>
<span class="kn">import</span> <span class="nn">pyemma</span>

<span class="c1"># used to check connectivity</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.csgraph</span> <span class="k">as</span> <span class="nn">csgraph</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.sputils</span> <span class="kn">import</span> <span class="n">isdense</span>

<span class="kn">from</span> <span class="nn">rich.live</span> <span class="kn">import</span> <span class="n">Live</span>
<span class="kn">from</span> <span class="nn">rich.table</span> <span class="kn">import</span> <span class="n">Table</span>

<span class="kn">import</span> <span class="nn">ray</span>


<div class="viewcode-block" id="find_connected_sets"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.find_connected_sets">[docs]</a><span class="k">def</span> <span class="nf">find_connected_sets</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation is taken from msmtools.estimation.sparse.connectivity, at commit 9312660.</span>
<span class="sd">    See the original at https://github.com/markovmodel/msmtools/blob/devel/msmtools/estimation/sparse/connectivity.py#L30</span>

<span class="sd">    Compute connected components for a directed graph with weights</span>
<span class="sd">    represented by the given count matrix.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : scipy.sparse matrix or numpy ndarray</span>
<span class="sd">        square matrix specifying edge weights.</span>
<span class="sd">    directed : bool, optional</span>
<span class="sd">       Whether to compute connected components for a directed  or</span>
<span class="sd">       undirected graph. Default is True.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cc : list of arrays of integers</span>
<span class="sd">        Each entry is an array containing all vertices (states) in</span>
<span class="sd">        the corresponding connected component.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isdense</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot; Compute connected components of C. nc is the number of</span>
<span class="sd">    components, indices contain the component labels of the states</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nc</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="s2">&quot;strong&quot;</span>
    <span class="p">)</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># Discrete states</span>

    <span class="sd">&quot;&quot;&quot;Order indices&quot;&quot;&quot;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot;Order states&quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot; The state index tuple is now of the following form (states,</span>
<span class="sd">    indices)=([s_23, s_17,...,s_3, s_2, ...], [0, 0, ..., 1, 1, ...])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot;Find number of states per component&quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;Cumulative sum of count gives start and end indices of</span>
<span class="sd">    components&quot;&quot;&quot;</span>
    <span class="n">csum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">csum</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;Generate list containing components, sort each component by</span>
<span class="sd">    increasing state label&quot;&quot;&quot;</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
        <span class="n">cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">csum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">csum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]))</span>

    <span class="sd">&quot;&quot;&quot;Sort by size of component - largest component first&quot;&quot;&quot;</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cc</span></div>


<div class="viewcode-block" id="is_connected"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.is_connected">[docs]</a><span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">source_states</span><span class="p">,</span> <span class="n">target_states</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check for connectivity between two states.</span>
<span class="sd">    If directed is True, then checks for directional connectivity from source_states to target_states.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix: np.array, NxN</span>
<span class="sd">        Transition matrix</span>
<span class="sd">    source_states: array-like, N</span>
<span class="sd">        Source states</span>
<span class="sd">    target_states: array-like, N</span>
<span class="sd">        Target states</span>
<span class="sd">    directed: bool, default=True</span>
<span class="sd">        Compute directional connectivity</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="ow">not</span> <span class="ow">in</span> <span class="n">csgraph</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">source_states</span><span class="p">)[</span>
            <span class="p">:,</span> <span class="n">target_states</span>
        <span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="inverse_iteration"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.inverse_iteration">[docs]</a><span class="k">def</span> <span class="nf">inverse_iteration</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do one iteration of inverse iteration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    guess: array-like  (N elements)</span>
<span class="sd">        Vector of weights to be used as the initial guess.</span>

<span class="sd">    matrix: array-like (NxN elements)</span>
<span class="sd">        Transition matrix to use for inverse iteration.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The new vector of weights after one iteration of inverse iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Looking for eigenvector corresponding to eigenvalue 1</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Inverse</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">identity</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;bad_matrix.npy&quot;</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Inverse iteration still failed with mu=</span><span class="si">{</span><span class="n">mu</span><span class="si">}</span><span class="s2"> -- examine your transition matrix for why it could &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;be unsolvable. Saving the transition matrix to </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">elif</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;When solving steady-state, failed to perform inverse iteration! &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Trying again with mu=0.999 instead of </span><span class="si">{</span><span class="n">mu</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">inverse_iteration</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.999</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">inverse</span> <span class="o">@</span> <span class="n">guess</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="c1"># Normalize</span>
    <span class="n">result</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="StratifiedClusters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.StratifiedClusters">[docs]</a><span class="k">class</span> <span class="nc">StratifiedClusters</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a class that provides semi-seamless integration of stratified clusters into the</span>
<span class="sd">    existing msm_we code.</span>

<span class="sd">    In &quot;stratified clustering&quot;, clustering is done independently within each WE bin.</span>
<span class="sd">    Cluster models between WE bins are kept completely independent.</span>
<span class="sd">    This may help enforce a wider spread of cluster centers.</span>

<span class="sd">    The purpose of this class is to provide an object with a `.predict()` method, just like</span>
<span class="sd">    the regular kmeans object, that takes in a set of coordinates and assigns it to a cluster.</span>
<span class="sd">    However, `StratifiedClusters.predict()` does an extra step of first mapping the coords</span>
<span class="sd">    to the appropriate WE bin, and then using that WE bin&#39;s cluster model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_mapper</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">target_bins</span><span class="p">,</span> <span class="o">**</span><span class="n">_cluster_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        bin_mapper: westpa.core.binning.BinMapper</span>
<span class="sd">            Bin mapper for the current simulation being analyzed.</span>

<span class="sd">        model: msm_we.modelWE</span>
<span class="sd">            The current haMSM model object</span>

<span class="sd">        n_clusters: int</span>
<span class="sd">            Number of cluster per bin</span>

<span class="sd">        target_bins: array-like</span>
<span class="sd">            Indices of WE bins in the target.</span>
<span class="sd">            Anything in the target gets mapped to its own state anyway,</span>
<span class="sd">            so we don&#39;t want to try to cluster within it.</span>

<span class="sd">        **_cluster_args:</span>
<span class="sd">            Arguments passed through to sklearn.cluster.MiniBatchKMeans</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        A bin mapper can be obtained from an existing simulation&#39;s h5 file with</span>
<span class="sd">        .. code-block:: python</span>
<span class="sd">            import westpa.tools.binning</span>
<span class="sd">            mapper, _, _ = westpa.tools.binning.mapper_from_hdf5(h5file[&#39;bin_topologies&#39;],</span>
<span class="sd">                    h5file[&#39;iterations/iter_00000002&#39;].attrs[&#39;binhash&#39;])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_clusters_per_bin</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="c1"># n_total_clusters = n_clusters_per_bin * (bin_mapper.nbins - 1)</span>

        <span class="c1"># Set some default arguments, and overwrite them with the user&#39;s choices if provided</span>
        <span class="n">cluster_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span> <span class="n">n_clusters_per_bin</span><span class="p">,</span>
            <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">cluster_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_cluster_args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters_per_bin</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span> <span class="o">=</span> <span class="n">bin_mapper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_total_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters_per_bin</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_bins</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Doing stratified clustering with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_total_clusters</span><span class="si">}</span><span class="s2"> total clusters&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_args</span> <span class="o">=</span> <span class="n">cluster_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mini_kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Processing &quot;from&quot;, as in the from-coords, or pcoord0List.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># These are bases/targets</span>
        <span class="c1"># It&#39;s only really important to ignore targets, because you may not have structures in the target b/c of recycling</span>
        <span class="c1"># self.target_bins = target_bins</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">we_remap</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">)}</span>

        <span class="c1"># This isn&#39;t really used any more, excise it at some point.</span>
        <span class="c1"># I need consecutive indices for each non-basis/non-target bin</span>
        <span class="c1"># In other words, remove the target, and then consecutively index all the remaining bins</span>
        <span class="c1"># legitimate_bins = []</span>
        <span class="c1"># for bin_index in range(self.bin_mapper.nbins):</span>
        <span class="c1">#     if bin_index not in target_bins:</span>
        <span class="c1">#         legitimate_bins.append(bin_index)</span>
        <span class="c1">#</span>
        <span class="c1"># self.legitimate_bins = legitimate_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legitimate_bins</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_bins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_bins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="StratifiedClusters.predict"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.StratifiedClusters.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map input coordinates to a WE bin, and then discretize using that bin&#39;s clusterer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords: array-like</span>
<span class="sd">            Coordinates to discretize</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Cluster assignments for coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In general, when a set of coordinates is obtained and being discretized, it&#39;s coordinates at the end of a</span>
<span class="sd">        segment, and so should be binned acoording to the progress coordinate at the end of that segment (i.e.,</span>
<span class="sd">        modelWE.pcoord1List).</span>
<span class="sd">        However, there&#39;s an exception to this -- when doing fluxmatrix calculations, the initial and final clusters</span>
<span class="sd">        for each segment are obtained back-to-back, to get the start/end point of each transition.</span>

<span class="sd">        For that case, setting :code:`StratifiedClusters.toggle=True` will alternate between pcoord0List and pcoord1List every</span>
<span class="sd">        time a prediction is done.</span>
<span class="sd">        This is a pretty janky solution, but at the moment it keeps it relatively seamless between Stratified and regular</span>
<span class="sd">        clusters.</span>
<span class="sd">        :code:`StratifiedClusters.toggle` must be set to False after.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_from</span><span class="p">:</span>
            <span class="n">iter_pcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pcoord0List</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iter_pcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">pcoord1List</span>

        <span class="n">we_bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">iter_pcoords</span><span class="p">)</span>
        <span class="n">we_bins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">we_remap</span><span class="p">[</span><span class="n">we_bin</span><span class="p">]</span> <span class="k">for</span> <span class="n">we_bin</span> <span class="ow">in</span> <span class="n">we_bins</span><span class="p">]</span>

        <span class="n">is_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="n">iter_pcoords</span><span class="p">)</span>
        <span class="n">is_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="n">iter_pcoords</span><span class="p">)</span>

        <span class="c1"># Discretize coords according to which WE bin they&#39;re in</span>
        <span class="n">discrete</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">is_target</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">_discrete</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="n">_bin</span> <span class="o">=</span> <span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_bins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_bin</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_basis</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">_discrete</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">]</span>

                <span class="n">_bin</span> <span class="o">=</span> <span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_bins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_bin</span><span class="p">)</span>

            <span class="c1"># Meanwhile, if you&#39;re NOT in the target (ignored) bin...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">consecutive_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legitimate_bins</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Since we cluster within each WE bin, the clusters within each bin are indexed from 0.</span>
                <span class="c1"># So, if we&#39;re in WE Bin N, the index of the 0th cluster in bin N is really (N-1) * (clusters per bin),</span>
                <span class="c1">#   not 0.</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="s2">&quot;cluster_centers_&quot;</span><span class="p">)</span>
                        <span class="k">else</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legitimate_bins</span><span class="p">[:</span><span class="n">consecutive_index</span><span class="p">]</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="s2">&quot;cluster_centers_&quot;</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Not initialized in seg </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, bin </span><span class="si">{</span><span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">. Coord was </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2">, coords were </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_discrete</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">predict</span><span class="p">([</span><span class="n">coord</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
                    <span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At seg </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, bin </span><span class="si">{</span><span class="n">we_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="n">discrete</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_discrete</span><span class="p">)</span>

        <span class="c1"># This should be true ONLY when doing fluxmatrix calculations!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">toggle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_from</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Finished and toggling... Next iteration will use pcoord</span><span class="si">{</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_from</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">List&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">discrete</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="modelWE"><a class="viewcode-back" href="../../stubs/msm_we.msm_we.modelWE.html#msm_we.msm_we.modelWE">[docs]</a><span class="k">class</span> <span class="nc">modelWE</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of haMSM model building, particularly for steady-state estimation (but there are lots of extras),</span>
<span class="sd">    from WE sampling with basis (source) and target (sink) states with recycling.</span>

<span class="sd">    Set up for typical west.h5 file structure, with coordinates to be stored in west.h5 /iterations/auxdata/coord and</span>
<span class="sd">    basis and target definitions from progress coordinates.</span>

<span class="sd">    Check out run_msmWE.slurm and run_msmWE_flux.py in scripts folder for an implementation example.</span>

<span class="sd">    Danger</span>
<span class="sd">    -------</span>
<span class="sd">    This code currently, in general, appears to assume a 1-D progress coordinate.</span>

<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Refactor</span>
<span class="sd">        In general, this class&#39;s methods generally handle data by holding state in the object.</span>
<span class="sd">        The functions that update state with the result of a calculation, though, tend to update a lot of state on the way.</span>
<span class="sd">        The state being updated along the way is usually &quot;helper&quot; quantities (an example would be the number of bins</span>
<span class="sd">        or number of walkers, which is computed &quot;along the way&quot; in a number of functions, and the object state updated.)</span>

<span class="sd">        I think it would be prudent to refactor these in such a way that these are updated in as few places as possible --</span>
<span class="sd">        one example of this might be setting them as properties, and then updating the value in state as part of that</span>
<span class="sd">        accessor if necessary.</span>


<span class="sd">    References</span>
<span class="sd">    --------</span>
<span class="sd">    Copperman and Zuckerman,</span>
<span class="sd">    *Accelerated estimation of long-timescale kinetics by combining weighted ensemble simulation with Markov model</span>
<span class="sd">    microstategs using non-Markovian theory*, **arXiv** (2020).</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="modelWE.__init__"><a class="viewcode-back" href="../../stubs/msm_we.msm_we.modelWE.html#msm_we.msm_we.modelWE.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work-in-progress init function. For now, just start adding attribute definitions in here.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        - Most logic from initialize() should be moved in here.</span>

<span class="sd">        - Also, comment all of these here. Right now most of them have comments throughout the code.</span>

<span class="sd">        - Reorganize these attributes into some meaningful structure</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Name used for storing files&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;list of str: List of all filenames with data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of files in :code:`fileList`</span>

<span class="sd">        **TODO**: Deprecate this, this could just be a property&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of dimensions in the progress coordinate&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of stored progress coordinates for each iteration, per-segment.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Resampling time for weighted ensemble. (Maybe should be int? Units?)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">WEtargetp1_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WEtargetp1_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Progress coordinate value at target state.</span>
<span class="sd">        Used to check if a progress coord is in the target, and to set the RMSD of the target cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_WEtargetp1_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">WEbasisp1_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Minimum progress coordinate value within basis state.</span>
<span class="sd">        Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WEbasisp1_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Maximum progress coordinate value within basis state.</span>
<span class="sd">        Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_WEbasisp1_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Dimensionality reduction method. Must be one of &quot;pca&quot;, &quot;vamp&quot;, or &quot;none&quot; (**NOT** NoneType)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For optimized binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Test description for minwalkers&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO: This is plural, reference_coord is singular. Intentional? Can you have multiple bases but 1 reference?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: Describe segindList better.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;list: List of segment indices(?)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;array-like: List of segment weights in an iteration&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of steps of history information to use when building transitions.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterFile</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errorWeight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorCount</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;array-like: List of RMSDs corresponding to each cluster.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JtargetSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structures</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;dict: Mapping of cluster indices to structures in that cluster&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="modelWE.initialize"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span>
        <span class="c1"># self, fileSpecifier: str, refPDBfile: str, initPDBfile: str, modelName: str</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fileSpecifier</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">refPDBfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">modelName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">basis_pcoord_bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_pcoord_bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dim_reduce_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pca&quot;</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pcoord_ndim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">auxpath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coord&quot;</span><span class="p">,</span>
        <span class="n">_suppress_boundary_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the model-builder.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileSpecifier : list</span>
<span class="sd">            List of paths to H5 files to analyze.</span>

<span class="sd">        refPDBfile : string</span>
<span class="sd">            Path to PDB file that defines topology.</span>

<span class="sd">        modelName : string</span>
<span class="sd">            Name to use in output filenames.</span>

<span class="sd">        basis_pcoord_bounds: list</span>
<span class="sd">            List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], ...]</span>
<span class="sd">            in pcoord-space for the basis state</span>

<span class="sd">        target_pcoord_bounds: list</span>
<span class="sd">            List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], ...]</span>
<span class="sd">            in pcoord-space for the target state</span>

<span class="sd">        dim_reduce_method: str</span>
<span class="sd">            Dimensionality reduction method. &quot;pca&quot;, &quot;vamp&quot;, or &quot;none&quot;.</span>

<span class="sd">        tau: float</span>
<span class="sd">            Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</span>

<span class="sd">        pcoord_ndim: int</span>
<span class="sd">            Defaults to 1. Dimensionality of progress coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>


<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Some of this logic should be broken into a constructor, and default arguments handled in the constructor&#39;s</span>
<span class="sd">        function signature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initializing msm_we model&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">=</span> <span class="n">modelName</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fileSpecifier</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">fileList</span> <span class="o">=</span> <span class="n">fileSpecifier</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">fileSpecifier</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">fileList</span> <span class="o">=</span> <span class="n">fileSpecifier</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;HDF5 file paths were provided in a string -- this is now deprecated, please pass as a list &quot;</span>
                <span class="s2">&quot;of paths.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span> <span class="o">=</span> <span class="n">pcoord_ndim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">basis_pcoord_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_suppress_boundary_warning</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;No basis coord bounds provided to initialize(). &quot;</span>
                    <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">basis_pcoord_bounds</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">target_pcoord_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_suppress_boundary_warning</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;No target coord bounds provided to initialize(). &quot;</span>
                    <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting basis pcoord bounds&quot;</span><span class="p">)</span>
            <span class="c1"># self.WEtargetp1_bounds = target_pcoord_bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span> <span class="o">=</span> <span class="n">target_pcoord_bounds</span>

        <span class="c1"># self._basis_pcoord_bounds = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span> <span class="o">=</span> <span class="n">auxpath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span> <span class="o">=</span> <span class="n">fileList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileList</span><span class="p">)</span>
        <span class="c1">#####</span>

        <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No tau provided, defaulting to 1.&quot;</span><span class="p">)</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="c1"># This is really only used for nAtoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_topology</span><span class="p">(</span><span class="n">refPDBfile</span><span class="p">)</span>
        <span class="c1"># self.set_basis(initPDBfile)</span>

        <span class="k">if</span> <span class="n">dim_reduce_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No dimensionality reduction method provided to initialize(). Defaulting to pca.&quot;</span>
                <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="s2">&quot;pca&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="n">dim_reduce_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="mi">48</span>  <span class="c1"># number of bins for optimized WE a la Aristoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># number of walkers for optimized WE a la Aristoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># minimum number of walkers per bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;adaptive&quot;</span>  <span class="c1"># adaptive for dynamic k-means bin edges, uniform for equal spacing on kh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;adaptive&quot;</span>  <span class="c1"># adaptive for dynamic allocation, uniform for equal allocation</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates0</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Nothing is raised here because this might be fine, depending on what you&#39;re doing.</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_suppress_boundary_warning</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Model initialized, but coordinates do not exist yet.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;msm_we model successfully initialized&quot;</span><span class="p">)</span></div>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">WEbasisp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@WEbasisp1_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">WEbasisp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the basis state in pcoord1, and also set the bin center based on those.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;WEbasisp1_bounds is a deprecated attribute. &quot;</span>
            <span class="s2">&quot;Set pcoord boundaries using basis_pcoord_bounds instead&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basis_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span>

    <span class="nd">@basis_pcoord_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">basis_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the basis state in an arbitrary dimension pcoord space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds: array-like, (pcoord_ndim x 2)</span>
<span class="sd">            Array of [lower, upper] bounds for each progress coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># In case it&#39;s a 1D pcoord provided as a simple list [min, max],</span>
        <span class="c1">#   reshape it to be consistent with N-D pcoord boundaries as  [[min, max]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Please provide 1-D boundaries as a list of lists or 2-D array&quot;</span>
                <span class="s2">&quot; [[lower bound, upper bound]]. Automatically doing conversion for now.&quot;</span>
            <span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Shape of bounds was </span><span class="si">{</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, should&#39;ve been (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="si">}</span><span class="s2">, 2)&quot;</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;A boundary has a lower bound larger than its upper bound&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

        <span class="n">basis_bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>

            <span class="c1"># If neither of the bin boundaries are infinity, then the bin center is their mean.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_max</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">basis_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">])</span>

            <span class="c1"># If one of them IS infinity, their &quot;bin center&quot; is the non-infinity one.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Janky indexing, if p1_max == inf then that&#39;s True, and True == 1 so it picks the second element</span>
                <span class="n">basis_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">][</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_centers</span> <span class="o">=</span> <span class="n">basis_bin_centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_lag</span>

    <span class="nd">@n_lag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only a lag of 1 tau (n_lag = 0) is currently supported&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_lag</span> <span class="o">=</span> <span class="n">lag</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">WEtargetp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@WEtargetp1_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">WEtargetp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the target state in pcoord1, and also set the bin center based on those.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A target boundary has not been correctly provided&quot;</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;WEbasisp1_bounds is a deprecated attribute. &quot;</span>
            <span class="s2">&quot;Set pcoord boundaries using basis_pcoord_bounds instead&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

<div class="viewcode-block" id="modelWE.progress_disable"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.progress_disable">[docs]</a>    <span class="k">def</span> <span class="nf">progress_disable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disable all progress bars&quot;&quot;&quot;</span>
        <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.progress_enable"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.progress_enable">[docs]</a>    <span class="k">def</span> <span class="nf">progress_enable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable all progress bars&quot;&quot;&quot;</span>
        <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span>

    <span class="nd">@target_pcoord_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">target_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the target state in an arbitrary dimension pcoord space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds: array-like, (pcoord_ndim x 2)</span>
<span class="sd">            Array of [lower, upper] bounds for each progress coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># In case it&#39;s a 1D pcoord provided as a simple list [min, max],</span>
        <span class="c1">#   reshape it to be consistent with N-D pcoord boundaries as  [[min, max]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Please provide 1-D boundaries as a list of lists or 2-D array&quot;</span>
                <span class="s2">&quot; [[lower bound, upper bound]]. Automatically doing conversion for now.&quot;</span>
            <span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">),</span> <span class="s2">&quot;Shape of bounds was </span><span class="si">{bounds.shape}</span><span class="s2">, should&#39;ve been (</span><span class="si">{self.pcoord_ndim}</span><span class="s2">, 2)&quot;</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;A boundary has a lower bound larger than its upper bound&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

        <span class="n">target_bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>

            <span class="c1"># If neither of the bin boundaries are infinity, then the bin center is their mean.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_max</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">target_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">])</span>

            <span class="c1"># If one of them IS infinity, their &quot;bin center&quot; is the non-infinity one.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Janky indexing, if p1_max == inf then that&#39;s True, and True == 1 so it picks the second element</span>
                <span class="n">target_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">][</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_centers</span> <span class="o">=</span> <span class="n">target_bin_centers</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_connect_ray</span><span class="p">():</span>

        <span class="k">assert</span> <span class="n">ray</span><span class="o">.</span><span class="n">is_initialized</span><span class="p">(),</span> <span class="p">(</span>
            <span class="s2">&quot;Ray cluster has not been initialized! &quot;</span>
            <span class="s2">&quot;Launch from the code calling this with ray.init().&quot;</span>
        <span class="p">)</span>
        <span class="n">resources</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">cluster_resources</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using Ray cluster with </span><span class="si">{</span><span class="n">resources</span><span class="p">[</span><span class="s1">&#39;CPU&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> CPUs!&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total cluster resources were </span><span class="si">{</span><span class="n">resources</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;However, available resources are </span><span class="si">{</span><span class="n">ray</span><span class="o">.</span><span class="n">available_resources</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

<div class="viewcode-block" id="modelWE.initialize_from_h5"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.initialize_from_h5">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_h5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refPDBfile</span><span class="p">,</span> <span class="n">initPDBfile</span><span class="p">,</span> <span class="n">modelName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like initialize, but sets state without</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        refPDBfile</span>
<span class="sd">        initPDBfile</span>
<span class="sd">        modelName</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="modelWE.is_WE_basis"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.is_WE_basis">[docs]</a>    <span class="k">def</span> <span class="nf">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the input progress coordinates are in the basis state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pcoords : numpy.ndarray(num_segments, num_pcoords)</span>
<span class="sd">            Array of progress coordinates for each segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True or False : bool</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        This only checks the 0th progress coordinate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pcoord_dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">):</span>
            <span class="n">in_basis</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">in_basis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">in_basis</span></div>

<div class="viewcode-block" id="modelWE.is_WE_target"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.is_WE_target">[docs]</a>    <span class="k">def</span> <span class="nf">is_WE_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the input progress coordinates are in the target state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pcoords : numpy.ndarray(num_segments, num_pcoords)</span>
<span class="sd">            Array of progress coordinates for each segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True or False : bool</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        This only checks the 0th progress coordinate</span>

<span class="sd">        This also assumes you need a small pcoord!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pcoord_dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">):</span>
            <span class="n">in_target</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">in_target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">in_target</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">do_step</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">in_subprocess</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">step_text</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>

        <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;[bold black][ [bold yellow]* [bold black]]&quot;</span>
        <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[bold black]</span><span class="si">{</span><span class="n">step_text</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_subprocess</span><span class="p">:</span>
            <span class="n">step</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(f&quot;Calling {step} with args={args} and kwargs={kwargs}&quot;)</span>
            <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

        <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;[bold black] [[bold green]✓[bold black]]&quot;</span>
        <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[black]</span><span class="si">{</span><span class="n">step_text</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">new_table</span><span class="p">():</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;haMSM Progress&quot;</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s2">&quot;Status&quot;</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s2">&quot;Step&quot;</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="s2">&quot;Notes&quot;</span><span class="p">)</span>

        <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Ray initialization&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Model initialization&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Loading iterations&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Loading coordinates&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Computing dimensionality reduction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Clustering&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Flux matrix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Cleaning&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Transition matrix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Steady-state distribution&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Steady-state target flux&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Cross-validation&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="s2">&quot; [ ]&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">table</span>

<div class="viewcode-block" id="modelWE.build_analyze_model"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.build_analyze_model">[docs]</a>    <span class="k">def</span> <span class="nf">build_analyze_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_paths</span><span class="p">,</span>
        <span class="n">ref_struct</span><span class="p">,</span>
        <span class="n">modelName</span><span class="p">,</span>
        <span class="n">basis_pcoord_bounds</span><span class="p">,</span>
        <span class="n">target_pcoord_bounds</span><span class="p">,</span>
        <span class="n">dimreduce_method</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="p">,</span>
        <span class="n">ray_kwargs</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">max_coord_iter</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">stratified</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">streaming</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_ray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fluxmatrix_iters</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">fluxmatrix_iters_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cross_validation_groups</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">cross_validation_blocks</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">show_live_display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        One-shot function to build the model and analyze all at once. This provides a convenient interface for running</span>
<span class="sd">        the blockwise estimation.</span>

<span class="sd">        This may not be desirable for very long workflows, or workflows still being debugged, where it might make sense</span>
<span class="sd">        to run the individual steps one by one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_paths: list</span>
<span class="sd">            List of paths to H5 files to analyze.</span>
<span class="sd">        ref_struct: string</span>
<span class="sd">            Path to PDB file that defines topology.</span>
<span class="sd">        modelName: string</span>
<span class="sd">            Name to use in output filenames.</span>
<span class="sd">        basis_pcoord_bounds: list</span>
<span class="sd">            List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], ...]</span>
<span class="sd">            in pcoord-space for the basis state</span>
<span class="sd">        target_pcoord_bounds: list</span>
<span class="sd">            List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], ...]</span>
<span class="sd">            in pcoord-space for the target state</span>
<span class="sd">        dimreduce_method: str</span>
<span class="sd">            Dimensionality reduction method. &quot;pca&quot;, &quot;vamp&quot;, or &quot;none&quot;.</span>
<span class="sd">        tau: float</span>
<span class="sd">            Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</span>
<span class="sd">        n_clusters: int</span>
<span class="sd">            Number of clusters to use when clustering. This is clusters per bin for stratified, or total clusters for</span>
<span class="sd">            aggregate.</span>
<span class="sd">        ray_kwargs: dict</span>
<span class="sd">            Keyword arguments passed to ray.init(). Useful for specifying num_cpus. You could also use this to connect</span>
<span class="sd">            to an existing Ray cluster.</span>
<span class="sd">        max_coord_iter: int, optional (Default = model.maxIter, so all)</span>
<span class="sd">            Last iteration to obtain coordinates from. Useful for excluding the end of some data.</span>

<span class="sd">        stratified: bool, optional (Default = True)</span>
<span class="sd">            Enables stratified clustering, where clustering is performed independently within each WE bin.</span>
<span class="sd">        streaming: bool, optional (Default = True)</span>
<span class="sd">            Enables streaming over input data, rather than batch processing. Substantially improves memory efficiency,</span>
<span class="sd">            at a potential small performance hit.</span>
<span class="sd">        use_ray: bool, optional (Default = True)</span>
<span class="sd">            Enable parallelization, using Ray. This provides substantial speedup in discretization and fluxmatrix</span>
<span class="sd">            calculations.</span>

<span class="sd">        fluxmatrix_iters: list, optional (Default = [1, -1])</span>
<span class="sd">            List of [first, last] iteration to use when calculating fluxmatrix. Defaults to using all iterations.</span>
<span class="sd">        fluxmatrix_iters_to_use: list, optional (Default = None)</span>
<span class="sd">            Specific range of iterations to use, as opposed to bounds like fluxmatrix_iters. Note that either this OR</span>
<span class="sd">            fluxmatrix_iters</span>

<span class="sd">        cross_validation_groups: int, optional (Default = 2)</span>
<span class="sd">            Number of independent models to build when doing cross-validation. Each group contains (blocks / groups)</span>
<span class="sd">            blocks.</span>
<span class="sd">        cross_validation_blocks: int, optional (Default = 4)</span>
<span class="sd">            Number of blocks to split your data into, before building the independent models.</span>

<span class="sd">        show_live_display</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_table</span><span class="p">()</span>

        <span class="c1"># Clean up any existing Ray instances</span>
        <span class="k">if</span> <span class="n">use_ray</span><span class="p">:</span>
            <span class="n">ray</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">Live</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">auto_refresh</span><span class="o">=</span><span class="n">show_live_display</span><span class="p">)</span> <span class="k">as</span> <span class="n">live</span><span class="p">:</span>

            <span class="c1"># If live updating was disabled, write to the table once now. (Doesn&#39;t do anything if it was enabled)</span>
            <span class="n">live</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="c1"># # Launch Ray</span>
            <span class="c1"># TODO: Do I actually want to do this in here? Previously, I assumed the user would set it up.</span>
            <span class="n">step_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">use_ray</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span>
                    <span class="mi">0</span>
                <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;[bold black][ [bold yellow]* [bold black]]&quot;</span>
                <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Ray initialization&quot;</span>
                <span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">ray_kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span>
                    <span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ray</span><span class="o">.</span><span class="n">available_resources</span><span class="p">()[</span><span class="s1">&#39;CPU&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> CPUs&quot;</span>
                <span class="p">)</span>

            <span class="c1"># # Initialize model</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">initialize</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;fileSpecifier&quot;</span><span class="p">:</span> <span class="n">file_paths</span><span class="p">,</span>
                    <span class="s2">&quot;refPDBfile&quot;</span><span class="p">:</span> <span class="n">ref_struct</span><span class="p">,</span>
                    <span class="s2">&quot;modelName&quot;</span><span class="p">:</span> <span class="n">modelName</span><span class="p">,</span>
                    <span class="s2">&quot;basis_pcoord_bounds&quot;</span><span class="p">:</span> <span class="n">basis_pcoord_bounds</span><span class="p">,</span>
                    <span class="s2">&quot;target_pcoord_bounds&quot;</span><span class="p">:</span> <span class="n">target_pcoord_bounds</span><span class="p">,</span>
                    <span class="s2">&quot;dim_reduce_method&quot;</span><span class="p">:</span> <span class="n">dimreduce_method</span><span class="p">,</span>
                    <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="n">tau</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="c1"># # Get number of iterations</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_iterations</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">maxIter</span><span class="si">}</span><span class="s2"> iterations exist&quot;</span><span class="p">)</span>

            <span class="c1"># # Load coordinates</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_max_coord_iter</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_coord_iter</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">maxIter</span><span class="p">][</span><span class="n">max_coord_iter</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_coordSet</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">_max_coord_iter</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Got coords for </span><span class="si">{</span><span class="n">_max_coord_iter</span><span class="si">}</span><span class="s2"> iterations&quot;</span>
            <span class="p">)</span>

            <span class="c1"># # Dimensionality reduction</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Method: </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">dimReduceMethod</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">dimReduce</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># # Clustering</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">cluster_coordinates</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span> <span class="n">n_clusters</span><span class="p">,</span>
                    <span class="s2">&quot;streaming&quot;</span><span class="p">:</span> <span class="n">streaming</span><span class="p">,</span>
                    <span class="s2">&quot;use_ray&quot;</span><span class="p">:</span> <span class="n">use_ray</span><span class="p">,</span>
                    <span class="s2">&quot;stratified&quot;</span><span class="p">:</span> <span class="n">stratified</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

            <span class="c1"># # Flux matrix</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_fluxmatrix_iters</span> <span class="o">=</span> <span class="n">fluxmatrix_iters</span>
            <span class="k">if</span> <span class="n">fluxmatrix_iters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">_fluxmatrix_iters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">maxIter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_fluxMatrix</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;n_lag&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;first_iter&quot;</span><span class="p">:</span> <span class="n">_fluxmatrix_iters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;last_iter&quot;</span><span class="p">:</span> <span class="n">_fluxmatrix_iters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;iters_to_use&quot;</span><span class="p">:</span> <span class="n">fluxmatrix_iters_to_use</span><span class="p">,</span>
                    <span class="s2">&quot;use_ray&quot;</span><span class="p">:</span> <span class="n">use_ray</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Fluxmatrix built from iters &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_fluxmatrix_iters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">_fluxmatrix_iters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fluxmatrix_iters_to_use</span><span class="p">][</span><span class="n">fluxmatrix_iters_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># # Cleaning</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">original_clusters</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">organize_fluxMatrix</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;use_ray&quot;</span><span class="p">:</span> <span class="n">use_ray</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">final_clusters</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">original_clusters</span><span class="si">}</span><span class="s2"> clusters cleaned to </span><span class="si">{</span><span class="n">final_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># # Transition matrix</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_Tmatrix</span><span class="p">)</span>

            <span class="c1"># # Steady state</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_steady_state</span><span class="p">)</span>

            <span class="c1"># # Steady-state flux</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Target flux: </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">JtargetSS</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># # Cross-validation</span>
            <span class="c1"># TODO</span>
            <span class="c1"># use `post_cluster_model`, which is the discretized model right before the fluxmatrix was calculated</span>
            <span class="c1"># for now just do something useless w/ the post_cluster_model so linter doesn&#39;t complain</span>
            <span class="n">step_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_step</span><span class="p">(</span>
                <span class="n">table</span><span class="p">,</span>
                <span class="n">step_idx</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">do_block_validation</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;cross_validation_groups&quot;</span><span class="p">:</span> <span class="n">cross_validation_groups</span><span class="p">,</span>
                    <span class="s2">&quot;cross_validation_blocks&quot;</span><span class="p">:</span> <span class="n">cross_validation_blocks</span><span class="p">,</span>
                    <span class="s2">&quot;use_ray&quot;</span><span class="p">:</span> <span class="n">use_ray</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">flux_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">_validation_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">):</span>
                <span class="n">flux_text</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2"> flux: </span><span class="si">{</span><span class="n">_validation_model</span><span class="o">.</span><span class="n">JtargetSS</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_note</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">step_idx</span><span class="p">,</span> <span class="n">flux_text</span><span class="p">)</span>

            <span class="c1"># If live updating was disabled, write to the table once now. (Doesn&#39;t do anything if it was enabled)</span>
            <span class="n">live</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">do_block_validation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cross_validation_groups</span><span class="p">,</span> <span class="n">cross_validation_blocks</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;post_cluster_model&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_cluster_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;Perform clustering with cluster_coordinates() before attempting&quot;</span>
            <span class="s2">&quot;block validation -- self.post_cluster_model is not set.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># TODO: Best way to move around post_cluster_model? Copying it will get massive.</span>
        <span class="c1"># TODO: copying AGAIN seems suboptimal...</span>
        <span class="n">validation_models</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_cluster_model</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cross_validation_groups</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Get the number of iterations in each block</span>
        <span class="n">iters_per_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_cluster_model</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">//</span> <span class="n">cross_validation_blocks</span>
        <span class="n">block_iterations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">start_iter</span><span class="p">,</span> <span class="n">start_iter</span> <span class="o">+</span> <span class="n">iters_per_block</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">start_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_cluster_model</span><span class="o">.</span><span class="n">maxIter</span><span class="p">,</span> <span class="n">iters_per_block</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Otherwise, this may be maxIters + 1</span>
        <span class="n">block_iterations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_iterations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Get the iterations corresponding to each group</span>
        <span class="n">group_blocks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">cross_validation_blocks</span><span class="p">,</span> <span class="n">cross_validation_groups</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">start_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cross_validation_groups</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">validation_iterations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cross_validation_groups</span><span class="p">):</span>

            <span class="n">group_iterations</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">group_blocks</span><span class="p">[</span><span class="n">group</span><span class="p">]:</span>
                <span class="n">group_iterations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">block_iterations</span><span class="p">[</span><span class="n">block</span><span class="p">]))</span>

            <span class="n">validation_iterations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_iterations</span><span class="p">)</span>

            <span class="c1"># You&#39;re looking at this massive try block and judging me -- but don&#39;t worry.</span>
            <span class="c1">#   The purpose of this is just to catch ANY error, and preface it with an explicit heads-up that it&#39;s coming</span>
            <span class="c1">#   from the block validation. This is useful because errors may crop up only in the block-validation, and it</span>
            <span class="c1">#   should be clear at a glance that it&#39;s not from the main model building, but only when the data is split up.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Beginning analysis of cross-validation group </span><span class="si">{</span><span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">cross_validation_groups</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

                <span class="n">_model</span> <span class="o">=</span> <span class="n">validation_models</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>

                <span class="c1"># Get the flux matrix</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_fluxMatrix</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">iters_to_use</span><span class="o">=</span><span class="n">validation_iterations</span><span class="p">[</span><span class="n">group</span><span class="p">],</span> <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span>
                <span class="p">)</span>

                <span class="c1"># Clean it</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">organize_fluxMatrix</span><span class="p">(</span><span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">)</span>

                <span class="c1"># Get tmatrix</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_Tmatrix</span><span class="p">()</span>

                <span class="c1"># Get steady-state</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_steady_state</span><span class="p">()</span>

                <span class="c1"># Get target flux</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">()</span>

                <span class="c1"># Get FPT distribution?</span>
                <span class="k">pass</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error during block validation!&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

                <span class="c1"># TODO: Would be nice to gracefully handle this and move on to the next validation group.</span>
                <span class="c1">#   However, validation models are used in a number of places, and leaving a model with uninitialized</span>
                <span class="c1">#   parameters will cause problems there.</span>
                <span class="c1">#   Maybe a solution is to only populate self.validation_models with successfully generated ones, though</span>
                <span class="c1">#   make sure having the length possibly change there is handled well.</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># Store the validation models, in case you want to analyze them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validation_iterations</span> <span class="o">=</span> <span class="n">validation_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span> <span class="o">=</span> <span class="n">validation_models</span>

<div class="viewcode-block" id="modelWE.load_iter_data"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_iter_data">[docs]</a>    <span class="k">def</span> <span class="nf">load_iter_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update state with the data (including pcoord but not including coords) corresponding to an iteration.</span>

<span class="sd">        Object fields updated with the information from the selected iteration:</span>
<span class="sd">            - `self.westList`</span>
<span class="sd">            - `self.segindList`</span>
<span class="sd">            - `self.weightList`</span>
<span class="sd">            - `self.n_segs`</span>
<span class="sd">            - `self.pcoord0List`</span>
<span class="sd">            - `self.pcoord1List`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter : int</span>
<span class="sd">            Iteration to get data for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        May want to rework the logic here, depending on how this is used.</span>
<span class="sd">        Seems like some of this iteration can be removed/optimized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># log.debug(&quot;Getting iteration data&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="n">westList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">segindList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">weightList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>
        <span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>

        <span class="n">seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="n">n_segs</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate through each file index, trying to find files that contains the iteration of interest</span>
        <span class="c1"># TODO: Can replace this with `for if, fileName in enumerate(self.\\)`</span>
        <span class="k">for</span> <span class="n">file_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">file_idx</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to find the h5 data file associated with this iteration</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

                <span class="c1"># Check if the dataset</span>
                <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>

                <span class="c1"># Check to make sure this isn&#39;t the last iteration -- last iterations have incomplete data</span>
                <span class="n">is_not_last_iteration</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dataIn</span>
                <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From file </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2">, loading iteration </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dataset_exists</span> <span class="ow">and</span> <span class="n">is_not_last_iteration</span><span class="p">:</span>

                    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                    <span class="n">n_segs_in_file</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                    <span class="n">n_segs_in_file</span> <span class="o">=</span> <span class="n">n_segs_in_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dsetNameP</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dsetP</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetNameP</span><span class="p">]</span>
                    <span class="n">pcoord</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
                    <span class="n">seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_weights</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

                    <span class="c1"># Iterate over segments in this dataset</span>
                    <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_segs_in_file</span><span class="p">):</span>
                        <span class="c1"># if np.sum(pcoord[seg_idx,self.pcoord_len-1,:])==0.0:</span>
                        <span class="c1"># # intentionally using this to write in dummy pcoords,</span>
                        <span class="c1"># # this is a good thing to have for post-analysis though!</span>
                        <span class="c1">#    raise ValueError(&#39;Sum pcoord is 0, probably middle of WE iteration, not using iteration&#39;) f</span>
                        <span class="n">westList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">westList</span><span class="p">,</span> <span class="n">file_idx</span><span class="p">)</span>
                        <span class="n">segindList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segindList</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">)</span>
                        <span class="n">weightList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weightList</span><span class="p">,</span> <span class="n">newSet</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pcoord0List</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pcoord</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pcoord1List</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pcoord</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">n_segs</span> <span class="o">=</span> <span class="n">n_segs</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">dataset_exists</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;error in &quot;</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">dataset_exists</span>

        <span class="c1"># log.debug(f&quot;Found {n_segs} segments in iteration {n_iter}&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">=</span> <span class="n">westList</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># This is a list of the segment indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">=</span> <span class="n">segindList</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span><span class="p">[</span><span class="n">n_iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span> <span class="o">=</span> <span class="n">weightList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span> <span class="o">=</span> <span class="n">n_segs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">pcoord0List</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">pcoord1List</span></div>

<div class="viewcode-block" id="modelWE.get_iterations"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iterations">[docs]</a>    <span class="k">def</span> <span class="nf">get_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with the maximum number of iterations, and the number of segments in each section.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This updates :code:`numSegments` -- :code:`numSegments` is actually a *list* of the number of segments in each iteration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting number of iterations and segments&quot;</span><span class="p">)</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Loop over nSegs</span>
        <span class="c1"># TODO: Not sure I understand the logic in this loop</span>
        <span class="k">while</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Iterate through each filename in fileList, and see if it contains the iteration we&#39;re looking for</span>
            <span class="c1"># TODO: This loop is pretty common, this should be refactored into a find_iteration() or something</span>
            <span class="k">for</span> <span class="n">file_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>

                    <span class="n">is_not_last_iteration</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dataIn</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">dataset_exists</span> <span class="ow">and</span> <span class="n">is_not_last_iteration</span><span class="p">:</span>
                        <span class="c1"># If this file does contain the iteration of interest</span>
                        <span class="c1"># if dataset_exists:</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                        <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                        <span class="n">nSeg</span> <span class="o">=</span> <span class="n">nS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nSeg</span>
                    <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No segments in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numSegments</span><span class="p">,</span> <span class="n">nSeg</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; has &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nSeg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; segments...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Warning: These are not defined until this is run for the first time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="n">numSegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="n">numSegments</span><span class="o">.</span><span class="n">size</span></div>

<div class="viewcode-block" id="modelWE.get_iterations_iters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iterations_iters">[docs]</a>    <span class="k">def</span> <span class="nf">get_iterations_iters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with the maximum number of iterations, and the number of segments in each section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter : int</span>
<span class="sd">        last_iter : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Warning</span>
<span class="sd">        ----</span>
<span class="sd">        This is potentially deprecated or unnecessary. Currently unused.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iF</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>
                    <span class="k">if</span> <span class="n">dataset_exists</span><span class="p">:</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                        <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                        <span class="n">nSeg</span> <span class="o">=</span> <span class="n">nS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nSeg</span>
                    <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No segments in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numSegments</span><span class="p">,</span> <span class="n">nSeg</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; has &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nSeg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; segments...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="n">numSegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="n">last_iter</span></div>

<div class="viewcode-block" id="modelWE.set_topology"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.set_topology">[docs]</a>    <span class="k">def</span> <span class="nf">set_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with a new topology.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : str</span>
<span class="sd">            Path to a file containing the PDB with the topology, OR, an mdtraj Trajectory object describing</span>
<span class="sd">            the new basis structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology was provided as a path, trying to load with mdtraj&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;dat&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;prmtop&quot;</span><span class="p">:</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load_prmtop</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">n_atoms</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;pdb&quot;</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                    <span class="s2">&quot;Topology is not a recognized type (PDB)! Proceeding, but no guarantees.&quot;</span>
                <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_atoms</span>
            <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology  was provided as an mdtraj structure, loading that&quot;</span>
            <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">topology</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_atoms</span></div>

<div class="viewcode-block" id="modelWE.set_basis"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.set_basis">[docs]</a>    <span class="k">def</span> <span class="nf">set_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with a new basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basis : str or mdtraj.Trajectory</span>
<span class="sd">            Path to a file containing the PDB with the new basis state, OR, an mdtraj Trajectory object describing</span>
<span class="sd">            the new basis structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input basis state topology was provided as a path, trying to load with mdtraj&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">basis</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;dat&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">basis</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;pdb&quot;</span><span class="p">:</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="n">struct</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                    <span class="s2">&quot;Basis is not a recognized type! Proceeding, but no guarantees.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># raise NotImplementedError(&quot;Basis coordinates are not a recognized filetype&quot;)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology  was provided as an mdtraj structure, loading that&quot;</span>
            <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">basis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_transition_data"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_transition_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function analyzes pairs of coordinates at the current iteration, set by :code:`self.n_iter`, and at some</span>
<span class="sd">            lag in the past, :code:`self.n_iter - n_lag`.</span>

<span class="sd">        Segments where a walker was warped (recycled) use the basis coords as the lagged coords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_lag : int</span>
<span class="sd">            Number of lags to use for transitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Getting transition data at arbitrary lags &gt; 0 is not yet supported! Use at your own risk.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># get segment history data at lag time n_lag from current iter</span>
        <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;too much lag for iter... n_lag reduced to: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n_lag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>
        <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;too much lag for stored history... recalculating...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="n">segindList_lagged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="n">n_lag</span><span class="p">]</span>

        <span class="c1"># TODO: What exactly is this a list of?</span>
        <span class="c1"># seg_histories is a list of indices of the segments</span>
        <span class="n">warpList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_lag</span><span class="p">]</span>  <span class="c1"># check for warps</span>
        <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">warpList</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get the weights for the lagged and current iterations</span>
        <span class="c1"># If something was split/merged between n_iter and n_iter-n_lag , then the weights may have changed, so</span>
        <span class="c1">#   check a particular segment&#39;s weight.</span>
        <span class="c1"># TODO: Does this effectively get the parent weight if it was split from something else? Then weight_histories</span>
        <span class="c1">#    would need to be tracking parents/children</span>
        <span class="n">weightList_lagged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[:,</span> <span class="n">n_lag</span><span class="p">]</span>
        <span class="c1"># TODO: Does this copy need to be made?</span>
        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>

        <span class="c1"># This will become a list of (lagged iter coord, current iter coord)</span>
        <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">prewarpedStructures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">nWarped</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Go through each segment, and get pairs of coordinates at current iter (n_iter) and</span>
        <span class="c1"># lagged iter (n_iter-n_lag)</span>
        <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>

            <span class="c1"># FIXME: Try statements should encompass the smallest amount of code</span>
            <span class="c1">#  possible - anything could be tripping this</span>
            <span class="c1"># try:</span>
            <span class="k">if</span> <span class="n">seg_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_current</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">n_lag</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_lagged</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># FIXME: I think you can just move this close to an if statement in the beginning, and then remove</span>
                <span class="c1">#   this whole if/elif. Everything after that close() seems to be duplicated.</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

                <span class="c1"># Load the data for the current iteration</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_current</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>

                <span class="c1"># Load the lagged data for (iteration - n_lag)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">n_lag</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_lagged</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>

            <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_current</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
            <span class="p">]</span>

            <span class="c1"># If this segment has no warps, then add the lagged coordinates</span>
            <span class="k">if</span> <span class="n">warpList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Try to set the previous coord in the transition pair to the segment&#39;s lagged coordinates</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lagged_seg_index</span> <span class="o">=</span> <span class="n">segindList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
                    <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_lagged</span><span class="p">[</span>
                        <span class="n">lagged_seg_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                    <span class="p">]</span>

                <span class="c1"># If this fails, then there were no lagged coordinates for this structure.</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Lagged coordinates do not exist for the structure in segment </span><span class="si">{</span><span class="n">seg_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">weightList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">weightList</span><span class="p">[</span>
                        <span class="n">seg_idx</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># set transitions without structures to zero weight</span>

            <span class="c1"># If something was recycled during this segment, then instead of using the lagged cooordinates,</span>
            <span class="c1">#   just use the basis coords.</span>
            <span class="c1"># But, also save the original structure before the warp!</span>
            <span class="k">elif</span> <span class="n">warpList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># St</span>
                <span class="n">prewarpedStructures</span><span class="p">[</span><span class="n">nWarped</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords_lagged</span><span class="p">[</span>
                    <span class="n">segindList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                <span class="p">]</span>

                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span>
                <span class="n">nWarped</span> <span class="o">=</span> <span class="n">nWarped</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># # TODO: What triggers this? When that critical log hits, come update this comment and the main docstring.</span>
            <span class="c1"># # This triggers on index out of bounds... But that&#39;s a huge try statement!</span>
            <span class="c1"># except Exception as e:</span>
            <span class="c1">#     log.critical(&quot;Document whatever&#39;s causing this exception!&quot;)</span>
            <span class="c1">#     log.warning(e)</span>
            <span class="c1">#     raise e</span>
            <span class="c1">#     weightList_lagged[seg_idx] = 0.0</span>
            <span class="c1">#     weightList[</span>
            <span class="c1">#         seg_idx</span>
            <span class="c1">#     ] = 0.0  # set transitions without structures to zero weight</span>

        <span class="c1"># Squeeze removes axes of length 1 -- this helps with np.where returning nested lists of indices</span>
        <span class="c1"># FIXME: is any of this necessary? This kinda seems like it could be replaced with</span>
        <span class="c1">#  something like indWarped = np.squeeze(np.where(warpList &gt; 0)).astype(int)</span>
        <span class="n">indWarped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">warpList</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">indWarpedArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nWarped</span><span class="p">)</span>
        <span class="n">indWarpedArray</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nWarped</span><span class="p">]</span> <span class="o">=</span> <span class="n">indWarped</span>
        <span class="n">indWarped</span> <span class="o">=</span> <span class="n">indWarpedArray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Get the current and lagged weights</span>
        <span class="c1"># This returns (the wrong? none at all?) weights for segments with warps, which is corrected below</span>
        <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">weightList_lagged</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get correct weights for segments that warped</span>
        <span class="k">for</span> <span class="n">iW</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nWarped</span><span class="p">):</span>

            <span class="c1"># The coord pair here is (pre-warped structure, reference topology) instead of</span>
            <span class="c1">#   (lagged struture, current structure)</span>
            <span class="n">coordPair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">coordPair</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prewarpedStructures</span><span class="p">[</span><span class="n">iW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">coordPair</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span>
            <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordPairList</span><span class="p">,</span> <span class="n">coordPair</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># TODO: iterWarped appears to be the iteration the warp happened at</span>
            <span class="n">iterWarped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">iterWarped</span><span class="p">)</span>
                <span class="n">iterWarped</span> <span class="o">=</span> <span class="n">iterWarped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot; warped &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nW</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; times</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># TODO: What exception is this handling? Why would this be tripped?</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exception was </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;UPDATE THIS EXCEPTION HANDLER!&quot;</span><span class="p">)</span>

                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    segment &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; warped 1 time</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># The &quot;current&quot; weights are taken at the warp iteration, so the final pair of weights are</span>
            <span class="c1">#   (the lagged weights, the weights at the warp)</span>
            <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">transitionWeights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="n">iterWarped</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">departureWeights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="n">n_lag</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="n">coordPairList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">transitionWeights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="n">departureWeights</span></div>

<div class="viewcode-block" id="modelWE.get_transition_data_lag0"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_transition_data_lag0">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_data_lag0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get coordinate pairs at the beginning and end of this iteration.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.coordPairList, a list of  parent/child coordinate pairs</span>
<span class="sd">            - self.transitionWeights, a copy of self.weightList</span>
<span class="sd">            - self.departureWeights, a copy of self.weightList</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>
        <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting transition data for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segs in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, at a lag of 0&quot;</span>
        <span class="p">)</span>

        <span class="c1"># the segments in this iteration may be split across a number of different files</span>
        <span class="c1"># &quot;Traditionally&quot;, we store a reference for  each segment  of which WEST file it&#39;s in</span>
        <span class="c1"># But what if we flip that, and for each west file, get which segments are in it?</span>

        <span class="n">seg_west_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">)]</span>
        <span class="n">west_file_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_west_files</span><span class="p">)</span>
        <span class="n">west_files</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">west_file_idxs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">west_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">west_files</span><span class="p">):</span>

            <span class="n">segs_contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg_west_files</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">west_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>

                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">data_file</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">dset</span>

                <span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                <span class="p">]</span>

                <span class="c1"># Check for NaNs in segments</span>
                <span class="n">nan_segments</span> <span class="o">=</span> <span class="n">segs_contained</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="n">nan_segments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Bad coordinates for segments </span><span class="si">{</span><span class="n">nan_segments</span><span class="si">}</span><span class="s2">, setting weights to 0&quot;</span>
                    <span class="p">)</span>
                    <span class="n">weightList</span><span class="p">[</span><span class="n">nan_segments</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="n">coordPairList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">transitionWeights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="n">departureWeights</span></div>

<div class="viewcode-block" id="modelWE.get_warps_from_parent"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_warps_from_parent">[docs]</a>    <span class="k">def</span> <span class="nf">get_warps_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all warps and weights over a range of iterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter: int</span>
<span class="sd">            First iteration in range.</span>
<span class="sd">        last_iter: int</span>
<span class="sd">            Last iteration in range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warpedWeights: list</span>
<span class="sd">            List of weights for each warp.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warpedWeights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">parentList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">parentList</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">warpedWeights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">warpedWeights</span></div>

    <span class="k">def</span> <span class="nf">get_warps_from_pcoord</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span>
    <span class="p">):</span>  <span class="c1"># get all warps and weights over set of iterations</span>
        <span class="n">warpedWeights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
            <span class="n">pcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># warpList = np.where(pcoord &lt; self.WEtargetp1)</span>
            <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="n">pcoord</span><span class="p">))</span>
            <span class="n">warpedWeights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span>
            <span class="n">meanJ</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Jdirect: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">meanJ</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">warpedWeights</span>

    <span class="k">def</span> <span class="nf">get_direct_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">last_iter</span> <span class="o">-</span> <span class="n">first_iter</span>
        <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;/s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;/Jdirect&quot;</span>
        <span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warpedWeights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_warps_from_pcoord</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warpedWeights</span> <span class="o">=</span> <span class="n">warpedWeights</span>
            <span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">iS</span> <span class="o">-</span> <span class="n">window</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nI</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
                <span class="n">warpedWeightsI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                    <span class="n">warpedWeightsI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warpedWeightsI</span><span class="p">,</span> <span class="n">warpedWeights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">nWarped</span> <span class="o">=</span> <span class="n">warpedWeightsI</span><span class="o">.</span><span class="n">size</span>
                <span class="n">particles</span> <span class="o">=</span> <span class="p">(</span><span class="n">nWarped</span> <span class="o">*</span> <span class="n">warpedWeightsI</span><span class="p">)</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">Jdirect</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
                <span class="n">JdirectTimes</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="n">iS</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">Jdirect</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Jdirect</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Jdirect</span>
            <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;/s&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;/JdirectTimes&quot;</span>
            <span class="p">)</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">JdirectTimes</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">JdirectTimes</span>
        <span class="k">elif</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;/s&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;/JdirectTimes&quot;</span>
            <span class="p">)</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Jdirect</span> <span class="o">=</span> <span class="n">Jdirect</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span>  <span class="c1"># correct for number of trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">JdirectTimes</span>

<div class="viewcode-block" id="modelWE.get_seg_histories"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_seg_histories">[docs]</a>    <span class="k">def</span> <span class="nf">get_seg_histories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_hist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **TODO: What does this do exactly?**</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.seg_histories</span>
<span class="sd">            - self.weight_histories</span>
<span class="sd">            - self.n_hist</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_hist : int</span>
<span class="sd">            Number of steps of history information to include.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting seg histories for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_hist</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;we have too much history... n_hist reduced to: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>

        <span class="c1"># FIXME: The only other place this is used is in get_transition_data(). May need to see how it&#39;s handled there</span>
        <span class="c1">#   i.e. make sure it&#39;s initialized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">=</span> <span class="n">n_hist</span>

        <span class="n">seg_histories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">weight_histories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span><span class="p">))</span>

        <span class="c1"># Loop over all segments</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>

            <span class="c1"># Print a message every 100 segments</span>
            <span class="c1"># if iS % 100 == 0:</span>
            <span class="c1">#     sys.stdout.write(</span>
            <span class="c1">#         &quot;        getting history for iteration &quot;</span>
            <span class="c1">#         + str(self.n_iter)</span>
            <span class="c1">#         + &quot; segment &quot;</span>
            <span class="c1">#         + str(iS)</span>
            <span class="c1">#         + &quot;...\n&quot;</span>
            <span class="c1">#     )</span>

            <span class="c1"># Open the relevant datafile for reading</span>
            <span class="k">if</span> <span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># If you&#39;re past the 0th segment, then close the previous file.</span>
                <span class="c1"># FIXME: Close the file after finished working with it, at the *end* of the loop. As-is, the last loop</span>
                <span class="c1">#       leaves the file open.</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

            <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
            <span class="n">warped</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Iterate over history lengths from 1 to n_hist</span>
            <span class="k">for</span> <span class="n">iH</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                <span class="n">indCurrentSeg</span> <span class="o">=</span> <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">indCurrentSeg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="s2">&quot;Segment &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; warped last iter: History must end NOW!</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">warped</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">elif</span> <span class="n">indCurrentSeg</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">iH</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="n">indCurrentSeg</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">weight_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="n">indCurrentSeg</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="s2">&quot;            segment &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; warped &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iH</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; iters ago</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span> <span class="o">=</span> <span class="n">seg_histories</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span> <span class="o">=</span> <span class="n">weight_histories</span></div>
        <span class="c1"># FIXME:</span>
        <span class="c1">#   weight histories and segment histories go in reverse order,</span>
        <span class="c1">#   so final current iter is first of 0 index</span>

<div class="viewcode-block" id="modelWE.collect_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.collect_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">collect_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># grab coordinates from WE traj_segs folder</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Goes through the generated trajectory segments, and adds data from the segments to an H5 file.</span>

<span class="sd">        This should be implemented by the user, and this implementation assumes a really specific configuration.</span>
<span class="sd">        This is left in mostly as an example.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Generalize to different filetypes. This appears to be AMBER specific and relies on loading rst7 files</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;If you&#39;re calling this function, be absolutely sure it does what you want -- this is &quot;</span>
            <span class="s2">&quot;very specifically written for the output of certain simulations.&quot;</span>
        <span class="p">)</span>

        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="c1"># FIXME: Replace strings with Pathlib paths</span>
            <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
            <span class="n">WEfolder</span> <span class="o">=</span> <span class="n">westFile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;west.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">trajpath</span> <span class="o">=</span> <span class="n">WEfolder</span> <span class="o">+</span> <span class="s2">&quot;traj_segs/</span><span class="si">%06d</span><span class="s2">/</span><span class="si">%06d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">iS</span><span class="p">)</span>
            <span class="n">coord0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                    <span class="n">trajpath</span> <span class="o">+</span> <span class="s2">&quot;/parent.rst7&quot;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span><span class="o">.</span><span class="n">topology</span>
                <span class="p">)</span><span class="o">.</span><span class="n">_xyz</span>
            <span class="p">)</span>
            <span class="n">coord1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                    <span class="n">trajpath</span> <span class="o">+</span> <span class="s2">&quot;/seg.rst7&quot;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span><span class="o">.</span><span class="n">topology</span>
                <span class="p">)</span><span class="o">.</span><span class="n">_xyz</span>
            <span class="p">)</span>
            <span class="n">coordT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord0</span><span class="p">,</span> <span class="n">coord1</span><span class="p">])</span>
            <span class="n">coordT</span> <span class="o">=</span> <span class="n">coordT</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coordT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">iS</span> <span class="o">&lt;</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># TODO: Why exclude the last point?</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                                <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>
                            <span class="p">)</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                            <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                                <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>
                            <span class="p">)</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;coords exist for iteration &quot;</span>
                                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coordT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>

                    <span class="c1"># If it&#39;s the last segment, don&#39;t exclude the last point (why?)</span>
                    <span class="k">elif</span> <span class="n">iS</span> <span class="o">==</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                            <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;coords exist for iteration &quot;</span>
                                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;error collecting coordinates from &quot;</span>
                    <span class="o">+</span> <span class="n">WEfolder</span>
                    <span class="o">+</span> <span class="s2">&quot; , iter &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the valid coordinates for a certain iteration</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iteration: int</span>
<span class="sd">            The iteration to return coordinates for</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Array of coordinates for all atoms at the current iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
        <span class="c1"># indGood = np.squeeze(np.where(np.sum(np.sum(self.cur_iter_coords, 2), 1) != 0))</span>

        <span class="n">bad_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_coords</span>

        <span class="c1"># iter_coords = self.cur_iter_coords[indGood]</span>
        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">iter_coords</span></div>

<div class="viewcode-block" id="modelWE.load_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">load_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting coordinates for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segs in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, at a lag of 0&quot;</span>
        <span class="p">)</span>

        <span class="c1"># the segments in this iteration may be split across a number of different files</span>
        <span class="c1"># &quot;Traditionally&quot;, we store a reference for  each segment  of which WEST file it&#39;s in</span>
        <span class="c1"># But flip that, and for each west file, get which segments are in it</span>

        <span class="n">seg_west_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">)]</span>
        <span class="n">west_file_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_west_files</span><span class="p">)</span>
        <span class="n">west_files</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">west_file_idxs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">west_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">west_files</span><span class="p">):</span>

            <span class="n">segs_contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg_west_files</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">west_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>

                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">data_file</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error getting coordinates from </span><span class="si">{</span><span class="n">west_file</span><span class="si">}</span><span class="s2">, in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                    <span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># raise e</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">dset</span>
                    <span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">cur_iter_coords</span></div>

    <span class="k">def</span> <span class="nf">load_iter_coordinates0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># get iteration initial coordinates</span>
        <span class="n">coordList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">auxpath</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="n">coordList</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">coordList</span>

<div class="viewcode-block" id="modelWE.get_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unused</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter</span>
<span class="sd">        last_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;This function is not tested or supported, use at your own risk!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span> <span class="o">=</span> <span class="n">first_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">=</span> <span class="n">last_iter</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    gathering structures from iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span><span class="p">:</span>
                <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordSet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_coords</span> <span class="o">=</span> <span class="n">coordSet</span></div>

<div class="viewcode-block" id="modelWE.get_coordSet"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_coordSet">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">streaming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads all coordinates and progress coordinates into memory for later usage.</span>

<span class="sd">        If streaming, then this only loads pcoords</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        I want to avoid loading full coordinates into memory as much as possible.</span>
<span class="sd">        That means trying to replace usage of all_coords here.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        last_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">streaming</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">streaming</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CoordSet loading up to </span><span class="si">{</span><span class="n">last_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">total_segments</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[:</span><span class="n">last_iter</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
            <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">total_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">pcoordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">total_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">last_seg_idx</span> <span class="o">=</span> <span class="n">total_segments</span>

        <span class="c1"># Update iterations N+1 -&gt; 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">last_iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Getting coordSet&quot;</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>

            <span class="n">first_seg_idx</span> <span class="o">=</span> <span class="n">last_seg_idx</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">first_seg_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Referencing a segment that doesn&#39;t exist&quot;</span>

            <span class="c1"># Get the indices of all &quot;good&quot; coordinates, where a  valid coordinate has been obtained</span>
            <span class="c1"># Boolean mask for coords that have been successfully initialized</span>
            <span class="n">bad_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_coords</span>

            <span class="k">if</span> <span class="n">bad_coords</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Walker </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">bad_coords</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="si">}</span><span class="s2"> has bad coords in iteration(s) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
                <span class="n">coordSet</span><span class="p">[</span><span class="n">first_seg_idx</span><span class="p">:</span><span class="n">last_seg_idx</span><span class="p">][</span>
                    <span class="n">good_coords</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

            <span class="n">pcoordSet</span><span class="p">[</span><span class="n">first_seg_idx</span><span class="p">:</span><span class="n">last_seg_idx</span><span class="p">][</span><span class="n">good_coords</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span>
                <span class="n">good_coords</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span>

            <span class="n">last_seg_idx</span> <span class="o">=</span> <span class="n">first_seg_idx</span>

        <span class="c1"># Set the coords, and pcoords</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_coords</span> <span class="o">=</span> <span class="n">coordSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span> <span class="o">=</span> <span class="n">pcoordSet</span>

        <span class="n">first_iter_cluster</span> <span class="o">=</span> <span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span> <span class="o">=</span> <span class="n">first_iter_cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">=</span> <span class="n">last_iter</span></div>

    <span class="k">def</span> <span class="nf">get_traj_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">,</span> <span class="n">traj_length</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traj_length</span> <span class="o">&gt;</span> <span class="n">from_iter</span><span class="p">:</span>
            <span class="n">traj_length</span> <span class="o">=</span> <span class="n">from_iter</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;trajectory length too long: set to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">traj_length</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">from_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="n">traj_length</span><span class="p">)</span>
        <span class="n">traj_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">traj_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">traj_length</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">iH</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="n">westList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">from_iter</span><span class="p">,</span> <span class="n">from_iter</span> <span class="o">-</span> <span class="n">traj_length</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;    gathering structures from iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;...</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
            <span class="n">seg_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="n">iH</span><span class="p">]</span>
            <span class="n">seg_history_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nS</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nS</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="nb">int</span>
            <span class="p">)</span>  <span class="c1"># list of final iterations for warped particles</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">seg_history_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">==</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">==</span> <span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>  <span class="c1"># segment indexes are local to the westfile, not global for the analysis set</span>
                    <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">from_iter</span> <span class="o">-</span> <span class="n">traj_length</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">traj_iters</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">seg_history_index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">iH</span> <span class="o">=</span> <span class="n">iH</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">from_iter</span><span class="p">)</span>
        <span class="n">traj_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">traj_iters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj_iters</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">do_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">rough_pca</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">processCoordinates</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># If  no good coords in this iteration, skip it</span>
        <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rough_pca</span>

        <span class="n">processed_iter_coords</span> <span class="o">=</span> <span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
        <span class="n">rough_pca</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">processed_iter_coords</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">rough_pca</span><span class="o">.</span><span class="n">n_samples_seen_</span><span class="si">}</span><span class="s2"> samples seen&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rough_pca</span>

    <span class="k">def</span> <span class="nf">do_full_pca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>

        <span class="n">ipca</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">processCoordinates</span><span class="p">,</span> <span class="n">components_for_var</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="n">used_iters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Keep adding coords until you have more than your components</span>
        <span class="k">while</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">components_for_var</span><span class="p">:</span>

            <span class="n">used_iters</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="n">used_iters</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">processed_iter_coords</span> <span class="o">=</span> <span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;About to run iPCA on  </span><span class="si">{</span><span class="n">processed_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> processed coords&quot;</span>
        <span class="p">)</span>
        <span class="n">ipca</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">processed_iter_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ipca</span><span class="p">,</span> <span class="n">used_iters</span>

<div class="viewcode-block" id="modelWE.dimReduce"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.dimReduce">[docs]</a>    <span class="k">def</span> <span class="nf">dimReduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">first_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">first_rough_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">last_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rough_stride</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">fine_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dimensionality reduction using the scheme specified in initialization.</span>

<span class="sd">        This just defines the dimensionality reduction scheme and builds the model -- it does NOT actually transform</span>
<span class="sd">        the data!</span>

<span class="sd">        Transforming the data is performed via reduceCoordinates(), which uses self.coordinates as set</span>
<span class="sd">            by this.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.coordinates`</span>
<span class="sd">            - `self.ndim`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running dimensionality reduction -- method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># log.debug(self.coordSet)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>

            <span class="c1"># Do this in a streaming way, iteration by iteration</span>
            <span class="c1"># First, do a &quot;rough&quot; PCA on the last 10% of the data to get the number of components that explain the</span>
            <span class="c1">#   variance cutoff.</span>
            <span class="c1"># This is necessary because with incremental PCA, there&#39;s no way to do this ahead of time.</span>
            <span class="n">variance_cutoff</span> <span class="o">=</span> <span class="mf">0.95</span>

            <span class="k">if</span> <span class="n">last_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">last_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span>

            <span class="n">rough_ipca</span> <span class="o">=</span> <span class="n">iPCA</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">first_rough_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">total_num_iterations</span> <span class="o">=</span> <span class="n">last_iter</span>
                <span class="c1"># Stride every 10th frame, so you&#39;re only doing the &quot;rough&quot; pca on 10% of the data</span>
                <span class="k">if</span> <span class="n">total_num_iterations</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="n">rough_iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span><span class="p">,</span> <span class="n">rough_stride</span><span class="p">)</span>

                <span class="c1"># But if you only have 100 frames or fewer, then just do the last-half.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rough_iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_num_iterations</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">total_num_iterations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rough_iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_rough_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">rough_stride</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">rough_iters</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Initial iPCA&quot;</span><span class="p">):</span>

                <span class="c1"># TODO: Allow  chunking here so you don&#39;t have  to  go 1  by  1, but N by N</span>
                <span class="c1"># If you don&#39;t use &#39;fork&#39; context here, this will break in Jupyter.</span>
                <span class="c1"># That&#39;s because processCoordinates is monkey-patched in. With &#39;spawn&#39; (i.e. without fork), the module</span>
                <span class="c1">#   is re-imported in the child process. In the reimported  module, processCoordinates is undefined.</span>
                <span class="c1"># With &#39;fork&#39;, it preserves the monkey-patched version.</span>
                <span class="c1"># Additionally, &#39;fork&#39; is a little faster than  spawn. Ironically, that&#39;s usually at the cost  of memory</span>
                <span class="c1">#   usage. But here, the memory being used by the main thread (and therefore being copied here) isn&#39;t</span>
                <span class="c1">#   that great -- the memory issue stems from it not being freed up between successive calls.</span>
                <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                    <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                    <span class="n">rough_ipca</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">do_pca</span><span class="p">,</span> <span class="p">[</span><span class="n">rough_ipca</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

            <span class="n">components_for_var</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rough_ipca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">variance_cutoff</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keeping </span><span class="si">{</span><span class="n">components_for_var</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>
            <span class="n">components_for_var</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">components_for_var</span><span class="p">,</span> <span class="p">(</span><span class="n">last_iter</span> <span class="o">-</span> <span class="n">first_iter</span><span class="p">)</span> <span class="o">//</span> <span class="n">fine_stride</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>

            <span class="c1"># Now do the PCA again, with that many components, using all the iterations.</span>
            <span class="n">ipca</span> <span class="o">=</span> <span class="n">iPCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">components_for_var</span><span class="p">)</span>

            <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">fine_stride</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;iPCA&quot;</span>
            <span class="p">):</span>

                <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Try some stuff to help memory management. I think  a lot of memory is not being explicitly released</span>
                <span class="c1">#   here when I&#39;m looping, because I can watch my swap usage steadily grow while it&#39;s running this loop.</span>
                <span class="c1"># https://stackoverflow.com/questions/1316767/how-can-i-explicitly-free-memory-in-python has some good</span>
                <span class="c1">#   details  on how memory may be freed by Python, but not necessarily recognized  as free by the OS.</span>
                <span class="c1"># One &quot;guaranteed&quot; way to free  memory back to the OS that&#39;s been released by Python is to do  the memory</span>
                <span class="c1">#   intensive operation  in a subprocess. So, maybe I need to do my partial fit in a subprocess.</span>
                <span class="c1"># In fact, I first moved partial_fit alone to a subprocess, but that didn&#39;t help. The issue isn&#39;t</span>
                <span class="c1">#   partial_fit, it&#39;s actually loading the coords.</span>
                <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                    <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                    <span class="n">ipca</span><span class="p">,</span> <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">do_full_pca</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">ipca</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">,</span> <span class="n">components_for_var</span><span class="p">],</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">ipca</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">components_for_var</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: I  don&#39;t think trajSet is initialized by itself -- you need to manually call get_traj_coordinates</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;VAMP dimensionality reduction requires you to *manually* call get_traj_coordinates first, &quot;</span>
                <span class="s2">&quot;or self.trajSet will be all None. Make sure you&#39;ve done that!&quot;</span>
            <span class="p">)</span>

            <span class="n">ntraj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ntraj</span>
            <span class="k">for</span> <span class="n">itraj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntraj</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">itraj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">[</span><span class="n">itraj</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">vamp</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">lag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span><span class="p">,</span>
                <span class="n">scaling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">)</span>

            <span class="c1"># TODO: Why is this unused?</span>
            <span class="c1"># data = self.all_coords.reshape(-1, self.ndim)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">()</span></div>
            <span class="c1"># self.coordinates.transform = self.processCoordinates</span>

<div class="viewcode-block" id="modelWE.Coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.Coordinates">[docs]</a>    <span class="k">class</span> <span class="nc">Coordinates</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fake Coordinates class, in case you don&#39;t want to use either PCA or VAMP for dimensionality reduction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The class &quot;constructor&quot; - It&#39;s actually an initializer</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;coordinate object&quot;</span>

        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coords</span></div>

<div class="viewcode-block" id="modelWE.reduceCoordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.reduceCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This performs the dimensionality reduction.</span>

<span class="sd">        dimReduce() defines self.coordinates, which is an object that has a .transform() function that produces the</span>
<span class="sd">        reduced data.</span>

<span class="sd">        reduceCoordinates() actually uses that coordinates object, transforms the coordinates,</span>
<span class="sd">        and returns the reduced data.</span>

<span class="sd">        The reduced coordinates are then stored in /auxdata for each iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords: array-like</span>
<span class="sd">            Array of coordinates to reduce.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Reduced data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reducing coordinates&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span>
        <span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coords</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dimReduceMethod undefined in reduceCoordinates&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.update_cluster_structures"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.update_cluster_structures">[docs]</a>    <span class="k">def</span> <span class="nf">update_cluster_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find structures (i.e. sets of coordinates) corresponding to each clusters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A dictionary where the keys are cluster indices, and the values are lists of coordinates (structures)</span>
<span class="sd">            in that cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Obtaining cluster structures...&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Clusters have not been computed!&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dtrajs len: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">)</span><span class="si">}</span><span class="s2">, [0] shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">cluster_structures</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Move this elsewhere, WE segment weights are useful to have outside of this</span>
        <span class="n">all_seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">)),</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># total_num_iterations = len(self.numSegments)</span>
        <span class="n">total_num_iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span>
        <span class="c1"># Don&#39;t include the last iteration, where dynamics didn&#39;t run</span>
        <span class="k">for</span> <span class="n">_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">iter_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span><span class="p">[</span><span class="n">_iter</span><span class="p">]</span>

            <span class="c1"># This is an array, not a dict, so index by... well, index, and not iter_number</span>
            <span class="n">num_segs_in_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[</span><span class="n">_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># log.debug(f&quot;Found {num_segs_in_iter} in iter {_iter}&quot;)</span>
            <span class="c1"># log.debug(f&quot;Updating indices {i} :  {i + num_segs_in_iter}&quot;)</span>

            <span class="k">assert</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iter_weights</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;None in iter </span><span class="si">{</span><span class="n">_iter</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">iter_weights</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">all_seg_weights</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">num_segs_in_iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">iter_weights</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="n">num_segs_in_iter</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">all_seg_weights</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> seg weights&quot;</span><span class="p">)</span>

        <span class="c1"># Assign each segment to a cluster by iterating over coords</span>
        <span class="c1"># Track the &quot;absolute&quot; segment index because all_seg_weights is a flat list</span>
        <span class="n">seg_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

            <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
            <span class="n">segs_in_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">_seg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segs_in_iter</span><span class="p">):</span>

                <span class="c1"># log.debug(f&quot;Iteration {iteration}, segment {_seg}, segs in iter {segs_in_iter}&quot;)</span>
                <span class="c1"># iteration-1 because dtrajs has n_iterations-1 elements</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cluster_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">_seg</span><span class="p">]</span>

                <span class="c1"># This *should* trip if there was no data for this segments</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Tried to get dtraj for seg </span><span class="si">{</span><span class="n">_seg</span><span class="si">}</span><span class="s2"> at iteration </span><span class="si">{</span><span class="n">iteration</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;This dtraj point was in a removed cluster -- this should never happen!&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># log.debug(f&quot;Skipping cluster {cluster_idx}&quot;)</span>
                    <span class="c1"># continue</span>

                <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">cluster_structures</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">seg_coords</span> <span class="o">=</span> <span class="n">iter_coords</span><span class="p">[</span><span class="n">_seg</span><span class="p">]</span>
                <span class="n">cluster_structures</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">)</span>
                <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_seg_weights</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">])</span>

                <span class="n">seg_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">cluster_structure_weights</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">),</span> <span class="s2">&quot;Structures and weights have different numbers of bins?&quot;</span>

        <span class="n">test_cluster</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_structures</span><span class="p">[</span><span class="n">test_cluster</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">test_cluster</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;First MSM bin has different numbers of structures and weights&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structures</span> <span class="o">=</span> <span class="n">cluster_structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="n">cluster_structure_weights</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cluster structure mapping completed.&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster keys are </span><span class="si">{</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">do_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>

        <span class="n">kmeans_model</span><span class="p">,</span> <span class="n">iters_to_use</span><span class="p">,</span> <span class="n">cluster_args</span><span class="p">,</span> <span class="n">processCoordinates</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="c1"># Cast to a list in case it&#39;s a np array</span>
        <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">)</span>

        <span class="n">iteration</span> <span class="o">=</span> <span class="n">iters_to_use</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">min_coords</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># The first time we cluster, we need at least n_clusters datapoints.</span>
        <span class="c1"># Before the first clustering has been done, cluster_centers_ is unset, so use that to know if  we&#39;re  on the</span>
        <span class="c1">#   first round.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kmeans_model</span><span class="p">,</span> <span class="s2">&quot;cluster_centers_&quot;</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;First batch to k-means, need a minimum of </span><span class="si">{</span><span class="n">cluster_args</span><span class="p">[</span><span class="s1">&#39;n_clusters&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> segments&quot;</span>
            <span class="p">)</span>
            <span class="n">min_coords</span> <span class="o">=</span> <span class="n">cluster_args</span><span class="p">[</span><span class="s2">&quot;n_clusters&quot;</span><span class="p">]</span>

        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="n">used_iters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Keep adding coords until you have more than your components</span>
        <span class="k">while</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">min_coords</span><span class="p">:</span>

            <span class="n">iteration</span> <span class="o">=</span> <span class="n">iters_to_use</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">used_iters</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Have </span><span class="si">{</span><span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, need </span><span class="si">{</span><span class="n">min_coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>

        <span class="n">kmeans_model</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kmeans_model</span><span class="p">,</span> <span class="n">used_iters</span>

    <span class="k">def</span> <span class="nf">do_discretization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>

        <span class="n">kmeans_model</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">processCoordinates</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="n">used_iters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Keep adding coords until you have more than your components</span>
        <span class="c1"># This actually isn&#39;t necessary here like it is for the clustering, I could just return an empty array</span>
        <span class="k">while</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">used_iters</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="n">used_iters</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>

        <span class="n">dtrajs</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>

        <span class="c1"># log.debug(f&quot;Took {used_iters} extra iterations to process iteration {iteration}&quot;)</span>

        <span class="k">return</span> <span class="n">dtrajs</span><span class="p">,</span> <span class="n">used_iters</span>

    <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span>
    <span class="k">def</span> <span class="nf">do_ray_discretization</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kmeans_model</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">processCoordinates</span><span class="p">):</span>

        <span class="c1"># model_id, kmeans_model_id, iteration, processCoordinates_id = arg</span>

        <span class="c1"># self = ray.get(model_id)</span>
        <span class="c1"># kmeans_model = ray.get(kmeans_model_id)</span>
        <span class="c1"># processCoordinates = ray.get(processCoordinates_id)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># Need to do this so the model&#39;s transformation array is writable -- otherwise predict chokes</span>
        <span class="c1">#   with &#39;buffer source array is read-only&#39;.</span>
        <span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kmeans_model</span><span class="p">)</span>

        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># If there are no coords for this iteration, return None</span>
        <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iteration</span>

        <span class="c1"># Otherwise, apply the k-means model and discretize</span>
        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>
        <span class="n">dtrajs</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dtrajs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iteration</span>

    <span class="k">def</span> <span class="nf">cluster_coordinates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="p">,</span>
        <span class="n">streaming</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">first_cluster_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_ray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">stratified</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">iters_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_cluster_args</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Be aware: Number of cluster centers is an important parameter, and can drastically affect model &quot;</span>
            <span class="s2">&quot;quality. We recommend examining block-validation results with a range of numbers of clusters, to &quot;</span>
            <span class="s2">&quot;check for overfitting.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">stratified</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Beginning stratified clustering.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">=</span> <span class="s2">&quot;stratified&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_stratified</span><span class="p">(</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
                <span class="n">streaming</span><span class="o">=</span><span class="n">streaming</span><span class="p">,</span>
                <span class="n">first_cluster_iter</span><span class="o">=</span><span class="n">first_cluster_iter</span><span class="p">,</span>
                <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span>
                <span class="n">iters_to_use</span><span class="o">=</span><span class="n">iters_to_use</span><span class="p">,</span>
                <span class="o">**</span><span class="n">_cluster_args</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Make sure you know what you&#39;re doing if using this!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Beginning aggregate clustering. (Beware! This can produce poor clustering)&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">=</span> <span class="s2">&quot;aggregated&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_aggregated</span><span class="p">(</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
                <span class="n">streaming</span><span class="o">=</span><span class="n">streaming</span><span class="p">,</span>
                <span class="n">first_cluster_iter</span><span class="o">=</span><span class="n">first_cluster_iter</span><span class="p">,</span>
                <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span>
                <span class="n">iters_to_use</span><span class="o">=</span><span class="n">iters_to_use</span><span class="p">,</span>
                <span class="o">**</span><span class="n">_cluster_args</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Do this so you can use it for building the validation models.</span>
        <span class="c1">#   We directly modify the clusters in cleaning, so this is the easiest way of recreating the original,</span>
        <span class="c1">#   &quot;unclean&quot; validation model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_cluster_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="modelWE.cluster_aggregated"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.cluster_aggregated">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_aggregated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="p">,</span>
        <span class="n">streaming</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">first_cluster_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_ray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">iters_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_cluster_args</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use k-means to cluster coordinates into `n_clusters` cluster centers, and saves the resulting cluster object</span>
<span class="sd">        to a file.</span>

<span class="sd">        Saved cluster file is named</span>
<span class="sd">        &quot;&lt;`self.model_name`&gt;_clusters_s&lt;`self.first_iter`&gt;_e&lt;`self.last_iter`&gt;_nC&lt;`self.n_clusters`&gt;.h5&quot;</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.n_clusters`</span>
<span class="sd">            - `self.clusters`</span>
<span class="sd">            - `self.clusterFile`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters: int</span>
<span class="sd">            Number of cluster centers to use.</span>

<span class="sd">        streaming: boolean</span>
<span class="sd">            Whether to stream k-means clustering, or load all from memory.</span>
<span class="sd">            Not supported for vamp dimensionality reduction.</span>

<span class="sd">        **_cluster_args:</span>
<span class="sd">            Keyword arguments that will be passed directly to cluster_kmeans</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doing clustering on </span><span class="si">{</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>

        <span class="c1"># Have to do this instead of setting a default argument so that we can specify custom iterations to use</span>
        <span class="k">if</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">first_cluster_iter</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_cluster_iter</span> <span class="o">=</span> <span class="n">first_cluster_iter</span>
        <span class="c1"># streaming = False</span>

        <span class="c1"># This is a bit of a gnarly chain of if statements, but it handles checking whether a user explicitly passed</span>
        <span class="c1">#   these arguments.</span>
        <span class="c1"># If you haven&#39;t specified a range of iterations to use, then go with first_cluster_iter</span>
        <span class="k">if</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">first_cluster_iter</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_cluster_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_cluster_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Conflicting parameters -- either iters_to_use OR first_cluster_iter should be provided, not both.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># iters_to_use was provided, and first_cluster_iter was not</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="s2">&quot;metric&quot;</span> <span class="ow">in</span> <span class="n">_cluster_args</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;k&quot;</span> <span class="ow">in</span> <span class="n">_cluster_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;You&#39;re passing pyemma-style arguments to k-means. K-means now uses sklearn, please update&quot;</span>
                <span class="s2">&quot;your code accordingly.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;PyEmma style arguments passed to kmeans, which is now based on sklearn&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set some default arguments, and overwrite them with the user&#39;s choices if provided</span>
        <span class="n">cluster_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span> <span class="n">n_clusters</span><span class="p">,</span>
            <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">cluster_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_cluster_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">streaming</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">mini_kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>
            <span class="c1"># TODO: Any mini_batch_kmeans specific arguments?</span>

        <span class="k">elif</span> <span class="n">streaming</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Streaming clustering is not supported for dimReduceMethod &#39;none&#39;. Using standard k-means.&quot;</span>
            <span class="p">)</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>

                <span class="c1"># TODO: Fix this to correctly use processCoordinates, like in the streaming case</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Non-streaming dimreduce None is currently broken&quot;</span>
                <span class="p">)</span>

                <span class="n">_data</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">iters_to_use</span>
                <span class="p">]</span>
                <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>

                <span class="c1"># Else here is a little sketchy, but fractional nAtoms is useful for some debugging hacks.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">_data</span>
                <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">iter_idx</span><span class="p">,</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering&quot;</span><span class="p">)</span>
                <span class="p">):</span>

                    <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                        <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                    <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                        <span class="n">cluster_model</span><span class="p">,</span> <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">do_clustering</span><span class="p">,</span>
                            <span class="p">[</span>
                                <span class="n">cluster_model</span><span class="p">,</span>
                                <span class="p">[</span><span class="n">iters_to_use</span><span class="p">[</span><span class="n">iter_idx</span><span class="p">]],</span>
                                <span class="n">cluster_args</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">,</span>
                            <span class="p">],</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span>

                <span class="c1"># Now compute dtrajs from the final model</span>
                <span class="c1"># TODO: Do I want to always discretize the full data?</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">):</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
                    <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span> <span class="ow">and</span> <span class="n">streaming</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># continued = False</span>
            <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iter_idx</span><span class="p">,</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering&quot;</span><span class="p">)</span>
            <span class="p">):</span>

                <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                    <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                    <span class="n">cluster_model</span><span class="p">,</span> <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">do_clustering</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="n">cluster_model</span><span class="p">,</span>
                            <span class="n">iters_to_use</span><span class="p">[</span><span class="n">iter_idx</span><span class="p">:],</span>
                            <span class="n">cluster_args</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">,</span>
                        <span class="p">],</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span>

            <span class="c1"># Now compute dtrajs from the final model</span>
            <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># If we&#39;re not using Ray, then calculate serially</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_ray</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Discretization&quot;</span>
                <span class="p">):</span>

                    <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                        <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                    <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                        <span class="n">dtrajs</span><span class="p">,</span> <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">do_discretization</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">cluster_model</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">],</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtrajs</span><span class="p">)</span>

            <span class="c1"># If we want to use Ray</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># First, connect to the ray cluster</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">check_connect_ray</span><span class="p">()</span>

                <span class="c1"># Submit all the discretization tasks to the cluster</span>
                <span class="n">task_ids</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">cluster_model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">cluster_model</span><span class="p">)</span>
                <span class="n">process_coordinates_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">)</span>

                <span class="c1"># max_inflight = 50</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Submitting discretization tasks&quot;</span>
                <span class="p">):</span>

                    <span class="c1"># if len(task_ids) &gt; max_inflight:</span>
                    <span class="c1">#</span>
                    <span class="c1">#     # The number that need to be ready before we can submit more</span>
                    <span class="c1">#     num_ready = iteration - max_inflight</span>
                    <span class="c1">#     ray.wait(task_ids, num_returns=num_ready)</span>

                    <span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_ray_discretization</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span>
                        <span class="n">model_id</span><span class="p">,</span> <span class="n">cluster_model_id</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">process_coordinates_id</span>
                    <span class="p">)</span>
                    <span class="n">task_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>

                <span class="c1"># As they&#39;re completed, add them to dtrajs</span>
                <span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Do these in bigger batches, dtrajs aren&#39;t very big</span>

                <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Retrieving discretized trajectories&quot;</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
                    <span class="k">while</span> <span class="n">task_ids</span><span class="p">:</span>
                        <span class="n">result_batch_size</span> <span class="o">=</span> <span class="mi">50</span>
                        <span class="n">result_batch_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">))</span>

                        <span class="c1"># Returns the first ObjectRef that is ready, with a 20s timeout</span>
                        <span class="n">finished</span><span class="p">,</span> <span class="n">task_ids</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                            <span class="n">task_ids</span><span class="p">,</span> <span class="n">num_returns</span><span class="o">=</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span>
                        <span class="p">)</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">dtraj</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                            <span class="n">dtrajs</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtraj</span>
                            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

                <span class="c1"># Remove all empty elements from dtrajs and assign to self.dtrajs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtraj</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="n">dtrajs</span> <span class="k">if</span> <span class="n">dtraj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span> <span class="ow">and</span> <span class="n">streaming</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;VAMP + streaming clustering is not supported.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">streaming</span>
        <span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
                <span class="n">transformed_data</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">iters_to_use</span><span class="p">:</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                    <span class="c1"># Skip if  this is an empty iteration</span>
                    <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">transformed_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Appended trajs for iter </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">transformed_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">transformed_data</span>
                <span class="p">]</span>

            <span class="c1"># TODO: Make sure this is returned in the shape (iteration, ...)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Clustering VAMP-reduced data still very experimental!&quot;</span><span class="p">)</span>

                <span class="n">transformed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">get_output</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">transformed_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">transformed_data</span>
                <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusterFile</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;_clusters_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_nC&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span>
        <span class="p">)</span>

        <span class="c1"># self.dtrajs = self.clusters.dtrajs</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Clustering completed.&quot;</span><span class="p">)</span></div>
        <span class="c1"># log.debug(f&quot;Dtrajs: {self.clusters.dtrajs}&quot;)</span>
        <span class="c1"># self.clusters.save(self.clusterFile, save_streaming_chain=True, overwrite=True)</span>

<div class="viewcode-block" id="modelWE.cluster_stratified"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.cluster_stratified">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_stratified</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_clusters</span><span class="p">,</span>
        <span class="n">streaming</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">first_cluster_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_ray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">bin_iteration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">iters_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">user_bin_mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_cluster_args</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform full-stratified clustering, enforcing independent clustering for trajectories within each WE bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters: int</span>
<span class="sd">            Number of cluster centers per WE bin.</span>

<span class="sd">        streaming: bool (default True)</span>
<span class="sd">            Must be True for now.</span>

<span class="sd">        first_cluster_iter: int</span>
<span class="sd">            Iteration to start clustering on.</span>
<span class="sd">            Discretization is always done on all iteration, but it may not be necessary or desirable to use all to</span>
<span class="sd">            cluster.</span>

<span class="sd">        use_ray: bool (default True)</span>
<span class="sd">            Must be True for now.</span>

<span class="sd">        bin_iteration: int (default 2)</span>
<span class="sd">            Iteration to obtain bin definitions from.</span>

<span class="sd">        iters_to_use: array-like (default [1, model.maxIter])</span>
<span class="sd">            Specific set of iterations to cluster on.</span>

<span class="sd">        **_cluster_args:</span>
<span class="sd">            Arguments passed through to sklearn.cluster.MiniBatchKMeans</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        Allow directly passing in a bin mapper or equivalent here. Way easier than trying to reverse engineer one.</span>
<span class="sd">        Require it if the existing is not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This provides backwards compatibility when loading WESTPA data from simulations where binning lived in westpa.binning</span>
        <span class="c1"># It&#39;s a little sketchy, but it import westpa.tools.binning under westpa.binning</span>
        <span class="kn">import</span> <span class="nn">importlib</span>
        <span class="kn">import</span> <span class="nn">westpa</span>

        <span class="n">westpa</span><span class="o">.</span><span class="n">binning</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;westpa.tools.binning&quot;</span><span class="p">,</span> <span class="s2">&quot;westpa.tools&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">user_bin_mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading user-specified bin mapper for stratified clustering.&quot;</span><span class="p">)</span>
            <span class="n">bin_mapper</span> <span class="o">=</span> <span class="n">user_bin_mapper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Obtaining bin definitions from iteration </span><span class="si">{</span><span class="n">bin_iteration</span><span class="si">}</span><span class="s2"> in file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">iteration</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">iteration</span><span class="p">(</span><span class="n">bin_iteration</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading pickled bin mapper from H5 for stratified clustering...&quot;</span><span class="p">)</span>
            <span class="n">bin_mapper</span> <span class="o">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">bin_mapper</span>

            <span class="c1"># Problem: I need a consistent set of bins, and some bin mappers may not return that! Some may re-calculate bins</span>
            <span class="c1">#    on-the-fly whenever data is passed to them, which will produce different bins for each iteration.</span>
            <span class="c1">#   In particular, ones that may are really any functional mapper:</span>
            <span class="c1">#   -   MABBinMapper will by construction never return bins that have everything populated, and by default,</span>
            <span class="c1">#       calculates boundaries on the fly</span>
            <span class="c1">#   -   PiecewiseBinMapper/VectorizingFuncBinMapper/FuncBinMapper are also function-based so they may do whatever</span>
            <span class="c1">#   Ones that won&#39;t:</span>
            <span class="c1">#   -   VoronoiBinMapper takes in a set of centers when it&#39;s initialized, so it&#39;ll be consistent</span>
            <span class="c1">#   -   Rectilinear is of course always consistent</span>
            <span class="c1"># Ideally, the best approach here would be to go through your bin mapper, recursing as necessary, and replacing</span>
            <span class="c1">#   any of the above functional bin mapper types with static bin mappers.</span>

            <span class="n">supported_mappers</span> <span class="o">=</span> <span class="p">[</span><span class="n">RectilinearBinMapper</span><span class="p">,</span> <span class="n">VoronoiBinMapper</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_mappers</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span><span class="si">}</span><span class="s2"> mapper loaded, but supported mappers are </span><span class="si">{</span><span class="n">supported_mappers</span><span class="si">}</span><span class="s2"> and others may&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;produce inconsistent bins between iterations. Please provide a supported user_bin_mapper.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>

            <span class="c1"># TODO: Before moving on, make sure it&#39;s actually possible to populate each bin with enough segments to</span>
            <span class="c1">#       cluster at least once from the given set of iterations.</span>
            <span class="c1">#   In other words, just load up pcoords iteration by iteration, and count the total number in each bin.</span>
            <span class="c1">#   Note that it&#39;s possible you&#39;ll end up clustering in a bin once, but then pulling too few in that bin for</span>
            <span class="c1">#       the rest of the iterations after that, or something like that.</span>
            <span class="c1">#   The alternative to this would be in do_stratified_clustering(), if a bin isn&#39;t populated, check every</span>
            <span class="c1">#       subsequent iteration and see if it&#39;s possible to populate it from them.</span>
            <span class="c1">#   This is a little more flexible/dynamic, however, I think it may potentially require much more looping</span>
            <span class="c1">#       through iterations.</span>

        <span class="c1"># Clustering will not be performed in these bins</span>
        <span class="n">ignored_bins</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_ray</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Stratified clustering currently MUST run in streaming mode (and with ray enabled for &quot;</span>
                <span class="s2">&quot;discretization). Enabling both and continuing...&quot;</span>
            <span class="p">)</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">use_ray</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Do the streaming clustering, but cluster each bin individually.</span>
        <span class="n">stratified_clusters</span> <span class="o">=</span> <span class="n">StratifiedClusters</span><span class="p">(</span>
            <span class="n">bin_mapper</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">ignored_bins</span><span class="p">,</span> <span class="o">**</span><span class="n">_cluster_args</span>
        <span class="p">)</span>

        <span class="c1"># This is a bit of a gnarly chain of if statements, but it handles checking whether a user explicitly passed</span>
        <span class="c1">#   these arguments.</span>
        <span class="c1"># If you haven&#39;t specified a range of iterations to use, then go with first_cluster_iter</span>
        <span class="k">if</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">first_cluster_iter</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_cluster_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_cluster_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_cluster_iter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Conflicting parameters -- either iters_to_use OR first_cluster_iter should be provided, not both.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># iters_to_use was provided, and first_cluster_iter was not</span>
            <span class="k">pass</span>

        <span class="c1"># ## Build the clustering model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">all_filled_bins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">all_unfilled_bins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iter_idx</span><span class="p">,</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering&quot;</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">ignored_bins</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">stratified_clusters</span><span class="p">,</span>
                    <span class="n">extra_iters_used</span><span class="p">,</span>
                    <span class="n">filled_bins</span><span class="p">,</span>
                    <span class="n">unfilled_bins</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">do_stratified_clustering</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="p">,</span>
                        <span class="n">stratified_clusters</span><span class="p">,</span>
                        <span class="n">iters_to_use</span><span class="p">[</span><span class="n">iter_idx</span><span class="p">:],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">,</span>
                        <span class="n">ignored_bins</span><span class="p">,</span>
                    <span class="p">],</span>
                <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

                <span class="n">all_filled_bins</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">filled_bins</span><span class="p">)</span>
                <span class="n">all_unfilled_bins</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">unfilled_bins</span><span class="p">)</span>

        <span class="c1"># all_filled_bins holds every bin that was clustered in</span>
        <span class="c1"># all_unfilled_bins holds any bin that was ever attempted, but unfilled</span>
        <span class="c1"># so, get the unfilled that were unfilled always, and never got clustered in</span>
        <span class="n">true_unfilled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_filled_bins</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled bins are </span><span class="si">{</span><span class="n">all_filled_bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unfilled bins were </span><span class="si">{</span><span class="n">all_unfilled_bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True unfilled bins are </span><span class="si">{</span><span class="n">true_unfilled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">unfilled_bin_idx</span> <span class="ow">in</span> <span class="n">true_unfilled</span><span class="p">:</span>
            <span class="n">remap_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_bin</span><span class="p">(</span>
                <span class="n">bin_mapper</span><span class="p">,</span> <span class="n">unfilled_bin_idx</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_filled_bins</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">stratified_clusters</span><span class="o">.</span><span class="n">we_remap</span><span class="p">[</span><span class="n">unfilled_bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">remap_bin</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Remapped </span><span class="si">{</span><span class="n">unfilled_bin_idx</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">remap_bin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># make sure this doesn&#39;t mess up we_remap later.. I think it should be fine, when I write to we_remap in the cleaning</span>
        <span class="c1">#       it should identify a superset of the bins identified here.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">stratified_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1">## The below -1 was removed, because now I may specify a custom set of WE bins</span>
        <span class="c1">## -1 because we don&#39;t cluster in the target</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span> <span class="o">*</span> <span class="p">(</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">launch_ray_discretization</span><span class="p">()</span></div>

<div class="viewcode-block" id="modelWE.find_nearest_bin"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.find_nearest_bin">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_nearest_bin</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">,</span> <span class="n">filled_bins</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a bin mapper, find the bin closest to bin_idx (that isn&#39;t bin_idx).</span>

<span class="sd">        Do this Voronoi-style by obtaining a set of bin centers, and finding which center bin_idx is closest to.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_mapper</span>
<span class="sd">        bin_idx</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index of the closest bin.</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        Note in the documentation that this can be overriden for finer control over empty bin mapping, if so desired.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">filled_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Can&#39;t find nearest populated bin -- no WE bins are populated with clusters! &quot;</span>
            <span class="s2">&quot;Try fewer clusters/bin.&quot;</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">VoronoiBinMapper</span><span class="p">,</span>
            <span class="n">RectilinearBinMapper</span><span class="p">,</span>
        <span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span><span class="si">}</span><span class="s2"> is unsupported!&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span> <span class="ow">is</span> <span class="n">VoronoiBinMapper</span><span class="p">:</span>

            <span class="n">centers</span> <span class="o">=</span> <span class="n">bin_mapper</span><span class="o">.</span><span class="n">centers</span>
            <span class="n">distance_function</span> <span class="o">=</span> <span class="n">bin_mapper</span><span class="o">.</span><span class="n">dfunc</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_mapper</span><span class="p">)</span> <span class="ow">is</span> <span class="n">RectilinearBinMapper</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_rmsd</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">_centers</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">_centers</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">distance_function</span> <span class="o">=</span> <span class="n">_rmsd</span>

            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">boundaries</span><span class="p">)</span>
            <span class="n">_centers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
                <span class="n">_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">dim</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">_centers</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1"># Remove both the bin you&#39;re looking at, and any other unfilled bins</span>
        <span class="c1"># all_ignored = np.concatenate([[bin_idx], unfilled_bins])</span>

        <span class="c1"># Ignore any bin that isn&#39;t an explicitly provided filled bin</span>
        <span class="n">all_ignored</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">filled_bins</span><span class="p">)</span>
        <span class="n">other_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">all_ignored</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">closest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance_function</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span> <span class="n">other_centers</span><span class="p">))</span>

        <span class="c1"># Increment index if it&#39;s past the ones we deleted</span>
        <span class="k">for</span> <span class="n">_bin_idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_ignored</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">closest</span> <span class="o">&gt;=</span> <span class="n">_bin_idx</span><span class="p">:</span>
                <span class="n">closest</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">closest</span></div>

<div class="viewcode-block" id="modelWE.do_stratified_clustering"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.do_stratified_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">do_stratified_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the full-stratified clustering.</span>

<span class="sd">        This works as follows:</span>

<span class="sd">            1. Pull coordinates from the first iteration to process</span>
<span class="sd">            2. Assign each segment to a WE bin, using its pcoord and the bin_mapper associated with this StratifiedCluster</span>
<span class="sd">                object.</span>
<span class="sd">            3a. If any of the seen WE bins have fewer segments than cluster centers, and there are more iterations left</span>
<span class="sd">                to process, repeat from 1.</span>
<span class="sd">                - Note that this may add NEW seen bins, and those new seen bins may not be full yet -- so more iterations</span>
<span class="sd">                    may be required.</span>
<span class="sd">            3b. If any seen WE bins have fewer segments than cluster centers, **but no iterations are left to process**,</span>
<span class="sd">                then assign each structure in an &quot;unfilled&quot; WE bin to the &quot;filled&quot; WE bin with the closest index.,</span>

<span class="sd">            At this point, we have a set of structures and the WE bins they&#39;re associated with, and each WE bin has a</span>
<span class="sd">            number of structures equal to or greater than the target number of cluster centers.</span>

<span class="sd">            Within each WE bin:</span>

<span class="sd">            4. Apply dimensionality reduction to structures</span>
<span class="sd">            5. Update clustering for that bin using this set of dimensionality reduced coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="p">,</span> <span class="n">kmeans_models</span><span class="p">,</span> <span class="n">iters_to_use</span><span class="p">,</span> <span class="n">processCoordinates</span><span class="p">,</span> <span class="n">ignored_bins</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="c1"># Cast to a list in case it&#39;s a np array</span>
        <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">)</span>

        <span class="n">bin_mapper</span> <span class="o">=</span> <span class="n">kmeans_models</span><span class="o">.</span><span class="n">bin_mapper</span>

        <span class="n">min_coords</span> <span class="o">=</span> <span class="n">kmeans_models</span><span class="o">.</span><span class="n">cluster_args</span><span class="p">[</span><span class="s2">&quot;n_clusters&quot;</span><span class="p">]</span>

        <span class="c1"># The number of populated bins is the number of total bins - 1</span>
        <span class="n">all_bins_have_segments</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Until all bins are populated</span>
        <span class="n">used_iters</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">iter_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">we_bin_assignments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Maybe not even necessary to track iter_coords, just _iter_coords.</span>
        <span class="c1"># The problem with it as it stands is that assert -- imagine if I have to grab a second iteration</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">all_bins_have_segments</span><span class="p">:</span>
            <span class="n">unfilled_bins</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># This may cover the same use case as iteration &gt; self.maxIter below</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">iteration</span> <span class="o">=</span> <span class="n">iters_to_use</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;At iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2"> (pulled </span><span class="si">{</span><span class="n">used_iters</span><span class="si">}</span><span class="s2"> extra), couldn&#39;t get segments in all bins, and no &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;iterations left.&quot;</span>
                <span class="p">)</span>

                <span class="c1"># Which bin didn&#39;t have enough clusters?</span>
                <span class="n">unfilled_bins</span> <span class="o">=</span> <span class="n">unique_bins</span><span class="p">[</span><span class="n">counts</span> <span class="o">&lt;</span> <span class="n">min_coords</span><span class="p">]</span>
                <span class="n">filled_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">,</span> <span class="n">unfilled_bins</span><span class="p">)</span>

                <span class="c1"># Find the nearest non-empty bin</span>
                <span class="k">for</span> <span class="n">unfilled_bin</span> <span class="ow">in</span> <span class="n">unfilled_bins</span><span class="p">:</span>

                    <span class="n">nearest_filled_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_bin</span><span class="p">(</span>
                        <span class="n">bin_mapper</span><span class="p">,</span> <span class="n">unfilled_bin</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">filled_bins</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="n">unfilled_bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">we_bin_assignments</span> <span class="o">==</span> <span class="n">unfilled_bin</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Remapping </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unfilled_bin_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> segments from unfilled bin </span><span class="si">{</span><span class="n">unfilled_bin</span><span class="si">}</span><span class="s2"> to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nearest_filled_bin</span><span class="si">}</span><span class="s2"> for stratified clustering&quot;</span>
                    <span class="p">)</span>
                    <span class="n">we_bin_assignments</span><span class="p">[</span><span class="n">unfilled_bin_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_filled_bin</span>

                <span class="c1"># Remove unfilled bins from unique_bins</span>
                <span class="n">unique_bins</span> <span class="o">=</span> <span class="n">filled_bins</span>

                <span class="k">break</span>

            <span class="k">if</span> <span class="n">used_iters</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Still missing segs in bin </span><span class="si">{</span><span class="n">unique_bins</span><span class="p">[</span><span class="n">counts</span> <span class="o">&lt;</span> <span class="n">min_coords</span><span class="p">]</span><span class="si">}</span><span class="s2">. Pulled </span><span class="si">{</span><span class="n">used_iters</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> extra iter&quot;</span>
                <span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Had </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">,</span> <span class="n">counts</span><span class="p">))</span><span class="si">}</span><span class="s2">, need </span><span class="si">{</span><span class="n">min_coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
                <span class="c1"># TODO: Is this always a deal-breaker?</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;At iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2"> (pulled </span><span class="si">{</span><span class="n">used_iters</span><span class="si">}</span><span class="s2"> extra), couldn&#39;t get segments in all bins, and no &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;iterations left&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="n">used_iters</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">used_iters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">_iter_coords</span>
                <span class="n">pcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">pcoords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;After extension, pcoords: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pcoords</span><span class="p">)</span><span class="si">}</span><span class="s2">, iter_coords: </span><span class="si">{</span><span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. Ignored: </span><span class="si">{</span><span class="n">ignored_bins</span><span class="si">}</span><span class="s2">. Mapper: </span><span class="si">{</span><span class="n">bin_mapper</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Map coords to WE bins</span>
            <span class="n">pcoord_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pcoords</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">pcoord_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Ignore any segments that are in the basis or target</span>
            <span class="n">pcoord_is_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="n">pcoord_array</span><span class="p">)</span>
            <span class="n">pcoord_is_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="n">pcoord_array</span><span class="p">)</span>
            <span class="n">pcoord_array</span> <span class="o">=</span> <span class="n">pcoord_array</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">pcoord_is_target</span> <span class="o">|</span> <span class="n">pcoord_is_basis</span><span class="p">)]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcoord_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">we_bin_assignments</span> <span class="o">=</span> <span class="n">bin_mapper</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">pcoord_array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;No coordinates outside of basis/target, we_bin_assignments will be empty and clustering&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; will be skipped for this iteration. (</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">pcoord_is_target</span><span class="p">)</span><span class="si">}</span><span class="s2"> in target, </span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="n">pcoord_is_basis</span><span class="p">)</span><span class="si">}</span><span class="s2"> in basis)&quot;</span>
                <span class="p">)</span>
                <span class="n">we_bin_assignments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

            <span class="n">unique_bins</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">we_bin_assignments</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">all_bins_have_segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;=</span> <span class="n">min_coords</span><span class="p">)</span>

        <span class="c1"># By now, I have some segments in each WE bin.</span>
        <span class="c1"># Now, do clustering within each WE bin, and only cluster in WE bins that things were actually assigned to</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_bin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">):</span>

            <span class="n">segs_in_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">we_bin_assignments</span> <span class="o">==</span> <span class="n">_bin</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clustering </span><span class="si">{</span><span class="n">segs_in_bin</span><span class="si">}</span><span class="s2"> segments in WE bin </span><span class="si">{</span><span class="n">_bin</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="n">processCoordinates</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">[</span><span class="n">segs_in_bin</span><span class="p">]))</span>
            <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">kmeans_models</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">_bin</span><span class="p">]</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Was on bin </span><span class="si">{</span><span class="n">_bin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error fitting k-means to bin </span><span class="si">{</span><span class="n">_bin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">kmeans_models</span><span class="p">,</span> <span class="n">used_iters</span><span class="p">,</span> <span class="n">unique_bins</span><span class="p">,</span> <span class="n">unfilled_bins</span></div>

<div class="viewcode-block" id="modelWE.organize_stratified"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.organize_stratified">[docs]</a>    <span class="k">def</span> <span class="nf">organize_stratified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alternative to organize_fluxMatrix, for stratified clustering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_ray: bool</span>
<span class="sd">            If True, use Ray when calculating the cleaned fluxmatrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find disconnected states</span>
        <span class="n">fmatrix_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">fmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fmatrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">connected_sets</span> <span class="o">=</span> <span class="n">find_connected_sets</span><span class="p">(</span><span class="n">fmatrix</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">start_cleaning_idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connected_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nothing to clean&quot;</span><span class="p">)</span>
            <span class="c1">#         return</span>
            <span class="n">states_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># # Experimental</span>
            <span class="c1"># # I&#39;ve seen cases where I have two large disconnected sets of similar size, with problems that arise from cleaning</span>
            <span class="c1"># #   one entirely. I think maybe this is like two sides of a barrier, with weak connection between, so when you</span>
            <span class="c1"># #   do the cleaning basically everything on one side gets lumped together.</span>
            <span class="c1"># # To try and ameliorate this, what if we group together large clusters, and bank on the fact that after we clean</span>
            <span class="c1"># #   all the small isolated clusters, those large ones will be connected?</span>
            <span class="c1"># # This doesn&#39;t work :( After cleaning, these sets remain disconnected</span>
            <span class="c1">#</span>
            <span class="c1"># set_sizes = np.array([len(_set) for _set in connected_sets])</span>
            <span class="c1"># primary_set_size = set_sizes[0]</span>
            <span class="c1">#</span>
            <span class="c1"># # Keep any sets that are at least half the size of the primary set</span>
            <span class="c1"># start_cleaning_idx = np.argmin(set_sizes &gt; (primary_set_size//2)).flatten()[0]</span>
            <span class="c1"># log.info(f&quot;Merging sets of size {set_sizes[:start_cleaning_idx]} and cleaning the rest&quot;)</span>
            <span class="c1"># #</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cleaning states </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">connected_sets</span><span class="p">[</span><span class="n">start_cleaning_idx</span><span class="p">:])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">states_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">connected_sets</span><span class="p">[</span><span class="n">start_cleaning_idx</span><span class="p">:])</span>

        <span class="c1"># Does NOT include the basis/target -- none of these numbers of cluster centers should,</span>
        <span class="c1">#   since they&#39;re explicitly not clustered in</span>
        <span class="n">pre_cleaning_n_clusters_per_bin</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">cluster_model</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cluster_model</span><span class="p">,</span> <span class="s2">&quot;cluster_centers_&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">cluster_model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span>
        <span class="p">]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Pre-cleaning clusters per bin: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pre_cleaning_n_clusters_per_bin</span><span class="p">)),</span> <span class="n">pre_cleaning_n_clusters_per_bin</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">empty_we_bins</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># target, basis = self.clusters.target_bins, self.clusters.basis_bins</span>
        <span class="c1"># Go through each WE bin, finding which clusters within it are not in the connected set</span>
        <span class="c1">#    and removing them.</span>
        <span class="k">for</span> <span class="n">we_bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">):</span>

            <span class="n">consecutive_index</span> <span class="o">=</span> <span class="n">we_bin</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pre_cleaning_n_clusters_per_bin</span><span class="p">[:</span><span class="n">we_bin</span><span class="p">])</span>

            <span class="c1"># Get all the clusters that would be contained in this bin</span>
            <span class="c1"># clusters_in_bin = range(offset, offset + self.clusters.n_clusters_per_bin)</span>
            <span class="n">n_clusters_in_bin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">consecutive_index</span><span class="p">],</span> <span class="s2">&quot;cluster_centers_&quot;</span>
            <span class="p">):</span>
                <span class="n">n_clusters_in_bin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">consecutive_index</span><span class="p">]</span><span class="o">.</span><span class="n">cluster_centers_</span>
                <span class="p">)</span>
            <span class="c1"># Otherwise, this is an uninitialized bin.</span>
            <span class="c1"># Bins can be uninitialized in 2 cases -- completely unvisited, or a basis/target</span>
            <span class="c1"># Segments in a basis/target should not be mapped to other bins -- however, this is short-circuited in</span>
            <span class="c1">#   StratifiedClusters.predict(), so even if they&#39;re mapped to those cluster centers, it&#39;s fine.</span>

            <span class="n">clusters_in_bin</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">n_clusters_in_bin</span><span class="p">,)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster models len: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;WE Bin </span><span class="si">{</span><span class="n">we_bin</span><span class="si">}</span><span class="s2"> (consec. index </span><span class="si">{</span><span class="n">consecutive_index</span><span class="si">}</span><span class="s2">) contains </span><span class="si">{</span><span class="n">n_clusters_in_bin</span><span class="si">}</span><span class="s2"> clusters </span><span class="si">{</span><span class="n">clusters_in_bin</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Find which of the removed clusters are in this</span>
            <span class="n">bin_clusters_to_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">states_to_remove</span><span class="p">,</span> <span class="n">clusters_in_bin</span><span class="p">)</span>

            <span class="c1"># Before actually cleaning, check if we&#39;re not cleaning anything, or if we&#39;re cleaning everything</span>

            <span class="c1"># If not cleaning anything, just move on</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_clusters_to_clean</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not cleaning any clusters from bin </span><span class="si">{</span><span class="n">we_bin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters_in_bin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">empty_we_bins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">we_bin</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="c1"># If cleaning EVERYTHING, handle this bin differently</span>
            <span class="c1"># We&#39;ll just re-map it to a &quot;good&quot; adjacent WE bin</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_clusters_to_clean</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters_in_bin</span><span class="p">):</span>
                <span class="n">empty_we_bins</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">we_bin</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cleaning </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_clusters_to_clean</span><span class="p">)</span><span class="si">}</span><span class="s2"> clusters </span><span class="si">{</span><span class="n">bin_clusters_to_clean</span><span class="si">}</span><span class="s2"> from WE bin </span><span class="si">{</span><span class="n">we_bin</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">we_bin</span><span class="p">]</span><span class="o">.</span><span class="n">cluster_centers_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span><span class="n">we_bin</span><span class="p">]</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span>
                <span class="n">bin_clusters_to_clean</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Started with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters, and removed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">states_to_remove</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">states_to_remove</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_clusters is now </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="s2">&quot;All clusters would be cleaned! You probably need more data, fewer clusters, or both.&quot;</span>

        <span class="c1"># If a WE bin was completely emptied of cluster centers, map it to the nearest non-empty bin</span>
        <span class="n">populated_we_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">empty_we_bins</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_we_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All clusters were cleaned from bins </span><span class="si">{</span><span class="n">empty_we_bins</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">empty_we_bin</span> <span class="ow">in</span> <span class="n">empty_we_bins</span><span class="p">:</span>

            <span class="c1"># Find the nearest non-empty bin</span>
            <span class="n">nearest_populated_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_bin</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">bin_mapper</span><span class="p">,</span> <span class="n">empty_we_bin</span><span class="p">,</span> <span class="n">populated_we_bins</span>
            <span class="p">)</span>

            <span class="c1"># Replace self.clusters.cluster_models[empty_we_bin].cluster_centers_ with</span>
            <span class="c1">#   self.clusters.cluster_models[nearest_nonempty_we_bin].cluster_centers_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">we_remap</span><span class="p">[</span><span class="n">empty_we_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_populated_bin</span>

        <span class="n">_running_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">we_bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">bin_mapper</span><span class="o">.</span><span class="n">nbins</span><span class="p">):</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">clusters_in_bin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_models</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">we_remap</span><span class="p">[</span><span class="n">we_bin</span><span class="p">]</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">cluster_centers_</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error obtaining clusters for WE bin </span><span class="si">{</span><span class="n">we_bin</span><span class="si">}</span><span class="s2">, remapped to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">we_remap</span><span class="p">[</span><span class="n">we_bin</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Target </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">target_bins</span><span class="si">}</span><span class="s2">, basis </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">basis_bins</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

            <span class="n">_running_total</span> <span class="o">+=</span> <span class="n">clusters_in_bin</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clusters_in_bin</span><span class="si">}</span><span class="s2"> in bin </span><span class="si">{</span><span class="n">we_bin</span><span class="si">}</span><span class="s2">. Running total: </span><span class="si">{</span><span class="n">_running_total</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Now re-discretize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">launch_ray_discretization</span><span class="p">()</span>

        <span class="n">pcoord_sort_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_centers</span><span class="p">()</span>

        <span class="c1"># And recalculate the flux matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_fluxMatrix</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_fluxMatrixParams</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Set the cleaned matrix as fluxMatrix</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="n">fmatrix_original</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)}</span>

        <span class="c1"># Sanity check that cleaning worked</span>
        <span class="n">fmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fmatrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">connected_sets</span> <span class="o">=</span> <span class="n">find_connected_sets</span><span class="p">(</span><span class="n">fmatrix</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;After cleaning, shape is </span><span class="si">{</span><span class="n">fmatrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and disconnected sets are: </span><span class="si">{</span><span class="n">connected_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">connected_sets</span><span class="p">[</span><span class="n">start_cleaning_idx</span><span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;Still not clean after cleaning!&quot;</span></div>

<div class="viewcode-block" id="modelWE.launch_ray_discretization"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.launch_ray_discretization">[docs]</a>    <span class="k">def</span> <span class="nf">launch_ray_discretization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply discretization in parallel, through Ray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Todo</span>
<span class="sd">        ====</span>
<span class="sd">        Replace manual discretization calls in cluster_aggregated with this</span>
<span class="sd">        Add flag to toggle between stratified and regular do_ray_discretization</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_connect_ray</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Submit all the discretization tasks to the cluster</span>
        <span class="n">task_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cluster_model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
        <span class="n">process_coordinates_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">)</span>

        <span class="c1"># max_inflight = 50</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Submitting discretization tasks&quot;</span>
        <span class="p">):</span>

            <span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_stratified_ray_discretization</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span>
                <span class="n">model_id</span><span class="p">,</span> <span class="n">cluster_model_id</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">process_coordinates_id</span>
            <span class="p">)</span>
            <span class="n">task_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>

        <span class="c1"># As they&#39;re completed, add them to dtrajs</span>
        <span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Do these in bigger batches, dtrajs aren&#39;t very big</span>

        <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Retrieving discretized trajectories&quot;</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">task_ids</span><span class="p">:</span>
                <span class="n">result_batch_size</span> <span class="o">=</span> <span class="mi">50</span>
                <span class="n">result_batch_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">))</span>

                <span class="c1"># Returns the first ObjectRef that is ready, with a 20s timeout</span>
                <span class="n">finished</span><span class="p">,</span> <span class="n">task_ids</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                    <span class="n">task_ids</span><span class="p">,</span> <span class="n">num_returns</span><span class="o">=</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span>
                <span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">dtraj</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">target_bins</span><span class="p">,</span> <span class="n">basis_bins</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">target_bins</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">target_bins</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">basis_bins</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">basis_bins</span><span class="p">)</span>

                    <span class="n">dtrajs</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtraj</span>
                    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

        <span class="c1"># Remove all empty elements from dtrajs and assign to self.dtrajs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtraj</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="n">dtrajs</span> <span class="k">if</span> <span class="n">dtraj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Discretization complete&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_cluster_centers"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_cluster_centers">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standalone method to obtain average pcoords of all segments in each cluster.</span>

<span class="sd">        This functionality is contained in organize_fluxMatrix.</span>

<span class="sd">        TODO</span>
<span class="sd">        ====</span>
<span class="sd">        Remove duplicate code in organize_fluxMatrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the average pcoord of trajs in each bin</span>
        <span class="n">cluster_pcoord_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>
        <span class="n">target_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Target at -1</span>
        <span class="n">basis_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>  <span class="c1"># basis at -2</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basis, target are </span><span class="si">{</span><span class="n">basis_cluster_index</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">target_cluster_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span>

        <span class="n">cluster_pcoord_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">cluster_pcoord_range</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">cluster_pcoord_range</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">cluster_pcoord_all</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">idx_traj_in_cluster</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">]</span>

            <span class="c1"># Get the pcoord points that correspond to these dtraj points</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pcoord_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_traj_in_cluster</span><span class="p">):</span>
                <span class="n">pcoord_idxs</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pcoord_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pcoord_idxs</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">target_bin_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span> <span class="o">==</span> <span class="n">target_bin_index</span><span class="p">:</span>
                    <span class="c1"># log.warning(idx_traj_in_cluster)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No trajectories in cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">! (Target was </span><span class="si">{</span><span class="n">target_bin_index</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>

                <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">cluster_pcoord_range</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
                <span class="n">cluster_pcoord_all</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
                <span class="k">continue</span>

            <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">cluster_pcoord_range</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">]</span>
            <span class="n">cluster_pcoord_all</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">pcoord_sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cluster_pcoord_centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_minmax</span> <span class="o">=</span> <span class="n">cluster_pcoord_range</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_pcoord_all</span><span class="p">)[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pcoord_sort_indices</span></div>

    <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span>
    <span class="k">def</span> <span class="nf">do_stratified_ray_discretization</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">kmeans_model</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">processCoordinates</span>
    <span class="p">):</span>

        <span class="c1"># model_id, kmeans_model_id, iteration, processCoordinates_id = arg</span>

        <span class="c1"># import sys</span>
        <span class="c1"># import westpa.core.binning</span>

        <span class="c1"># sys.modules[&quot;westpa.binning&quot;] = sys.modules[&quot;westpa.core.binning&quot;]</span>
        <span class="c1"># This is silly -- I need to import westpa.core.binning so it&#39;s loaded into sys.modules but the linter</span>
        <span class="c1">#   complains that it&#39;s unused... so, use it.</span>
        <span class="c1"># log.debug(f&quot;Loaded {westpa.core.binning}&quot;)</span>

        <span class="c1"># self = ray.get(model_id)</span>
        <span class="c1"># kmeans_model = ray.get(kmeans_model_id)</span>
        <span class="c1"># processCoordinates = ray.get(processCoordinates_id)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># Need to do this so the model&#39;s transformation array is writable -- otherwise predict chokes</span>
        <span class="c1">#   with &#39;buffer source array is read-only&#39;.</span>
        <span class="n">kmeans_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kmeans_model</span><span class="p">)</span>
        <span class="n">kmeans_model</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># for i, cluster_model in enumerate(kmeans_model.cluster_models):</span>
        <span class="c1">#     print(f&quot;Model {i}: \t &quot;, end=&quot; &quot;)</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         print(cluster_model.cluster_centers_)</span>
        <span class="c1">#     except AttributeError:</span>
        <span class="c1">#         print(&quot;No cluster centers!&quot;)</span>

        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># If there are no coords for this iteration, return None</span>
        <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iteration</span>

        <span class="c1"># Otherwise, apply the k-means model and discretize</span>
        <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dtrajs</span> <span class="o">=</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Cluster center was not initialized and not remapped&quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">kmeans_model</span><span class="o">.</span><span class="n">we_remap</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
            <span class="c1"># TODO: Remap to nearest visited</span>

        <span class="k">return</span> <span class="n">dtrajs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">target_bins</span><span class="p">,</span> <span class="n">kmeans_model</span><span class="o">.</span><span class="n">basis_bins</span>

<div class="viewcode-block" id="modelWE.load_clusters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">load_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterFile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load clusters from a file.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.clusters`</span>
<span class="sd">            - `self.n_clusters`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clusterFile: str</span>
<span class="sd">            Filename to load clusters from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found saved clusters -- loading from </span><span class="si">{</span><span class="n">clusterFile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">pyemma</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">clusterFile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span>
    <span class="k">def</span> <span class="nf">get_iter_fluxMatrix_ray</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">processCoordinates</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">):</span>

        <span class="c1"># model_id, n_iter, processCoordinates_id = args</span>

        <span class="c1"># self = ray.get(model_id)</span>
        <span class="c1"># processCoordinates = ray.get(processCoordinates_id)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span> <span class="o">=</span> <span class="n">processCoordinates</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">iter_fluxmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">iter_fluxmatrix</span><span class="p">,</span> <span class="n">n_iter</span>

<div class="viewcode-block" id="modelWE.get_iter_fluxMatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_fluxMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the flux matrix for an iteration.</span>

<span class="sd">        1. Update state with data from the iteration you want to compute the flux matrix for</span>
<span class="sd">        2. Load transition data at the requested lag</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        This function is slow because of the call to get_transition_data_lag0(). See that function for more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1. Update state with data from the iteration you want to compute the flux matrix for</span>
        <span class="c1"># sys.stdout.write(&quot;iteration &quot; + str(n_iter) + &quot;: data \n&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

        <span class="c1">#  2. Load transition data at the requested lag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If you&#39;re using more than 1 lag, obtain segment histories at that lag</span>
            <span class="c1">#   This means you have to look back one or more iterations</span>

            <span class="c1"># sys.stdout.write(&quot;segment histories \n&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># sys.stdout.write(&quot; transition data...\n&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_transition_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If you&#39;re using a lag of 0, your coordinate pairs are just the beginning/end of the iteration.</span>
            <span class="c1">#   In that, it&#39;s not possible to have warps/recycles, since those are done handled between iterations.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_transition_data_lag0</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No coordinates for iter </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, skipping this iter in fluxmatrix calculation&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting flux matrix for iter </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>
        <span class="c1"># If you used a lag of 0, transitions weights are just weightList</span>
        <span class="c1"># If you used a lag &gt; 0, these include the weight histories from previous iterations</span>
        <span class="c1"># num_transitions = np.shape(self.transitionWeights)[0]</span>

        <span class="c1"># Create dedicated clusters for the target and basis states,</span>
        <span class="c1"># and reassign any points within the target or basis to those</span>
        <span class="n">target_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">basis_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>

        <span class="c1"># (Segment, Atom, [lagged, current coord])</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coord pairlist shape is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get which coords are not NaN</span>
        <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Assign a cluster to the lagged and the current coords</span>
        <span class="n">reduced_initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">reduced_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Wrap this in a try to make sure we unset the toggle</span>
        <span class="c1"># Note: This toggle is only used for stratified clusteirng, but it&#39;s set either way.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">reduced_initial</span><span class="p">)</span>
            <span class="n">end_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">reduced_final</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">reduced_initial</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">reduced_final</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">processing_from</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">toggle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster 0 shape: </span><span class="si">{</span><span class="n">start_cluster</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Record every point where you&#39;re in the target</span>
        <span class="n">ind_end_in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ind_end_in_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Number of post-transition target1 entries: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind_end_in_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No target1 entries. </span><span class="si">{</span><span class="n">ind_end_in_target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get the index of every point</span>
        <span class="n">ind_start_in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ind_start_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Number of pre-transition points in basis0: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind_start_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ind_end_in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ind_end_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Number of post-transition points in basis1: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind_end_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Target cluster index is: </span><span class="si">{</span><span class="n">target_cluster_index</span><span class="si">}</span><span class="s2">,  basis cluster index is: </span><span class="si">{</span><span class="n">basis_cluster_index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Re-assign points that were in either the target or the basis to the target or basis clusters</span>
        <span class="n">end_cluster</span><span class="p">[</span><span class="n">ind_end_in_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_cluster_index</span>
        <span class="n">start_cluster</span><span class="p">[</span><span class="n">ind_start_in_basis</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_cluster_index</span>
        <span class="n">end_cluster</span><span class="p">[</span><span class="n">ind_end_in_basis</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_cluster_index</span>

        <span class="c1"># coo_matrix takes in (Data, (x, y)) and then gives you a matrix, with the point at Data[i]</span>
        <span class="c1">#   placed at (x,y)[i]</span>
        <span class="c1"># Data here is just the number of segments since each segment is associated with 1 transition</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span><span class="p">[</span><span class="n">good_coords</span><span class="p">],</span> <span class="p">(</span><span class="n">start_cluster</span><span class="p">,</span> <span class="n">end_cluster</span><span class="p">)),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Iter_fluxmatrix failed. Transition was from </span><span class="si">{</span><span class="n">start_cluster</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">end_cluster</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">(Total </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="si">}</span><span class="s2"> clusters)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">(End in target: </span><span class="si">{</span><span class="n">ind_end_in_target</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># While the sparse matrix implementation is nice and efficient, using the np.matrix type is a little weird</span>
        <span class="c1">#   and fragile, and it&#39;s possible it&#39;ll be deprecated in the future.</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="o">.</span><span class="n">A</span>

        <span class="k">return</span> <span class="n">fluxMatrix</span></div>

    <span class="k">def</span> <span class="nf">get_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">binbounds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;/s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_b&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nBins</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;/pcoord1D_fluxMatrix&quot;</span>
        <span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>

        <span class="c1"># Again, disable this file</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calling with </span><span class="si">{</span><span class="n">iS</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">binbounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="n">fluxMatrixI</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>
                <span class="p">)</span>  <span class="c1"># correct for multiple trees</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
        <span class="k">elif</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nIter</span> <span class="o">=</span> <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">nIter</span> <span class="o">=</span> <span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nIter</span> <span class="o">&lt;</span> <span class="n">last_iter</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># TODO: Is this even implemented..?</span>
                        <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span>
                            <span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span>
                        <span class="p">)</span>
                    <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                    <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1D_fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span>

<div class="viewcode-block" id="modelWE.get_iter_pcoord1D_fluxMatrix_lag0"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_pcoord1D_fluxMatrix_lag0">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a flux-matrix in the space of the 1D progress coordinate, at a given iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter: integer</span>
<span class="sd">            Iteration to compute flux matrix for</span>

<span class="sd">        binbounds: array-like</span>
<span class="sd">            Array of progress coordinate bin boundaries</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The fluxmatrix at iteration n_iter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># log.info(n_iter)</span>
        <span class="c1"># log.info(binbounds)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: solving fluxmatrix </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">num_segments_in_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nBins</span> <span class="o">=</span> <span class="n">binbounds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>

        <span class="c1"># Lists of all parent and child pcoords</span>
        <span class="n">pcoord0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pcoord1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Assign parent/child pcoords to bins</span>
        <span class="n">bins0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">pcoord0</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
        <span class="n">bins1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">pcoord1</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_segments_in_iter</span><span class="p">):</span>
            <span class="c1"># I THINK WHAT&#39;S HAPPENING HERE IS:</span>
            <span class="c1"># The lowest binbound provided here should be smaller than the smallest possible</span>
            <span class="c1">#   value in the trajectory.</span>
            <span class="c1"># I.e., because of the way bins are defined for WE, you might have bin bounds like</span>
            <span class="c1">#   [0,1,2,3], where x&gt;3 is in the basis and 0&lt;x&lt;1 is in the target. However, digitize</span>
            <span class="c1">#   would assign a point of 0.5, which should be in the target, to index 1.</span>
            <span class="c1"># I think this -1 corrects for that.</span>

            <span class="n">from_bin_index</span> <span class="o">=</span> <span class="n">bins0</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">to_bin_index</span> <span class="o">=</span> <span class="n">bins1</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Set the weight of any segment that jumps more than 12 bins to 0?</span>
            <span class="c1">#   This seems super risky, and also originally this function didn&#39;t copy weightList, so it</span>
            <span class="c1">#   modified weightList in state for anything that runs after.</span>
            <span class="c1"># In particular, I think that&#39;s bad because if you have more than 12 bins, going from the target to</span>
            <span class="c1">#   the basis is going to be set to 0 by this logic.</span>
            <span class="c1"># So, I&#39;m going to disable this for now...</span>
            <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">from_bin_index</span> <span class="o">-</span> <span class="n">to_bin_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">weightList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">from_bin_index</span><span class="p">,</span> <span class="n">to_bin_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">from_bin_index</span><span class="p">,</span> <span class="n">to_bin_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">weightList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fluxMatrix</span></div>

<div class="viewcode-block" id="modelWE.get_fluxMatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_fluxMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_fluxMatrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iters_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix of fluxes at a given lag time, for a range of iterations.</span>

<span class="sd">        Checks if a file has been written named</span>
<span class="sd">        &quot;&lt;`self.modelName`&gt;_s&lt;`first_iter`&gt;_e&lt;`last_iter`&gt;_lag&lt;`n_lag`&gt;_clust&lt;`self.n_clusters`&gt;.h5&quot;.</span>
<span class="sd">        If this file exists, load it and recalculate if it was calculated at an earlier iteration.</span>
<span class="sd">        Otherwise, write it.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.n_lag`</span>
<span class="sd">            - `self.errorWeight`</span>
<span class="sd">            - `self.errorCount`</span>
<span class="sd">            - `self.fluxMatrixRaw`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_lag: int</span>
<span class="sd">            Number of lags to use.</span>
<span class="sd">        first_iter: int</span>
<span class="sd">            First iteration to use.</span>
<span class="sd">        last_iter: int</span>
<span class="sd">            Last iteration to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fluxMatrixParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">iters_to_use</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Specific iterations to use were provided for fluxmatrix calculation, using those.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">iters_to_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">last_iter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">last_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span>
            <span class="n">iters_to_use</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Else, if iters_to_use is Not none, and Not (first_iter is None and last_iter is None)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Both specific iterations to use AND first/last were provided to fluxmatrix calculation. Specify&quot;</span>
                <span class="s2">&quot; one or the other, not both.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing all flux matrices&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorWeight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># +2 because the basis and target states are the last two indices</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">fileName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;-fluxmatrix-_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_clust&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Overwrite this file, don&#39;t try to read from it.  Hence the &quot;w&quot; flag</span>
        <span class="c1"># TODO: Maybe in the future return to this,</span>
        <span class="c1">#  but it caused more problems than it was worth when doing multiple runs.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="c1"># Janky -- if the file exists, pick a random name</span>
            <span class="kn">import</span> <span class="nn">random</span>

            <span class="n">fileName</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="s2">04d</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;fluxMatrix&quot;</span>

        <span class="c1"># FIXME: name this something descriptive or just use the &#39;in&#39; statement in the if/elif</span>
        <span class="n">fluxmatrix_exists_in_h5</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>
        <span class="n">always_overwrite_fluxmatrix</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># If this data file does not contain a fluxMatrix entry, create it</span>
        <span class="c1"># For now, don&#39;t use a saved fluxmatrix, annoying to debug</span>
        <span class="k">if</span> <span class="n">always_overwrite_fluxmatrix</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fluxmatrix_exists_in_h5</span><span class="p">:</span>
            <span class="c1"># Create the fluxMatrix dataset</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span>

            <span class="c1"># Add up the flux matrices for each iteration to get the flux matrix.</span>
            <span class="c1"># Then, save that matrix to the data file, along with the number of iterations used</span>
            <span class="c1"># FIXME: Duplicated code</span>
            <span class="c1"># The range is offset by 1 because you can&#39;t calculate fluxes for the 0th iteration</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_ray</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Constructing flux matrix&quot;</span><span class="p">,):</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getting fluxMatrix iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># fluxMatrixI = self.get_iter_fluxMatrix(iS)</span>
                    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                        <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                    <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                        <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix</span><span class="p">,</span> <span class="n">iS</span><span class="p">,</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

                    <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># f = h5py.File(fileName + &quot;.h5&quot;, &quot;a&quot;)</span>
                    <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                    <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Completed flux matrix for iter </span><span class="si">{</span><span class="n">iS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># If we&#39;re running through Ray..</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># First, connect to the ray cluster</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">check_connect_ray</span><span class="p">()</span>

                <span class="c1"># Submit all the tasks for iteration fluxmatrix calculations</span>
                <span class="n">task_ids</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">processCoordinates_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">)</span>

                <span class="c1"># max_inflight = 70</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">iters_to_use</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Submitting fluxmatrix tasks&quot;</span><span class="p">,</span>
                <span class="p">):</span>

                    <span class="c1"># Allow 1000 in flight calls</span>
                    <span class="c1"># This is buggy, so disable for now.</span>
                    <span class="c1"># For example, if i = 5000, this call blocks until that</span>
                    <span class="c1"># 4000 of the object_refs in result_refs are ready</span>
                    <span class="c1"># and available.</span>
                    <span class="c1"># See: https://docs.ray.io/en/latest/ray-design-patterns/limit-tasks.html</span>
                    <span class="c1"># if len(task_ids) &gt; max_inflight:</span>
                    <span class="c1">#</span>
                    <span class="c1">#     # The number that need to be ready before we can submit more</span>
                    <span class="c1">#     num_ready = iteration - max_inflight</span>
                    <span class="c1">#     log.info(f&quot;At iteration {iteration}, waiting to submit more jobs until {num_ready} are ready&quot;)</span>
                    <span class="c1">#     ready, notready = ray.wait(task_ids, num_returns=num_ready)</span>
                    <span class="c1">#     log.info(f&quot;At iteration {iteration}, {len(ready)} jobs are ready {len(notready)} not, submitting more.&quot;)</span>

                    <span class="c1"># log.debug(f&quot;Submitted fluxmatrix task iteration {iteration}&quot;)</span>
                    <span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix_ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span>
                        <span class="n">model_id</span><span class="p">,</span> <span class="n">processCoordinates_id</span><span class="p">,</span> <span class="n">iteration</span>
                    <span class="p">)</span>

                    <span class="n">task_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>

                <span class="c1"># Wait for them to complete</span>
                <span class="c1"># Process results as they&#39;re ready, instead of in submission order</span>
                <span class="c1">#  See: https://docs.ray.io/en/latest/ray-design-patterns/submission-order.html</span>
                <span class="c1"># Additionally, this batches rather than getting them all at once, or one by one.</span>

                <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Retrieving flux matrices&quot;</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
                    <span class="k">while</span> <span class="n">task_ids</span><span class="p">:</span>
                        <span class="n">result_batch_size</span> <span class="o">=</span> <span class="mi">50</span>
                        <span class="n">result_batch_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">))</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Waiting for </span><span class="si">{</span><span class="n">result_batch_size</span><span class="si">}</span><span class="s2"> results (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> total remain)&quot;</span>
                        <span class="p">)</span>

                        <span class="c1"># Returns the first ObjectRefs that are ready, with a 60s timeout.</span>
                        <span class="n">finished</span><span class="p">,</span> <span class="n">task_ids</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                            <span class="n">task_ids</span><span class="p">,</span> <span class="n">num_returns</span><span class="o">=</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span>
                        <span class="p">)</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="si">}</span><span class="s2"> results&quot;</span><span class="p">)</span>

                        <span class="c1"># Add each matrix to the total fluxmatrix</span>
                        <span class="k">for</span> <span class="n">_fmatrix</span><span class="p">,</span> <span class="n">_iter</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">_fmatrix</span>
                            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fluxmatrices all obtained&quot;</span><span class="p">)</span>

                <span class="c1"># Write the H5. Can&#39;t do this per-iteration, because we&#39;re not guaranteed to be going sequentially now</span>

                <span class="n">nI</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iters_to_use</span><span class="p">)</span>
                <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nI</span>

            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="c1"># Normalize the flux matrix by the number of iterations that it was calculated with</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>

        <span class="c1"># If this datafile DOES contain a fluxMatrix entry...</span>
        <span class="c1"># HACK: This explicitly never runs now, but keep it around in case we decide to re-add this later.</span>
        <span class="c1"># TODO: Update this to work with the specific iterations</span>
        <span class="k">elif</span> <span class="n">fluxmatrix_exists_in_h5</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fluxmatrix already exists in h5 file, loading saved.&quot;</span><span class="p">)</span>

            <span class="c1"># Load the existing fluxMatrix</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="n">nIter</span> <span class="o">=</span> <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
            <span class="c1"># f.close()</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># If the flux matrix was calculated at an earlier iteration than the current/requested last iteration, then</span>
            <span class="c1">#   recalculate it and update it.</span>
            <span class="c1"># TODO: Check if first_iter changed too? That&#39;s not stored anywhere</span>

            <span class="c1">#  For now, just always overwrite any saved data.</span>
            <span class="c1"># if nIter &lt; last_iter:</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring any saved fluxmatrix in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2">.h5&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                    <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># f = h5py.File(fileName + &quot;.h5&quot;, &quot;a&quot;)</span>
                    <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                    <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                    <span class="c1"># f.close()</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;getting fluxMatrix iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Update state with the new, updated, or loaded from file fluxMatrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="n">fluxMatrix</span></div>

    <span class="k">def</span> <span class="nf">organize_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustering_method&quot;</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;self.clustering_method is not set. This may be a model saved before stratified was &quot;</span>
                <span class="s2">&quot;implemented, or you may not have run cluster_coordinates! &quot;</span>
                <span class="s2">&quot;Assuming the former and setting to aggregated.&quot;</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">=</span> <span class="s2">&quot;aggregated&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">==</span> <span class="s2">&quot;stratified&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">organize_stratified</span><span class="p">(</span><span class="n">use_ray</span><span class="p">)</span>

            <span class="c1"># TODO: Respect do_cleaning=False for blockwise stratified</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span> <span class="o">==</span> <span class="s2">&quot;aggregated&quot;</span><span class="p">:</span>

            <span class="c1"># If the user has manually specified states to keep, skip the normal cleaning, and just do what they said</span>
            <span class="k">if</span> <span class="s2">&quot;states_to_keep&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">organize_aggregated</span><span class="p">(</span><span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c1"># self.organize_aggregated(use_ray, **args)</span>

            <span class="n">fmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Add recycling to avoid detecting the target as a sink</span>
            <span class="n">fmatrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">flat_raw_islands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">find_connected_sets</span><span class="p">(</span><span class="n">fmatrix</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">new_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">new_args</span><span class="p">[</span><span class="s2">&quot;do_cleaning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">states_to_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">organize_aggregated</span><span class="p">(</span>
                <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span> <span class="o">**</span><span class="n">new_args</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="n">regular_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="o">~</span><span class="n">states_to_keep</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_raw_islands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">states_to_keep</span><span class="p">[</span><span class="n">flat_raw_islands</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">states_to_keep</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">modified_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="o">~</span><span class="n">states_to_keep</span><span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Modified cleaning added states </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">modified_clean</span><span class="p">,</span> <span class="n">regular_clean</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># If you didn&#39;t want to do cleaning, you&#39;ve gone far enough, return the list of good state indices</span>
            <span class="k">if</span> <span class="s2">&quot;do_cleaning&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;do_cleaning&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">states_to_keep</span><span class="p">)</span>

            <span class="c1"># Otherwise, carry on and actually clean</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">new_args</span><span class="p">[</span><span class="s2">&quot;states_to_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">states_to_keep</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">organize_aggregated</span><span class="p">(</span><span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span> <span class="o">**</span><span class="n">new_args</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">states_to_keep</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unrecognized clustering_method (Had: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clustering_method</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="modelWE.organize_aggregated"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.organize_aggregated">[docs]</a>    <span class="k">def</span> <span class="nf">organize_aggregated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_cleaning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">states_to_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rediscretize</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do some cleaning on the flux matrix, and update state with the cleaned flux matrix.</span>

<span class="sd">        Namely:</span>
<span class="sd">            - Remove unvisited clusters</span>
<span class="sd">            - Remove bins with no connectivity</span>
<span class="sd">            - Sort along the bins&#39; projection in pcoord 1</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ray_args : dict</span>
<span class="sd">            Dictionary whose values are currently unused, but containing an &#39;address&#39; and &#39;password&#39; key will enable</span>
<span class="sd">            Ray.</span>

<span class="sd">        do_cleaning : bool</span>
<span class="sd">            If true, clean self.fluxMatrixRaw and re-discretize to produce self.fluxMatrix. If false, just return</span>
<span class="sd">            the list of good states to keep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        Break this up into find_traps() and clean_traps(list_of_traps).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">original_fluxmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cleaning flux matrix&quot;</span><span class="p">)</span>

        <span class="c1"># Discretize trajectories via clusters</span>
        <span class="c1"># Get the indices of the target and basis clusters</span>
        <span class="n">target_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Target at -1</span>
        <span class="n">basis_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>  <span class="c1"># basis at -2</span>

        <span class="c1"># This tracks which clusters are going to be cleaned from the flux matrix.</span>
        <span class="c1"># A 0 means it&#39;ll be cleaned, a 1 means it&#39;ll be kept.</span>
        <span class="n">good_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">cluster_pcoord_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>
        <span class="c1"># cluster_pcoord_centers[indTargetCluster]=self.target_rmsd</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span>
        <span class="c1"># cluster_pcoord_centers[indBasisCluster]=self.get_reference_rmsd(self.basis_coords)</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span>

        <span class="c1"># Just initialize this to some positive nonzero value to kick off the while loop</span>
        <span class="n">nTraps</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">fluxMatrixTraps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">nTraps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nTraps</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">cluster_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
                <span class="c1"># Get the indices of the dtraj points in this cluster</span>
                <span class="n">idx_traj_in_cluster</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj</span> <span class="o">==</span> <span class="n">cluster_index</span><span class="p">)</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span>
                <span class="p">]</span>

                <span class="c1"># Get the pcoord points that correspond to these dtraj points</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">pcoord_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_traj_in_cluster</span><span class="p">):</span>
                    <span class="n">pcoord_idxs</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">pcoord_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pcoord_idxs</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Get the number of dtraj points in this cluster</span>
                <span class="n">n_in_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">idx_traj_in_cluster</span><span class="p">])</span>

                <span class="c1"># If this cluster is unvisited in the trajectories, set good_cluster to False</span>
                <span class="c1"># if np.shape(idx_traj_in_cluster)[1] == 0:</span>
                <span class="k">if</span> <span class="n">n_in_cluster</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Otherwise, get the average pcoord of the points in the cluster</span>
                <span class="k">elif</span> <span class="n">n_in_cluster</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># cluster_pcoord_centers[iC]=np.mean(self.get_reference_rmsd(self.coordSet[idx_traj_in_cluster[0],:,:]))</span>
                    <span class="c1"># The coordinate of this cluster center is the average pcoord of all points in it</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Offset is </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">pcoord_indices</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>

                <span class="c1"># Get the total flux along the row and col of this index</span>
                <span class="n">net_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrixTraps</span><span class="p">[:,</span> <span class="n">cluster_index</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="p">:]</span>
                <span class="p">)</span>

                <span class="c1"># If both the row and column are all zero, this is an unvisited state, so set good_clusters to 0/False</span>
                <span class="k">if</span> <span class="n">net_flux</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># If the sum along the row and column are nonzero</span>
                <span class="k">if</span> <span class="n">net_flux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Get all the clusters that *aren&#39;t* the one we&#39;re looking at</span>
                    <span class="n">all_other_cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                        <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">),</span> <span class="n">cluster_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Look at all the flux FROM other clusters</span>
                    <span class="n">total_flux_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="n">all_other_cluster_indices</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># And look at all the flux TO other clusters</span>
                    <span class="n">total_flux_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">all_other_cluster_indices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># If either the flux from or the flux to other clusters are all zero,</span>
                    <span class="c1">#   then this is a source or sink respectively.</span>
                    <span class="c1"># So, clean it</span>
                    <span class="k">if</span> <span class="n">total_flux_in</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">total_flux_out</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">nTraps</span> <span class="o">=</span> <span class="n">nTraps</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[:,</span> <span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Make sure we don&#39;t clean the target or basis clusters</span>
            <span class="n">good_clusters</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">good_clusters</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># If a list of states to keep has been provided, forget everything we just did, and only clean those.</span>
        <span class="c1"># Still run the above, rather than putting the else for this if clause around it,</span>
        <span class="c1">#   so that we still get the cluster pcoords from it.</span>
        <span class="k">if</span> <span class="n">states_to_keep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">good_clusters</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">good_clusters</span><span class="p">[</span><span class="n">states_to_keep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_cleaning</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">good_clusters</span>

        <span class="c1"># Store this array. 1 if a cluster is good, 0 otherwise.</span>
        <span class="n">clusters_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">good_clusters</span><span class="p">)</span>

        <span class="c1"># Get all the visited and non-trap clusters, which we want to keep, and make fluxMatrix from those</span>
        <span class="n">good_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">good_clusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="p">[</span><span class="n">good_clusters</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">good_clusters</span><span class="p">]</span>

        <span class="c1"># Get the RMSD centers for all of the clusters we want to keep</span>
        <span class="n">cluster_pcoord_centers</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">good_clusters</span><span class="p">]</span>
        <span class="c1"># Get the indices that sort it, in pcoord 0</span>
        <span class="n">pcoord_sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cluster_pcoord_centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># And update the model&#39;s RMSD cluster centers to just include the sorted clusters to keep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="c1"># Sort fluxmatrix using the sorted indices, columns and then rows</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="c1"># Renormalize the new flux matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">fluxMatrix</span>
        <span class="p">)</span>  <span class="c1"># average weight transitioning or staying put should be 1</span>

        <span class="c1"># Update the index of the basis and target states to account for their position in the new sorted clusters</span>
        <span class="n">originalClusters</span> <span class="o">=</span> <span class="n">good_clusters</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="c1"># log.debug(f&quot;Good clusters: {good_clusters}&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">originalClusters</span> <span class="o">==</span> <span class="n">basis_cluster_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">originalClusters</span> <span class="o">==</span> <span class="n">target_cluster_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;indBasis:  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="si">}</span><span class="s2">, indTargets: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sanity check -- basis:  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span><span class="si">}</span><span class="s2">, target: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Save the new, sorted clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span> <span class="o">=</span> <span class="n">originalClusters</span>

        <span class="c1"># Update binCenters with the new, sorted centers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Remove the cluster structure dict entries corresponding to removed clusters</span>
        <span class="n">removed_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">clusters_good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># log.debug(f&quot;Good clusters are {clusters_good}&quot;)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed clusters were </span><span class="si">{</span><span class="n">removed_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="n">removed_clusters</span>

        <span class="c1"># TODO: Since I re-discretize below, this is no longer necessary.</span>
        <span class="c1">#  For now, set it to 1:1 for backwards compatibility</span>
        <span class="c1"># After cleaning, the cluster indices may no longer be consecutive.</span>
        <span class="c1">#  So, when I do the cleaning, I need to build a mapping of old, nonconsecutive cluster indices from the</span>
        <span class="c1">#  non-cleaned matrix, to new, consecutive indices.</span>
        <span class="c1"># That&#39;s like collapsing the nonconsecutive list. In other words, imagine I started with 5 clusters [0,1,2,3,4]</span>
        <span class="c1">#   and clean cluster 2. Now, I&#39;ll still have clusters labeled as [0,1,3,4], but my steady-state distribution</span>
        <span class="c1">#   is only 4 elements. So indexing element 4 won&#39;t do anything.</span>
        <span class="n">cluster_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">n_removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span><span class="p">:</span>
                <span class="n">n_removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cluster_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_removed</span>

        <span class="c1"># TODO: This is unused, which is why it&#39;s just set to a 1:1. This is legacy, but left in for compatibility</span>
        <span class="c1">#   with the restart plugin which expects it.</span>
        <span class="c1"># log.debug(f&quot;New cluster mapping is  {cluster_mapping}&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mapping</span> <span class="o">=</span> <span class="n">cluster_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="c1"># Remove the bad clusters from the set of cluster centers. Thus, they won&#39;t be used by self.clusters.predict</span>
        <span class="c1">#   in the future.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">removed_clusters</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># TODO: Don&#39;t duplicate code from cluster_coordinates!!</span>
        <span class="c1"># TODO: You don&#39;t actually need to rediscretize every point -- just the removed ones.  Do this  later to make</span>
        <span class="c1">#   this more efficient.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span>

        <span class="k">if</span> <span class="n">rediscretize</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_ray</span><span class="p">:</span>
            <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Post-cleaning rediscretization&quot;</span>
            <span class="p">):</span>

                <span class="k">if</span> <span class="n">extra_iters_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">extra_iters_used</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Already processed  iter  </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span>
                    <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp_context</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                    <span class="n">dtrajs</span><span class="p">,</span> <span class="n">extra_iters_used</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">do_discretization</span><span class="p">,</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">],</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtrajs</span><span class="p">)</span>

        <span class="c1"># If we&#39;re using Ray...</span>
        <span class="k">elif</span> <span class="n">rediscretize</span> <span class="ow">and</span> <span class="n">use_ray</span><span class="p">:</span>

            <span class="c1"># First, connect to the ray cluster</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_connect_ray</span><span class="p">()</span>

            <span class="c1"># Submit all the discretization tasks to the cluster</span>
            <span class="n">task_ids</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">cluster_model_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
            <span class="n">process_coordinates_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">)</span>

            <span class="c1"># max_inflight = 50</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Submitting discretization tasks&quot;</span>
            <span class="p">):</span>
                <span class="c1"># if len(task_ids) &gt; max_inflight:</span>
                <span class="c1">#</span>
                <span class="c1">#     # The number that need to be ready before we can submit more</span>
                <span class="c1">#     num_ready = iteration - max_inflight</span>
                <span class="c1">#     ray.wait(task_ids, num_returns=num_ready)</span>

                <span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_ray_discretization</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span>
                    <span class="n">model_id</span><span class="p">,</span> <span class="n">cluster_model_id</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">process_coordinates_id</span>
                <span class="p">)</span>
                <span class="n">task_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>

            <span class="c1"># As they&#39;re completed, add them to dtrajs</span>
            <span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">last_iter</span> <span class="o">-</span> <span class="n">first_iter</span><span class="p">)</span>

            <span class="c1"># Do these in bigger batches, dtrajs aren&#39;t very big</span>

            <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Retrieving discretized trajectories&quot;</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">task_ids</span><span class="p">:</span>
                    <span class="n">result_batch_size</span> <span class="o">=</span> <span class="mi">50</span>
                    <span class="n">result_batch_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_ids</span><span class="p">))</span>

                    <span class="c1"># Returns the first ObjectRef that is ready, with a 20s timeout</span>
                    <span class="n">finished</span><span class="p">,</span> <span class="n">task_ids</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                        <span class="n">task_ids</span><span class="p">,</span> <span class="n">num_returns</span><span class="o">=</span><span class="n">result_batch_size</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span>
                    <span class="p">)</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">dtraj</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                        <span class="n">dtrajs</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtraj</span>
                        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">pbar</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

            <span class="c1"># Remove all empty elements from dtrajs and assign to self.dtrajs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtraj</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="n">dtrajs</span> <span class="k">if</span> <span class="n">dtraj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Update self.n_clusters to account for any removed clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">-=</span> <span class="n">n_removed</span>

        <span class="c1"># Rebuild the fluxmatrix with whatever params were originally provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_fluxMatrix</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_fluxMatrixParams</span><span class="p">,</span> <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">)</span>

        <span class="c1"># # The new, organized fluxmatrix is the result of computing the new fluxmatrix, on the new set of bins.</span>
        <span class="n">new_fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Do the same sorting and organization we did above on the &quot;raw&quot; fluxmatrix, for consistency.</span>
        <span class="n">new_fluxMatrix</span> <span class="o">=</span> <span class="n">new_fluxMatrix</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">new_fluxMatrix</span> <span class="o">=</span> <span class="n">new_fluxMatrix</span><span class="p">[:,</span> <span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="c1"># Renormalize the new flux matrix</span>
        <span class="n">new_fluxMatrix</span> <span class="o">=</span> <span class="n">new_fluxMatrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">new_fluxMatrix</span>
        <span class="p">)</span>  <span class="c1"># average weight transitioning or staying put should be 1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="n">original_fluxmatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">new_fluxMatrix</span></div>

<div class="viewcode-block" id="modelWE.get_model_clusters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_model_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by get_iter_aristoffian(). Untested and un-debugged, use at your own risk.</span>

<span class="sd">        Updates:</span>
<span class="sd">        - self.model_clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define new clusters from organized flux matrix corresponding to model</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;This function is untested, and may rely on other untested parts of this code. Use with extreme caution.&quot;</span>
        <span class="p">)</span>

        <span class="n">clustercenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">clustercenters</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clustercenters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span><span class="p">])</span>
            <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span>
                <span class="n">coords</span>
            <span class="p">)</span>  <span class="c1"># add in basis and target</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span><span class="p">,</span> <span class="p">:]),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">coords</span>
            <span class="p">)</span>  <span class="c1"># add in basis and target</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_Tmatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_Tmatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_Tmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transition matrix from the flux matrix.</span>
<span class="sd">        Corrects the &quot;target&quot; states to be true sink states.</span>

<span class="sd">        More specifically:</span>
<span class="sd">            - row-normalizes the flux matrix,</span>
<span class="sd">            - sets any states with 0 flux ot (i.e. sinks) to have 1.0</span>
<span class="sd">            - sets target bins to uniformly recycle into basis bins</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.Tmatrix`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing transition matrix&quot;</span><span class="p">)</span>

        <span class="c1"># Get a copy of the flux matrix</span>
        <span class="n">fluxmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Get the dimension of the flux matrix</span>
        <span class="n">fluxmatrix_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxmatrix</span><span class="p">)</span>
        <span class="c1"># Add up the total flux on each row, i.e. from each state</span>
        <span class="n">fluxes_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxmatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each state</span>
        <span class="k">for</span> <span class="n">state_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fluxmatrix_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># For positive definite flux, set the matrix elements based on normalized fluxes</span>
            <span class="k">if</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># If the flux is zero, then consider it all self-transition</span>
            <span class="c1"># FIXME: this if can be an elif</span>
            <span class="k">if</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">state_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Make the transition matrix a steady-state matrix</span>
        <span class="c1"># Identify the bins corresponding to target states.</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span>  <span class="c1"># np.where(avBinPnoColor==0.0)</span>

        <span class="c1"># Get the number of sink bins</span>
        <span class="n">n_sink_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sinkBins</span><span class="p">)</span>
        <span class="n">n_sink_bins</span> <span class="o">=</span> <span class="n">n_sink_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO: The goal here is to correct for the transition probabilities out of the sink state. Not</span>
        <span class="c1">#   sure I fully understand this implementation, but that&#39;s the goal.</span>
        <span class="c1"># Correction: I think this sets all the sink bins to recycle to the basis</span>
        <span class="n">sinkRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">sinkRates</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="o">.</span><span class="n">size</span>
        <span class="n">tmatrix</span> <span class="o">=</span> <span class="n">fluxmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tmatrix</span><span class="p">[</span><span class="n">sinkBins</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">sinkRates</span><span class="p">,</span> <span class="p">(</span><span class="n">n_sink_bins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">tmatrix</span></div>

    <span class="k">def</span> <span class="nf">get_eqTmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indSpace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indSpace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">indSpace</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">))</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">indSpace</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[:,</span> <span class="n">indSpace</span><span class="p">]</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
        <span class="n">sM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nR</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">Mt</span>

<div class="viewcode-block" id="modelWE.get_steady_state"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_fractional_convergence</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Get the steady-state distribution for the transition matrix.</span>
<span class="sd">        Uses scipy eigensolver to obtain an initial guess, then refines that using inverse iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flux_fractional_convergence: (optional, default=1e-4) float</span>
<span class="sd">            Convergence of the</span>

<span class="sd">        max_iters: (optional, default=100) int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Transition matrices generated from WE data may have entries spanning many orders of magnitude, and may have</span>
<span class="sd">        extremely high condition numbers.</span>
<span class="sd">        Furthermore, the smallest entries may be those near the target state, which are also the most important</span>
<span class="sd">        for computing target fluxes, meaning values near machine precision can&#39;t just be truncated.</span>
<span class="sd">        All this means that floating-point error may substantially affect the results of eigensolvers, and may produce</span>
<span class="sd">        bad/negative/inaccurate values for small probability bins.</span>

<span class="sd">        In order to obtain better estimates, sparse matrices are used to reduce the number of floating point operations</span>
<span class="sd">        being performed.</span>
<span class="sd">        A stationary distribution is first estimated using scipy&#39;s eigensolver for sparse matrices.</span>
<span class="sd">        This is then used as an initial guess for the inverse iteration method, to further refine it.</span>
<span class="sd">        Convergence of the inverse iteration is determined using change in the flux estimate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cast the matrix to a sparse matrix, to reduce floating point operations</span>
        <span class="n">sparse_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">)</span>

        <span class="n">algebraic_pss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_algebraic</span><span class="p">(</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">check_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Get an initial flux estimate using the numpy algebraic solver</span>
        <span class="c1"># Call with _set=False so you don&#39;t actually update self.JtargetSS</span>
        <span class="n">last_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">(</span><span class="n">pSS</span><span class="o">=</span><span class="n">algebraic_pss</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># ## Next, use that as an initial guess  for inverse iteration</span>
        <span class="n">last_pSS</span> <span class="o">=</span> <span class="n">algebraic_pss</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial flux: </span><span class="si">{</span><span class="n">last_flux</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">flux_warned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>

            <span class="n">iterated</span> <span class="o">=</span> <span class="n">inverse_iteration</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">sparse_mat</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="n">last_pSS</span><span class="p">)</span>

            <span class="c1"># Compute change in pSS</span>
            <span class="n">pSS_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">iterated</span> <span class="o">-</span> <span class="n">last_pSS</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Change in SS: </span><span class="si">{</span><span class="n">pSS_change</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">last_pSS</span> <span class="o">=</span> <span class="n">iterated</span>

            <span class="c1"># Compute change in target flux with the new pSS</span>
            <span class="n">new_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">(</span><span class="n">pSS</span><span class="o">=</span><span class="n">last_pSS</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">flux_change</span> <span class="o">=</span> <span class="n">new_flux</span> <span class="o">-</span> <span class="n">last_flux</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Change in flux estimate: </span><span class="si">{</span><span class="n">flux_change</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> (</span><span class="si">{</span><span class="n">new_flux</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> raw)&quot;</span>
            <span class="p">)</span>
            <span class="n">last_flux</span> <span class="o">=</span> <span class="n">new_flux</span>

            <span class="c1"># Set the convergence criterion after the iteration, in case the original result is really junk</span>
            <span class="c1"># Do it after so the first time this is calculated, it&#39;s using the result of the first iteration.</span>
            <span class="c1"># If the initial numpy estimate was really bad, it&#39;ll never be used.</span>
            <span class="n">flux_convergence_criterion</span> <span class="o">=</span> <span class="n">last_flux</span> <span class="o">*</span> <span class="n">flux_fractional_convergence</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Flux convergence criterion is </span><span class="si">{</span><span class="n">flux_convergence_criterion</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">last_flux</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">flux_warned</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Flux is 0, so steady-state solver will only converge after max iterations (using flux as &quot;</span>
                        <span class="s2">&quot;convergence criterion is not meaningful if it&#39;s 0!). &quot;</span>
                        <span class="s2">&quot;If you&#39;re looking for equilibrium, this is probably OK.&quot;</span>
                        <span class="s2">&quot; Otherwise, take a look at why you have 0 flux.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">flux_warned</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">flux_change</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">flux_convergence_criterion</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Flux converged to </span><span class="si">{</span><span class="n">last_flux</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> after </span><span class="si">{</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> iterations of inverse iteration.&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="n">max_iters</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">last_flux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Flux is nonzero and did not converge!&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">last_pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;Negative elements in pSS&quot;</span>
        <span class="k">assert</span> <span class="n">last_flux</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Negative flux estimate from this pSS&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done with steady-state estimation.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">last_pSS</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_algebraic"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_algebraic">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_algebraic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">check_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the steady-state distribution as the eigenvectors of the transition matrix.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.pSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_iters: int, optional</span>
<span class="sd">            Defaults to 1000. Number of power-method iterations to run if the numpy eigensolver returns negative elements.</span>

<span class="sd">        check_negative: bool, optional</span>
<span class="sd">            Defaults to True. If True, then raise an Exception if there are negative elements in the normalized pSS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># log.warning(</span>
        <span class="c1">#     &quot;get_steady_state_algebraic() will be deprecated soon. Use get_steady_state() instead, which has&quot;</span>
        <span class="c1">#     &quot; a more robust eigensolver.&quot;</span>
        <span class="c1"># )</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing steady-state from eigenvectors&quot;</span><span class="p">)</span>

        <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">))</span>

        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">))])</span>

        <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;Steady-state distribution sums to 0!&quot;</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>

        <span class="c1"># The numpy eigensolver is iterative, and approximate. Given that data from WE often spans many orders of</span>
        <span class="c1">#   magnitude, we&#39;ll sometimes run into situations where our populations span more than machine precision.</span>
        <span class="c1">#   This causes hiccups in the eigensolver. However, we can&#39;t just zero these out (as attempted above),</span>
        <span class="c1">#   because these values are often important.</span>
        <span class="c1"># So, if there are any negative elements, try to correct the NP eigensolver result using the matrix method</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pSS</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_iters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Negative elements in pSS after normalization, attempting to correct with matrix power method.&quot;</span>
            <span class="p">)</span>
            <span class="n">pSS_last</span> <span class="o">=</span> <span class="n">pSS</span>
            <span class="n">_tmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>

                <span class="n">pSS_new</span> <span class="o">=</span> <span class="n">_tmatrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pSS_last</span>
                <span class="n">num_negative_elements</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pSS_new</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_negative_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corrected to semidefinite pSS in </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> iterations&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="n">pSS_last</span> <span class="o">=</span> <span class="n">pSS_new</span>
                <span class="n">_tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">_tmatrix</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="n">max_iters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Power method did NOT obtain semidefinite pSS. Some negative values remain. This is weird, and you&quot;</span>
                    <span class="s2">&quot; should try to figure out why this is happening.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS_new</span>

        <span class="k">elif</span> <span class="n">max_iters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Negative elements in pSS after normalization, &quot;</span>
                <span class="s2">&quot;but max_iters=0 so not attempting to correct with power method.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">check_negative</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="n">pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Some negative elements in steady-state distribution: </span><span class="si">{</span><span class="n">pSS</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Some negative  elements in pSS... Ignoring, and setting model.pSS anyways.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pSS</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_matrixpowers"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_matrixpowers">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_matrixpowers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the steady-state distribution using the matrix power method.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.pSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conv: numeric</span>
<span class="sd">            Convergence criterion for iteration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pSSp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">Mt</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSp</span><span class="p">))</span>
                <span class="n">pSSp</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;N=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; dconv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_target_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_target_flux">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pSS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total flux into the target state(s).</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.lagtime`</span>
<span class="sd">            - `self.JtargetSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pSS: (optional) array-like</span>
<span class="sd">            Steady-state distribution. If nothing provided, then use self.pSS</span>

<span class="sd">        _set: (optional) boolean</span>
<span class="sd">            If True, then update self.JtargetSS and self.lagtime. If False, then just return the value of JtargetSS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If this matrix isn&#39;t connected from source to target, then it&#39;s not possible to get an MFPT directly out of it</span>
        <span class="n">sparse_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">)</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="n">is_connected</span><span class="p">(</span>
            <span class="n">sparse_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">connected</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                <span class="s2">&quot;There is no path in this matrix from the basis to the target, so no MFPT can be calculated.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>

        <span class="c1"># If no pSS was provided, then pull from self</span>
        <span class="k">if</span> <span class="n">pSS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">))</span>

        <span class="n">lagtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get a list of all the states that AREN&#39;T targets, since we want to sum up</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="c1"># log.debug(f&quot;Non-target states are those with index {indNotTargets}&quot;)</span>

        <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># Add up the total flux into each of the targets</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Processing flux into target state with index </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                    <span class="n">pSS</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Mss</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)])</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="n">lagtime</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">JtargetSS</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Jt</span> <span class="o">/</span> <span class="n">lagtime</span></div>

    <span class="k">def</span> <span class="nf">evolve_probability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition at basis</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">probBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="c1"># ????? why these nested excepts? What&#39;s so fragile here? Maybe the shape of pSS?</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">evolve_probability2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition spread for everything at RMSD higher than basis</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">probBasis</span><span class="p">[</span>
            <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span>
        <span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># assign initial probability to everything at RMSD higher than the basis, for case when nothing observed leaving exact basis</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">probBasis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probBasis</span><span class="p">)</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="c1"># plt.ylim([1e-100,1])</span>
                <span class="c1"># plt.title(str(iT)+&#39; of &#39;+str(nIterations))</span>
                <span class="c1"># plt.pause(.1)</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">evolve_probability_from_initial</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition provided</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">probBasis</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">probBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">probBasis</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="modelWE.get_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_flux">[docs]</a>    <span class="k">def</span> <span class="nf">get_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the measured flux (i.e. from the flux matrix) into the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># J = np.zeros_like(self.binCenters)</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nBins</span><span class="p">)</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">indBack</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">indForward</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nBins</span><span class="p">)</span>
            <span class="n">JR</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">JF</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indBack</span><span class="p">:</span>
                <span class="n">JR</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indForward</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indForward</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indForward</span><span class="p">:</span>
                <span class="n">JF</span> <span class="o">=</span> <span class="n">JF</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indBack</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indBack</span><span class="p">)])</span>
            <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">-</span> <span class="n">JF</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">J</span></div>

<div class="viewcode-block" id="modelWE.get_flux_committor"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_flux_committor">[docs]</a>    <span class="k">def</span> <span class="nf">get_flux_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the flux binned according to committors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># J = np.zeros_like(self.targetRMSD_centers)</span>
        <span class="c1"># nBins = np.shape(self.binCenters)[0]</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nBins</span><span class="p">)</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">indq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">))</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indq</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">indq</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Obtaining pseudocommittor-fluxes&quot;</span>
        <span class="p">):</span>
            <span class="n">indBack</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">indForward</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nBins</span><span class="p">)</span>
            <span class="n">JR</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">JF</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indBack</span><span class="p">:</span>
                <span class="n">JR</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indForward</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indForward</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indForward</span><span class="p">:</span>
                <span class="n">JF</span> <span class="o">=</span> <span class="n">JF</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indBack</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indBack</span><span class="p">)])</span>
            <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">-</span> <span class="n">JF</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Jq</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span></div>
            <span class="c1"># sys.stdout.write(&quot;%s &quot; % i)</span>

    <span class="k">def</span> <span class="nf">plot_flux_committor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nwin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_from_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">_to_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_plot_args</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">_models</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">_models</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">)</span>

        <span class="n">_model_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;main_model&quot;</span><span class="p">]</span>
        <span class="n">_model_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;validation_model_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">))]</span>
        <span class="p">)</span>

        <span class="n">cross_validation_done</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cross_validation_done</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                <span class="s2">&quot;No cross-validation models have been generated! Do this before making plots.&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_validation</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Perform cross-validation before plotting results.&quot;</span><span class="p">)</span>

        <span class="n">own_ax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">own_ax</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">plot_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;markersize&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
        <span class="n">plot_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_plot_args</span><span class="p">)</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_models</span><span class="p">)</span>
        <span class="n">from_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;cool&quot;</span><span class="p">)(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n_models</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">to_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;hot&quot;</span><span class="p">)(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n_models</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_model</span><span class="p">,</span> <span class="n">_label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_models</span><span class="p">,</span> <span class="n">_model_labels</span><span class="p">)):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_model</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Committors have not yet been generated for </span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2">, generating now.&quot;</span>
                <span class="p">)</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_committor</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_model</span><span class="p">,</span> <span class="s2">&quot;Jq&quot;</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Committor-fluxes have not yet been generated for </span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2">, generating now.&quot;</span>
                <span class="p">)</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_flux_committor</span><span class="p">()</span>

            <span class="n">n_bins</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Jq_avg</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">Jq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Jq_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Jq_avg</span><span class="p">)</span>

            <span class="n">q_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Jq_avg</span><span class="p">)</span>

            <span class="n">indq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">_model</span><span class="o">.</span><span class="n">q</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nwin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">iav</span> <span class="o">=</span> <span class="n">_i</span> <span class="o">-</span> <span class="n">nwin</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">_i</span> <span class="o">-</span> <span class="n">nwin</span><span class="p">,</span> <span class="n">_i</span><span class="p">)</span>
                <span class="n">Jq_avg</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_model</span><span class="o">.</span><span class="n">Jq</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">Jq_std</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">_model</span><span class="o">.</span><span class="n">Jq</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">q_avg</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_model</span><span class="o">.</span><span class="n">q</span><span class="p">[</span><span class="n">indq</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>

            <span class="n">indPlus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jq_avg</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">indMinus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jq_avg</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_from_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_from_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">q_avg</span><span class="p">[</span><span class="n">indMinus</span><span class="p">],</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Jq_avg</span><span class="p">[</span><span class="n">indMinus</span><span class="p">]),</span>
                <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
                <span class="c1"># color=to_target_colors[i%len(to_target_colors)],</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2"> flux toward source/basis&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">plot_args</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">_to_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_to_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">q_avg</span><span class="p">[</span><span class="n">indPlus</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Jq_avg</span><span class="p">[</span><span class="n">indPlus</span><span class="p">]),</span>
                <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
                <span class="c1"># color=from_target_colors[i%len(from_target_colors)],</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2"> flux toward target&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">plot_args</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Pseudocommittor&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Flux (weight/second&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_pseudocommittor_warning</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">own_ax</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.01</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">plot_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span><span class="si">}</span><span class="s2">_flux_committor.pdf&quot;</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving flux-committor plot to </span><span class="si">{</span><span class="n">plot_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot_filename</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="modelWE.plot_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.plot_flux">[docs]</a>    <span class="k">def</span> <span class="nf">plot_flux</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">custom_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_from_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">_to_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pcoord_to_use</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_plot_args</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make, and save, a plot of the fluxes along the RMSD.  get_flux() must be run before this.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        custom_name : str (optional)</span>
<span class="sd">            The name for the saved plot. Defaults to flux_s&lt;first iter&gt;_e&lt;last iter&gt;.png</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_models</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">_models</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">)</span>

        <span class="n">_model_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;main_model&quot;</span><span class="p">]</span>
        <span class="n">_model_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;validation_model_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">))]</span>
        <span class="p">)</span>

        <span class="n">cross_validation_done</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_models</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cross_validation_done</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                <span class="s2">&quot;No cross-validation models have been generated! Do this before making plots.&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_validation</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Perform cross-validation before plotting results.&quot;</span><span class="p">)</span>

        <span class="n">own_ax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">own_ax</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">plot_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;markersize&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
        <span class="n">plot_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_plot_args</span><span class="p">)</span>

        <span class="n">n_models</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_models</span><span class="p">)</span>
        <span class="n">from_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;cool&quot;</span><span class="p">)(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n_models</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">to_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;hot&quot;</span><span class="p">)(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n_models</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Draw the basis/target boundaries in this pcoord</span>
        <span class="p">[</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                <span class="n">bound</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Target bound&quot;</span><span class="p">][</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_to_use</span><span class="p">,</span> <span class="p">:])</span>
        <span class="p">]</span>
        <span class="p">[</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span>
                <span class="n">bound</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Basis/Source bound&quot;</span><span class="p">][</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_to_use</span><span class="p">,</span> <span class="p">:])</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_model</span><span class="p">,</span> <span class="n">_label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_models</span><span class="p">,</span> <span class="n">_model_labels</span><span class="p">)):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_model</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Fluxes have not yet been generated for </span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2">, generating now.&quot;</span>
                <span class="p">)</span>
                <span class="n">_model</span><span class="o">.</span><span class="n">get_flux</span><span class="p">()</span>

            <span class="n">J</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">J</span> <span class="o">/</span> <span class="n">_model</span><span class="o">.</span><span class="n">tau</span>

            <span class="n">binCenters</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[:,</span> <span class="n">pcoord_to_use</span><span class="p">]</span>
            <span class="n">indPlus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">indMinus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_to_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_to_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">binCenters</span><span class="p">[</span><span class="n">indPlus</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">indPlus</span><span class="p">]),</span>
                <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2"> flux toward target&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">plot_args</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">_from_colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_from_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_args</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">binCenters</span><span class="p">[</span><span class="n">indMinus</span><span class="p">],</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">indMinus</span><span class="p">]),</span>
                <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_label</span><span class="si">}</span><span class="s2"> flux toward source/basis&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">plot_args</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pcoord </span><span class="si">{</span><span class="n">pcoord_to_use</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Flux (weight/second&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">own_ax</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.01</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">custom_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_filename</span> <span class="o">=</span> <span class="n">custom_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span><span class="si">}</span><span class="s2">_flux.pdf&quot;</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving flux plot to </span><span class="si">{</span><span class="n">plot_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot_filename</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="k">def</span> <span class="nf">evolve_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span>
        <span class="n">nT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">probTransient</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Jtarget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="n">JtargetTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nT</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nT</span><span class="p">):</span>
            <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">indNotTargets</span><span class="p">],</span>
                        <span class="n">Mss</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">Jtarget</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jt</span>
            <span class="n">JtargetTimes</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Jtarget</span> <span class="o">=</span> <span class="n">Jtarget</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JtargetTimes</span> <span class="o">=</span> <span class="n">JtargetTimes</span>

    <span class="k">def</span> <span class="nf">get_hflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="n">convh</span> <span class="o">=</span> <span class="n">conv</span>
        <span class="n">convf</span> <span class="o">=</span> <span class="n">conv</span>
        <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">50000</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dconvh</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">dconvf</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">fTotal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fSSp</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fTotal</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">dconvh</span> <span class="o">&gt;</span> <span class="n">convh</span> <span class="ow">or</span> <span class="n">dconvf</span> <span class="o">&gt;</span> <span class="n">convf</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">):</span>
                <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">Pt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                            <span class="n">Pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">indNotTargets</span><span class="p">],</span>
                            <span class="n">Mt</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">fTotal</span> <span class="o">=</span> <span class="n">fTotal</span> <span class="o">+</span> <span class="n">f</span>
            <span class="n">fSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">fTotal</span> <span class="o">-</span> <span class="n">N</span> <span class="o">*</span> <span class="n">fSS</span>
            <span class="n">dconvh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hp</span> <span class="o">-</span> <span class="n">ht</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>
            <span class="n">dconvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fSS</span> <span class="o">-</span> <span class="n">fSSp</span><span class="p">)</span> <span class="o">/</span> <span class="n">fSS</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;N=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; dh: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconvh</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; df: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconvf</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; Jss:&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fSS</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">fSSp</span> <span class="o">=</span> <span class="n">fSS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_model_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">kh_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">hsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">k_hsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">hsq</span><span class="p">)</span>
        <span class="n">varh</span> <span class="o">=</span> <span class="n">k_hsq</span> <span class="o">-</span> <span class="n">kh_sq</span>
        <span class="c1"># val=np.sqrt(varh)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varh</span> <span class="o">=</span> <span class="n">varh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh</span> <span class="o">=</span> <span class="n">kh</span>

    <span class="k">def</span> <span class="nf">get_model_steady_state_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;adaptive&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">cluster_kmeans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nB</span><span class="p">:</span>
                <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;log_uniform&quot;</span><span class="p">:</span>
            <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;optimized&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;khbins (khbins_binCenters.dat) not found: initializing</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins_equalAlloc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh_clusters&quot;</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;giving up: log uniform kh bins&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins</span><span class="p">()</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">nB</span>
        <span class="p">)</span>  <span class="c1"># get bin objective function, value and allocation over set of bins</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">indBin</span><span class="p">]))</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wt</span> <span class="o">*</span> <span class="p">(</span><span class="n">vw</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
                <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span>
        <span class="c1"># base_walkers=self.min_walkers*np.ones_like(alloc)</span>
        <span class="c1"># nBase=np.sum(base_walkers)</span>
        <span class="c1"># nAdapt=self.nW-nBase</span>
        <span class="c1"># if nAdapt&lt;0:</span>
        <span class="c1">#    nAdapt=0</span>
        <span class="c1"># walkers=np.round(alloc*nAdapt)</span>
        <span class="c1"># walkers=walkers+base_walkers</span>
        <span class="c1"># indZero=np.where(walkers==0.0)</span>
        <span class="c1"># walkers[indZero]=1.0</span>
        <span class="c1"># walkers=walkers.astype(int)</span>
        <span class="c1"># binEdges=np.zeros(self.nB+1)</span>
        <span class="c1"># binEdges[0]=-np.inf</span>
        <span class="c1"># binEdges[-1]=np.inf</span>
        <span class="c1"># ind=np.argsort(self.kh_clusters.clustercenters[:,0]) #note sorting makes kh_clusters indexes differen</span>
        <span class="c1"># self.khbins_binCenters=self.kh_clusters.clustercenters[ind,0]</span>
        <span class="c1"># binEdges[1:-1]=0.5*(self.khbins_binCenters[1:]+self.khbins_binCenters[0:-1])</span>
        <span class="c1"># self.khbins_binEdges=binEdges</span>
        <span class="c1"># self.walkers_per_bin=walkers[ind]</span>
        <span class="c1"># self.bin_kh_var=bin_kh_var[ind]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># asymptotic particle distribution in bins</span>
        <span class="c1"># asymptotic particle distribution after mutation</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">rhov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">wv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBinv</span><span class="p">])</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;sum v: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">):</span>
                <span class="n">indBinu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indBinv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">indBinu</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">rhov</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">rhov</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">wv</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                        <span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rhov</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pOccupied</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span><span class="p">)</span>
        <span class="n">nOccupied</span> <span class="o">=</span> <span class="n">nB</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span><span class="p">))</span>
        <span class="n">nAdditional</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nOccupied</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span>
        <span class="n">nT</span> <span class="o">=</span> <span class="n">nAdditional</span> <span class="o">+</span> <span class="n">pOccupied</span>
        <span class="c1"># nT=np.zeros(nB)</span>
        <span class="c1"># for i in range(nB):</span>
        <span class="c1">#    nT[i]=np.max(np.array([1,nAdditional[i]+pOccupied[i]]))</span>
        <span class="n">bin_mutV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="n">bin_selV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
            <span class="n">bin_mutV</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">wi</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nT</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">bin_selV</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">wi</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nT</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_mutV</span> <span class="o">+</span> <span class="n">bin_selV</span><span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="c1"># self.walkers_per_bin=walkers[ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">base_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">nBase</span> <span class="o">=</span> <span class="n">nOccupied</span>  <span class="c1"># estimated from occupied bins a la Aristoff notes, was np.sum(base_walkers)</span>
        <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nBase</span>
        <span class="k">if</span> <span class="n">nAdapt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alloc</span> <span class="o">*</span> <span class="n">nAdapt</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span> <span class="o">+</span> <span class="n">base_walkers</span>
        <span class="n">indZero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">walkers</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">walkers</span><span class="p">[</span><span class="n">indZero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkers_per_bin</span> <span class="o">=</span> <span class="n">walkers</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_mutV</span> <span class="o">=</span> <span class="n">bin_mutV</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_selV</span> <span class="o">=</span> <span class="n">bin_selV</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nOccupancySS</span> <span class="o">=</span> <span class="n">nT</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nOccupied</span> <span class="o">=</span> <span class="n">nOccupied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAdapt</span> <span class="o">=</span> <span class="n">nAdapt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhomutation</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get_initial_khbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># log-uniform kh bins</span>
        <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_initial_khbins_equalAlloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># kh bins approximately of equal value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_aristoffian</span><span class="p">()</span>
        <span class="n">binMethod_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span>
        <span class="n">allocationMethod_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span>
        <span class="n">nB_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="s2">&quot;adaptive&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">)</span>
        <span class="c1"># resN=np.round(abs(np.max(self.kh)/np.min(np.abs(self.kh)))).astype(int)</span>
        <span class="n">resN</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="n">resN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_model_steady_state_aristoffian</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">kh_unique</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">xB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xB</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">indm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_unique</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">xB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kh_unique</span><span class="p">[</span><span class="n">indm</span><span class="p">]</span>
            <span class="n">dist_unique</span><span class="p">[</span><span class="n">indm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">xB</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="n">nB_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="n">binMethod_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="n">allocationMethod_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bin_kh_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="c1"># alloc=np.zeros(nB) #get bin objective function, value and allocation over set of bins</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># alloc[i]=0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="c1"># wt=np.sum(self.pSS[indBin])</span>
                <span class="c1"># vw=np.sum(np.multiply(self.pSS[indBin]/wt,self.varh[indBin]))</span>
                <span class="c1"># alloc[i]=wt*(vw)**.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_kh_var</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_bin_kh_var</span>

    <span class="k">def</span> <span class="nf">get_bin_total_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># nB = self.nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;optimized&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_model_steady_state_aristoffian</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span>

    <span class="k">def</span> <span class="nf">get_iter_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;This function is untested, and may rely on other untested parts of this code. Use with extreme caution.&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;model_clusters&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_clusters</span><span class="p">()</span>
        <span class="c1">#        if self.pcoord_is_kh:</span>
        <span class="c1"># wt=np.sum(self.pSS[indBin])</span>
        <span class="c1"># vw=np.sum(np.multiply(self.pSS[indBin]/wt,self.varh[indBin]))</span>
        <span class="c1"># alloc[i]=wt*(vw)**.5</span>
        <span class="c1">#            self.khList=np.array(self.pcoord1List[:,1]) #kh is pcoord 2 from optimized WE sims</span>
        <span class="c1">#            self.khList=self.khList[:,np.newaxis]</span>
        <span class="c1">#        else:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># get k-means bins defined over walkers</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="n">khList_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">khList_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">nB</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;adaptive&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">cluster_kmeans</span><span class="p">(</span>
                <span class="n">khList_unique</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
            <span class="p">)</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nB</span><span class="p">:</span>
                <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;log_uniform&quot;</span><span class="p">:</span>
            <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;optimized&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;khbins (khbins_binCenters.dat) not found: initializing</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins_equalAlloc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh_clusters&quot;</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;giving up: log uniform kh bins&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins</span><span class="p">()</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">)</span>
        <span class="n">varh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">nB</span>
        <span class="p">)</span>  <span class="c1"># get bin objective function, value and allocation over set of bins</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">indBin</span><span class="p">],</span> <span class="n">varh_iter</span><span class="p">[</span><span class="n">indBin</span><span class="p">]))</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wt</span> <span class="o">*</span> <span class="n">vw</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span>
        <span class="n">base_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">nBase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">base_walkers</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nAdapt&quot;</span><span class="p">):</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAdapt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nBase</span>
        <span class="k">if</span> <span class="n">nAdapt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alloc</span> <span class="o">*</span> <span class="n">nAdapt</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span> <span class="o">+</span> <span class="n">base_walkers</span>
        <span class="n">indZero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">walkers</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">walkers</span><span class="p">[</span><span class="n">indZero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># ind=np.argsort(khbins_centers_unique) #note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="n">khbins_centers_unique</span>  <span class="c1"># [ind]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkers_per_bin</span> <span class="o">=</span> <span class="n">walkers</span>  <span class="c1"># [ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span>  <span class="c1"># [ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_kh_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_iter_kh_pcoord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># grab coordinates from WE traj_segs folder</span>
        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;model_clusters&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_clusters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>  <span class="c1"># post coordinates</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">khList1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># post pcoord</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates0</span><span class="p">()</span>  <span class="c1"># pre coordinates</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">khList0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># pre pcoord</span>
        <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># this is explicitly set up for p1 (target,basis def) and p2 (kh-aristoffian)</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
            <span class="n">pcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">khList0</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">khList1</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">pcoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">iS</span> <span class="o">&lt;</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                            <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pcoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                        <span class="p">)</span>
                        <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pcoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">)</span>  <span class="c1"># this is explicitly set up for p1 (target,basis def) and p2 (kh-aristoffian)</span>
                        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">pcoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">iS</span> <span class="o">==</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pcoords</span><span class="p">))</span>
                        <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pcoords</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="s2">&quot;pcoords for iteration &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;error overwriting pcoord from &quot;</span>
                    <span class="o">+</span> <span class="n">westFile</span>
                    <span class="o">+</span> <span class="s2">&quot; , iter &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="modelWE.get_committor"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_committor">[docs]</a>    <span class="k">def</span> <span class="nf">get_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iteratively obtain an estimate of the committor.</span>

<span class="sd">        1. Take the flux matrix, and normalize it into a transition matrix.</span>

<span class="sd">        2. Apply two-sided absorbing boundary conditions by setting self-transition probabilities for the basis and</span>
<span class="sd">            target states to 1.0, and all transitions out to 0.0.</span>

<span class="sd">        3. Starting with an initial committor &quot;guess&quot; of all 1s, iteratively multiply the guess by the transition matrix</span>
<span class="sd">            until convergence is below conv.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.q</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conv: numerical</span>
<span class="sd">            Convergence criteria for committor calculation. Calculation stops when the total difference between q_p and q</span>
<span class="sd">            is less than this.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_pseudocommittor_warning</span><span class="p">()</span>

        <span class="n">_fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Number of bins/states in the fluxmatrix</span>

        <span class="n">num_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">)</span>
        <span class="n">flux_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="c1"># If the flux out is positive semidefinite, then normalize that row to get transition probabilities</span>
            <span class="k">if</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>

            <span class="c1"># If the flux out is zero, then just set the self-transition to 1.0</span>
            <span class="c1"># (This probably keeps a calculation later clean?)</span>
            <span class="k">if</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1">#  The basis states are set to have 0 flux out, and only self-transition = 1.0.</span>
        <span class="c1">#   These are the two-sided absorbing BCs for the committor.</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">sinkBins</span><span class="p">:</span>
            <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
            <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Committor to the target state is 1 by definition</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">qp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># Iteratively update the committor estimate until it converges to stationarity</span>
        <span class="c1"># (The committor is the stationary distribution for two-sided absorbing boundary conditions)</span>
        <span class="k">with</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">conv</span><span class="p">))</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span><span class="p">:</span>
                <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="n">q</span><span class="p">))</span>

                <span class="c1"># Update with progress since last iter</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;convergence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dconv</span><span class="p">))</span> <span class="o">-</span> <span class="n">progress</span><span class="p">)</span>
                <span class="n">progress</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dconv</span><span class="p">))</span>

                <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

    <span class="c1"># TODO: This should probably just be a call to get_committor, followed by self.q = 1 - self.q</span>
    <span class="k">def</span> <span class="nf">get_backwards_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
        <span class="n">sM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nR</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span>  <span class="c1"># np.where(avBinPnoColor==0.0)</span>
        <span class="n">nsB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sinkBins</span><span class="p">)</span>
        <span class="n">nsB</span> <span class="o">=</span> <span class="n">nsB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">sinkBins</span><span class="p">:</span>
            <span class="n">Mt</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
            <span class="n">Mt</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>  <span class="c1"># time reversal</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="n">qp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span><span class="p">:</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="n">q</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;convergence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qm</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Pseudocommittor to target&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Average microstate pcoord&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_pseudocommittor_warning</span><span class="p">()</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;committor.png&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">print_pseudocommittor_warning</span><span class="p">():</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Note that, if steady-state weighted ensemble data is being analyzed, this is a &#39;pseudocommittor&#39; &quot;</span>
            <span class="s2">&quot;and not a true committor as a result of being constructed from a one-way ensemble.&quot;</span>
        <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, John Russo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>