<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; msm_we 0.1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="msm_we.msm_we.modelWE" href="stubs/msm_we.msm_we.modelWE.html" />
    <link rel="prev" title="msm_we" href="readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> msm_we
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">msm_we</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.msm_we.modelWE.html">msm_we.msm_we.modelWE</a></li>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.fpt.html">msm_we.fpt</a></li>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.ensembles.html">msm_we.ensembles</a></li>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.nmm.html">msm_we.nmm</a></li>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.phat.html">msm_we.phat</a></li>
<li class="toctree-l2"><a class="reference internal" href="stubs/msm_we.utils.html">msm_we.utils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Installation/Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="code_todos.html">TODOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">msm_we</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline"></a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/msm_we.msm_we.modelWE.html#msm_we.msm_we.modelWE" title="msm_we.msm_we.modelWE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.msm_we.modelWE</span></code></a></p></td>
<td><p>Implementation of haMSM model building, particularly for steady-state estimation (but there are lots of extras), from WE sampling with basis (source) and target (sink) states with recycling.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stubs/msm_we.fpt.html#module-msm_we.fpt" title="msm_we.fpt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.fpt</span></code></a></p></td>
<td><p>Adapted from the original NMpathAnalysis package, <a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/msm_we.ensembles.html#module-msm_we.ensembles" title="msm_we.ensembles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.ensembles</span></code></a></p></td>
<td><p>Adapted from the original NMpathAnalysis package, <a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stubs/msm_we.nmm.html#module-msm_we.nmm" title="msm_we.nmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.nmm</span></code></a></p></td>
<td><p>Adapted from the original NMpathAnalysis package, <a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/msm_we.phat.html#module-msm_we.phat" title="msm_we.phat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.phat</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stubs/msm_we.utils.html#module-msm_we.utils" title="msm_we.utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.utils</span></code></a></p></td>
<td><p>Adapted from the original NMpathAnalysis package, <a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p></td>
</tr>
</tbody>
</table>
<span class="target" id="module-msm_we.msm_we"></span><p>Main module.</p>
<dl class="py function">
<dt class="sig sig-object py" id="msm_we.msm_we.is_connected">
<span class="sig-prename descclassname"><span class="pre">msm_we.msm_we.</span></span><span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#is_connected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.is_connected" title="Permalink to this definition"></a></dt>
<dd><p>Check for connectivity between two states.
If directed is True, then checks for directional connectivity from source_states to target_states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>np.array</em><em>, </em><em>NxN</em>) – Transition matrix</p></li>
<li><p><strong>source_states</strong> (<em>array-like</em><em>, </em><em>N</em>) – Source states</p></li>
<li><p><strong>target_states</strong> (<em>array-like</em><em>, </em><em>N</em>) – Target states</p></li>
<li><p><strong>directed</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Compute directional connectivity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.msm_we.inverse_iteration">
<span class="sig-prename descclassname"><span class="pre">msm_we.msm_we.</span></span><span class="sig-name descname"><span class="pre">inverse_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#inverse_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.inverse_iteration" title="Permalink to this definition"></a></dt>
<dd><p>Do one iteration of inverse iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>guess</strong> (<em>array-like</em><em>  (</em><em>N elements</em><em>)</em>) – Vector of weights to be used as the initial guess.</p></li>
<li><p><strong>matrix</strong> (<em>array-like</em><em> (</em><em>NxN elements</em><em>)</em>) – Transition matrix to use for inverse iteration.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The new vector of weights after one iteration of inverse iteration.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.msm_we.</span></span><span class="sig-name descname"><span class="pre">modelWE</span></span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of haMSM model building, particularly for steady-state estimation (but there are lots of extras),
from WE sampling with basis (source) and target (sink) states with recycling.</p>
<p>Set up for typical west.h5 file structure, with coordinates to be stored in west.h5 /iterations/auxdata/coord and
basis and target definitions from progress coordinates.</p>
<p>Check out run_msmWE.slurm and run_msmWE_flux.py in scripts folder for an implementation example.</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>This code currently, in general, appears to assume a 1-D progress coordinate.</p>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<dl>
<dt>Refactor</dt><dd><p>In general, this class’s methods generally handle data by holding state in the object.
The functions that update state with the result of a calculation, though, tend to update a lot of state on the way.
The state being updated along the way is usually “helper” quantities (an example would be the number of bins
or number of walkers, which is computed “along the way” in a number of functions, and the object state updated.)</p>
<p>I think it would be prudent to refactor these in such a way that these are updated in as few places as possible –
one example of this might be setting them as properties, and then updating the value in state as part of that
accessor if necessary.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Copperman and Zuckerman,
<em>Accelerated estimation of long-timescale kinetics by combining weighted ensemble simulation with Markov model
microstategs using non-Markovian theory</em>, <strong>arXiv</strong> (2020).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.modelName">
<span class="sig-name descname"><span class="pre">modelName</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.modelName" title="Permalink to this definition"></a></dt>
<dd><p>Name used for storing files</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.fileList">
<span class="sig-name descname"><span class="pre">fileList</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.fileList" title="Permalink to this definition"></a></dt>
<dd><p>List of all filenames with data</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.n_data_files">
<span class="sig-name descname"><span class="pre">n_data_files</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.n_data_files" title="Permalink to this definition"></a></dt>
<dd><p>Number of files in <code class="code docutils literal notranslate"><span class="pre">fileList</span></code></p>
<p><strong>TODO</strong>: Deprecate this, this could just be a property</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.pcoord_ndim">
<span class="sig-name descname"><span class="pre">pcoord_ndim</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.pcoord_ndim" title="Permalink to this definition"></a></dt>
<dd><p>Number of dimensions in the progress coordinate</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.pcoord_len">
<span class="sig-name descname"><span class="pre">pcoord_len</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.pcoord_len" title="Permalink to this definition"></a></dt>
<dd><p>Number of stored progress coordinates for each iteration, per-segment.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.tau">
<span class="sig-name descname"><span class="pre">tau</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.tau" title="Permalink to this definition"></a></dt>
<dd><p>Resampling time for weighted ensemble. (Maybe should be int? Units?)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.WEtargetp1_max">
<span class="sig-name descname"><span class="pre">WEtargetp1_max</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.WEtargetp1_max" title="Permalink to this definition"></a></dt>
<dd><p>Progress coordinate value at target state.
Used to check if a progress coord is in the target, and to set the RMSD of the target cluster when cleaning the
fluxmatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.WEbasisp1_min">
<span class="sig-name descname"><span class="pre">WEbasisp1_min</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.WEbasisp1_min" title="Permalink to this definition"></a></dt>
<dd><p>Minimum progress coordinate value within basis state.
Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the
fluxmatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.WEbasisp1_max">
<span class="sig-name descname"><span class="pre">WEbasisp1_max</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.WEbasisp1_max" title="Permalink to this definition"></a></dt>
<dd><p>Maximum progress coordinate value within basis state.
Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the
fluxmatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.dimReduceMethod">
<span class="sig-name descname"><span class="pre">dimReduceMethod</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.dimReduceMethod" title="Permalink to this definition"></a></dt>
<dd><p>Dimensionality reduction method. Must be one of “pca”, “vamp”, or “none” (<strong>NOT</strong> NoneType)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.min_walkers">
<span class="sig-name descname"><span class="pre">min_walkers</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.min_walkers" title="Permalink to this definition"></a></dt>
<dd><p>Test description for minwalkers</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.segindList">
<span class="sig-name descname"><span class="pre">segindList</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.segindList" title="Permalink to this definition"></a></dt>
<dd><p>List of segment indices(?)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.weightList">
<span class="sig-name descname"><span class="pre">weightList</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.weightList" title="Permalink to this definition"></a></dt>
<dd><p>List of segment weights in an iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.n_hist">
<span class="sig-name descname"><span class="pre">n_hist</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.n_hist" title="Permalink to this definition"></a></dt>
<dd><p>Number of steps of history information to use when building transitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.targetRMSD_centers">
<span class="sig-name descname"><span class="pre">targetRMSD_centers</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.targetRMSD_centers" title="Permalink to this definition"></a></dt>
<dd><p>List of RMSDs corresponding to each cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.cluster_structure_weights">
<span class="sig-name descname"><span class="pre">cluster_structure_weights</span></span><a class="headerlink" href="#msm_we.msm_we.modelWE.cluster_structure_weights" title="Permalink to this definition"></a></dt>
<dd><p>Mapping of cluster indices to structures in that cluster</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileSpecifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refPDBfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_pcoord_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_pcoord_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_reduce_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcoord_ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.initialize" title="Permalink to this definition"></a></dt>
<dd><p>Initialize the model-builder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fileSpecifier</strong> (<em>list</em>) – List of paths to H5 files to analyze.</p></li>
<li><p><strong>refPDBfile</strong> (<em>string</em>) – Path to PDB file that defines topology.</p></li>
<li><p><strong>modelName</strong> (<em>string</em>) – Name to use in output filenames.</p></li>
<li><p><strong>basis_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the basis state</p></li>
<li><p><strong>target_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the target state</p></li>
<li><p><strong>dim_reduce_method</strong> (<em>str</em>) – Dimensionality reduction method. “pca”, “vamp”, or “none”.</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</p></li>
<li><p><strong>pcoord_ndim</strong> (<em>int</em>) – Defaults to 1. Dimensionality of progress coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Some of this logic should be broken into a constructor, and default arguments handled in the constructor’s
function signature.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.progress_disable">
<span class="sig-name descname"><span class="pre">progress_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.progress_disable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.progress_disable" title="Permalink to this definition"></a></dt>
<dd><p>Disable all progress bars</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.progress_enable">
<span class="sig-name descname"><span class="pre">progress_enable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.progress_enable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.progress_enable" title="Permalink to this definition"></a></dt>
<dd><p>Enable all progress bars</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.initialize_from_h5">
<span class="sig-name descname"><span class="pre">initialize_from_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">refPDBfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initPDBfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.initialize_from_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.initialize_from_h5" title="Permalink to this definition"></a></dt>
<dd><p>Like initialize, but sets state without
:param refPDBfile:
:param initPDBfile:
:param modelName:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.is_WE_basis">
<span class="sig-name descname"><span class="pre">is_WE_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pcoords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.is_WE_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.is_WE_basis" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the input progress coordinates are in the basis state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pcoords</strong> (<em>numpy.ndarray</em><em>(</em><em>num_segments</em><em>, </em><em>num_pcoords</em><em>)</em>) – Array of progress coordinates for each segment.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>True or False</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>This only checks the 0th progress coordinate</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.is_WE_target">
<span class="sig-name descname"><span class="pre">is_WE_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pcoords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.is_WE_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.is_WE_target" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the input progress coordinates are in the target state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pcoords</strong> (<em>numpy.ndarray</em><em>(</em><em>num_segments</em><em>, </em><em>num_pcoords</em><em>)</em>) – Array of progress coordinates for each segment.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>True or False</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>This only checks the 0th progress coordinate</p>
<p>This also assumes you need a small pcoord!</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.load_iter_data">
<span class="sig-name descname"><span class="pre">load_iter_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.load_iter_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.load_iter_data" title="Permalink to this definition"></a></dt>
<dd><p>Update state with the data (including pcoord but not including coords) corresponding to an iteration.</p>
<dl class="simple">
<dt>Object fields updated with the information from the selected iteration:</dt><dd><ul class="simple">
<li><p><cite>self.westList</cite></p></li>
<li><p><cite>self.segindList</cite></p></li>
<li><p><cite>self.weightList</cite></p></li>
<li><p><cite>self.n_segs</cite></p></li>
<li><p><cite>self.pcoord0List</cite></p></li>
<li><p><cite>self.pcoord1List</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_iter</strong> (<em>int</em>) – Iteration to get data for.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>May want to rework the logic here, depending on how this is used.
Seems like some of this iteration can be removed/optimized.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_iterations">
<span class="sig-name descname"><span class="pre">get_iterations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_iterations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Updates internal state with the maximum number of iterations, and the number of segments in each section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This updates <code class="code docutils literal notranslate"><span class="pre">numSegments</span></code> – <code class="code docutils literal notranslate"><span class="pre">numSegments</span></code> is actually a <em>list</em> of the number of segments in each iteration.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_iterations_iters">
<span class="sig-name descname"><span class="pre">get_iterations_iters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_iterations_iters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_iterations_iters" title="Permalink to this definition"></a></dt>
<dd><p>Updates internal state with the maximum number of iterations, and the number of segments in each section.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_iter</strong> (<em>int</em>) – </p></li>
<li><p><strong>last_iter</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is potentially deprecated or unnecessary. Currently unused.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.set_topology">
<span class="sig-name descname"><span class="pre">set_topology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topology</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.set_topology"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.set_topology" title="Permalink to this definition"></a></dt>
<dd><p>Updates internal state with a new topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>topology</strong> (<em>str</em>) – Path to a file containing the PDB with the topology, OR, an mdtraj Trajectory object describing
the new basis structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.set_basis">
<span class="sig-name descname"><span class="pre">set_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.set_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.set_basis" title="Permalink to this definition"></a></dt>
<dd><p>Updates internal state with a new basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>basis</strong> (<em>str</em><em> or </em><em>mdtraj.Trajectory</em>) – Path to a file containing the PDB with the new basis state, OR, an mdtraj Trajectory object describing
the new basis structure.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_transition_data">
<span class="sig-name descname"><span class="pre">get_transition_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_lag</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_transition_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_transition_data" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>This function analyzes pairs of coordinates at the current iteration, set by <code class="code docutils literal notranslate"><span class="pre">self.n_iter</span></code>, and at some</dt><dd><p>lag in the past, <code class="code docutils literal notranslate"><span class="pre">self.n_iter</span> <span class="pre">-</span> <span class="pre">n_lag</span></code>.</p>
</dd>
</dl>
<p>Segments where a walker was warped (recycled) use the basis coords as the lagged coords.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_lag</strong> (<em>int</em>) – Number of lags to use for transitions.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_transition_data_lag0">
<span class="sig-name descname"><span class="pre">get_transition_data_lag0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_transition_data_lag0"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_transition_data_lag0" title="Permalink to this definition"></a></dt>
<dd><p>Get coordinate pairs at the beginning and end of this iteration.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p>self.coordPairList, a list of  parent/child coordinate pairs</p></li>
<li><p>self.transitionWeights, a copy of self.weightList</p></li>
<li><p>self.departureWeights, a copy of self.weightList</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_warps_from_parent">
<span class="sig-name descname"><span class="pre">get_warps_from_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_warps_from_parent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_warps_from_parent" title="Permalink to this definition"></a></dt>
<dd><p>Get all warps and weights over a range of iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_iter</strong> (<em>int</em>) – First iteration in range.</p></li>
<li><p><strong>last_iter</strong> (<em>int</em>) – Last iteration in range.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>warpedWeights</strong> – List of weights for each warp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_seg_histories">
<span class="sig-name descname"><span class="pre">get_seg_histories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_hist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_seg_histories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_seg_histories" title="Permalink to this definition"></a></dt>
<dd><p><strong>TODO: What does this do exactly?</strong></p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p>self.seg_histories</p></li>
<li><p>self.weight_histories</p></li>
<li><p>self.n_hist</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_hist</strong> (<em>int</em>) – Number of steps of history information to include.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.collect_iter_coordinates">
<span class="sig-name descname"><span class="pre">collect_iter_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.collect_iter_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.collect_iter_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Goes through the generated trajectory segments, and adds data from the segments to an H5 file.</p>
<p>This should be implemented by the user, and this implementation assumes a really specific configuration.
This is left in mostly as an example.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>Generalize to different filetypes. This appears to be AMBER specific and relies on loading rst7 files</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_iter_coordinates">
<span class="sig-name descname"><span class="pre">get_iter_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_iter_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_iter_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Return the valid coordinates for a certain iteration</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iteration</strong> (<em>int</em>) – The iteration to return coordinates for</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Array of coordinates for all atoms at the current iteration</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.load_iter_coordinates">
<span class="sig-name descname"><span class="pre">load_iter_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.load_iter_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.load_iter_coordinates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_coordinates">
<span class="sig-name descname"><span class="pre">get_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Unused</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_iter</strong> – </p></li>
<li><p><strong>last_iter</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_coordSet">
<span class="sig-name descname"><span class="pre">get_coordSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_coordSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_coordSet" title="Permalink to this definition"></a></dt>
<dd><p>Loads all coordinates and progress coordinates into memory for later usage.</p>
<p>If streaming, then this only loads pcoords</p>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>I want to avoid loading full coordinates into memory as much as possible.
That means trying to replace usage of all_coords here.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>last_iter</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.dimReduce">
<span class="sig-name descname"><span class="pre">dimReduce</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.dimReduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.dimReduce" title="Permalink to this definition"></a></dt>
<dd><p>Dimensionality reduction using the scheme specified in initialization.</p>
<p>This just defines the dimensionality reduction scheme – it does NOT actually run it!</p>
<dl class="simple">
<dt>Dimensionality reduction is actually performed via reduceCoordinates(), which uses self.coordinates as set</dt><dd><p>by this.</p>
</dd>
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.coordinates</cite></p></li>
<li><p><cite>self.ndim</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id8">
<p class="admonition-title">Todo</p>
<p>Allow passing custom parameters to the dimensionality reduction schemes.</p>
<p>Add <cite>else</cite> clause that raises a <cite>NotImplemented</cite> exception</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.Coordinates">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Coordinates</span></span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.Coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.Coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Fake Coordinates class, in case you don’t want to use either PCA or VAMP for dimensionality reduction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.reduceCoordinates">
<span class="sig-name descname"><span class="pre">reduceCoordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.reduceCoordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.reduceCoordinates" title="Permalink to this definition"></a></dt>
<dd><p>This performs the dimensionality reduction.</p>
<p>dimReduce() defines self.coordinates, which is an object that has a .transform() function that produces the
reduced data.</p>
<p>reduceCoordinates() actually uses that coordinates object, transforms the coordinates,
and returns the reduced data.</p>
<p>The reduced coordinates are then stored in /auxdata for each iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coords</strong> (<em>array-like</em>) – Array of coordinates to reduce.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Reduced data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.update_cluster_structures">
<span class="sig-name descname"><span class="pre">update_cluster_structures</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.update_cluster_structures"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.update_cluster_structures" title="Permalink to this definition"></a></dt>
<dd><p>Find structures (i.e. sets of coordinates) corresponding to each clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>in that cluster.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A dictionary where the keys are cluster indices, and the values are lists of coordinates (structures)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.cluster_coordinates">
<span class="sig-name descname"><span class="pre">cluster_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cluster_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_cluster_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.cluster_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.cluster_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Use k-means to cluster coordinates into <cite>n_clusters</cite> cluster centers, and saves the resulting cluster object
to a file.</p>
<p>Saved cluster file is named
“&lt;<cite>self.model_name</cite>&gt;_clusters_s&lt;<cite>self.first_iter</cite>&gt;_e&lt;<cite>self.last_iter</cite>&gt;_nC&lt;<cite>self.n_clusters</cite>&gt;.h5”</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.n_clusters</cite></p></li>
<li><p><cite>self.clusters</cite></p></li>
<li><p><cite>self.clusterFile</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_clusters</strong> (<em>int</em>) – Number of cluster centers to use.</p></li>
<li><p><strong>streaming</strong> (<em>boolean</em>) – Whether to stream k-means clustering, or load all from memory.
Not supported for vamp dimensionality reduction.</p></li>
<li><p><strong>**_cluster_args</strong> – Keyword arguments that will be passed directly to cluster_kmeans</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.load_clusters">
<span class="sig-name descname"><span class="pre">load_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusterFile</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.load_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.load_clusters" title="Permalink to this definition"></a></dt>
<dd><p>Load clusters from a file.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.clusters</cite></p></li>
<li><p><cite>self.n_clusters</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clusterFile</strong> (<em>str</em>) – Filename to load clusters from.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_iter_fluxMatrix">
<span class="sig-name descname"><span class="pre">get_iter_fluxMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_iter_fluxMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_iter_fluxMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Get the flux matrix for an iteration.</p>
<ol class="arabic simple">
<li><p>Update state with data from the iteration you want to compute the flux matrix for</p></li>
<li><p>Load transition data at the requested lag</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_iter</strong> – </p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id9">
<p class="admonition-title">Todo</p>
<p>This function is slow because of the call to get_transition_data_lag0(). See that function for more info.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_iter_pcoord1D_fluxMatrix_lag0">
<span class="sig-name descname"><span class="pre">get_iter_pcoord1D_fluxMatrix_lag0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binbounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_iter_pcoord1D_fluxMatrix_lag0"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_iter_pcoord1D_fluxMatrix_lag0" title="Permalink to this definition"></a></dt>
<dd><p>Compute a flux-matrix in the space of the 1D progress coordinate, at a given iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_iter</strong> (<em>integer</em>) – Iteration to compute flux matrix for</p></li>
<li><p><strong>binbounds</strong> (<em>array-like</em>) – Array of progress coordinate bin boundaries</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The fluxmatrix at iteration n_iter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_fluxMatrix">
<span class="sig-name descname"><span class="pre">get_fluxMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_lag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_fluxMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_fluxMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the matrix of fluxes at a given lag time, for a range of iterations.</p>
<p>Checks if a file has been written named
“&lt;<cite>self.modelName</cite>&gt;_s&lt;<cite>first_iter</cite>&gt;_e&lt;<cite>last_iter</cite>&gt;_lag&lt;<cite>n_lag</cite>&gt;_clust&lt;<cite>self.n_clusters</cite>&gt;.h5”.
If this file exists, load it and recalculate if it was calculated at an earlier iteration.
Otherwise, write it.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.n_lag</cite></p></li>
<li><p><cite>self.errorWeight</cite></p></li>
<li><p><cite>self.errorCount</cite></p></li>
<li><p><cite>self.fluxMatrixRaw</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_lag</strong> (<em>int</em>) – Number of lags to use.</p></li>
<li><p><strong>first_iter</strong> (<em>int</em>) – First iteration to use.</p></li>
<li><p><strong>last_iter</strong> (<em>int</em>) – Last iteration to use.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.organize_fluxMatrix">
<span class="sig-name descname"><span class="pre">organize_fluxMatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.organize_fluxMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.organize_fluxMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Do some cleaning on the flux matrix, and update state with the cleaned flux matrix.</p>
<dl class="simple">
<dt>Namely:</dt><dd><ul class="simple">
<li><p>Remove unvisited clusters</p></li>
<li><p>Remove bins with no connectivity</p></li>
<li><p>Sort along the bins’ projection in pcoord 1</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>Need to update self.cluster_structures with the new, reduced set of clusters</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_model_clusters">
<span class="sig-name descname"><span class="pre">get_model_clusters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_model_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_model_clusters" title="Permalink to this definition"></a></dt>
<dd><p>Used by get_iter_aristoffian(). Untested and un-debugged, use at your own risk.</p>
<p>Updates:
- self.model_clusters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_Tmatrix">
<span class="sig-name descname"><span class="pre">get_Tmatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_Tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_Tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the transition matrix from the flux matrix.
Corrects the “target” states to be true sink states.</p>
<dl class="simple">
<dt>More specifically:</dt><dd><ul class="simple">
<li><p>row-normalizes the flux matrix,</p></li>
<li><p>sets any states with 0 flux ot (i.e. sinks) to have 1.0</p></li>
<li><p>sets target bins to uniformly recycle into basis bins</p></li>
</ul>
</dd>
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.Tmatrix</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_steady_state">
<span class="sig-name descname"><span class="pre">get_steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flux_fractional_convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_steady_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_steady_state" title="Permalink to this definition"></a></dt>
<dd><p>”
Get the steady-state distribution for the transition matrix.
Uses scipy eigensolver to obtain an initial guess, then refines that using inverse iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flux_fractional_convergence</strong> (<em>(</em><em>optional</em><em>, </em><em>default=1e-4</em><em>) </em><em>float</em>) – Convergence of the</p></li>
<li><p><strong>max_iters</strong> (<em>(</em><em>optional</em><em>, </em><em>default=100</em><em>) </em><em>int</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Transition matrices generated from WE data may have entries spanning many orders of magnitude, and may have
extremely high condition numbers.
Furthermore, the smallest entries may be those near the target state, which are also the most important
for computing target fluxes, meaning values near machine precision can’t just be truncated.
All this means that floating-point error may substantially affect the results of eigensolvers, and may produce
bad/negative/inaccurate values for small probability bins.</p>
<p>In order to obtain better estimates, sparse matrices are used to reduce the number of floating point operations
being performed.
A stationary distribution is first estimated using scipy’s eigensolver for sparse matrices.
This is then used as an initial guess for the inverse iteration method, to further refine it.
Convergence of the inverse iteration is determined using change in the flux estimate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_steady_state_algebraic">
<span class="sig-name descname"><span class="pre">get_steady_state_algebraic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_steady_state_algebraic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_steady_state_algebraic" title="Permalink to this definition"></a></dt>
<dd><p>Compute the steady-state distribution as the eigenvectors of the transition matrix.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.pSS</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iters</strong> (<em>int</em><em>, </em><em>optional</em>) – Defaults to 1000. Number of power-method iterations to run if the numpy eigensolver returns negative elements.</p></li>
<li><p><strong>check_negative</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True. If True, then raise an Exception if there are negative elements in the normalized pSS.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_steady_state_matrixpowers">
<span class="sig-name descname"><span class="pre">get_steady_state_matrixpowers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_steady_state_matrixpowers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_steady_state_matrixpowers" title="Permalink to this definition"></a></dt>
<dd><p>Compute the steady-state distribution using the matrix power method.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.pSS</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>conv</strong> (<em>numeric</em>) – Convergence criterion for iteration.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_steady_state_target_flux">
<span class="sig-name descname"><span class="pre">get_steady_state_target_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pSS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_steady_state_target_flux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_steady_state_target_flux" title="Permalink to this definition"></a></dt>
<dd><p>Get the total flux into the target state(s).</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.lagtime</cite></p></li>
<li><p><cite>self.JtargetSS</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pSS</strong> (<em>(</em><em>optional</em><em>) </em><em>array-like</em>) – Steady-state distribution. If nothing provided, then use self.pSS</p></li>
<li><p><strong>_set</strong> (<em>(</em><em>optional</em><em>) </em><em>boolean</em>) – If True, then update self.JtargetSS and self.lagtime. If False, then just return the value of JtargetSS.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_flux">
<span class="sig-name descname"><span class="pre">get_flux</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_flux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_flux" title="Permalink to this definition"></a></dt>
<dd><p>Get the measured flux (i.e. from the flux matrix) into the target.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_flux_committor">
<span class="sig-name descname"><span class="pre">get_flux_committor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_flux_committor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_flux_committor" title="Permalink to this definition"></a></dt>
<dd><p>Get the flux binned according to committors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.plot_flux">
<span class="sig-name descname"><span class="pre">plot_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">custom_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.plot_flux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.plot_flux" title="Permalink to this definition"></a></dt>
<dd><p>Make, and save, a plot of the fluxes along the RMSD.  get_flux() must be run before this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>custom_name</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – The name for the saved plot. Defaults to flux_s&lt;first iter&gt;_e&lt;last iter&gt;.png</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.msm_we.modelWE.get_committor">
<span class="sig-name descname"><span class="pre">get_committor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.get_committor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.msm_we.modelWE.get_committor" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively obtain an estimate of the committor.</p>
<ol class="arabic simple">
<li><p>Take the flux matrix, and normalize it into a transition matrix.</p></li>
<li><dl class="simple">
<dt>Apply two-sided absorbing boundary conditions by setting self-transition probabilities for the basis and</dt><dd><p>target states to 1.0, and all transitions out to 0.0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Starting with an initial committor “guess” of all 1s, iteratively multiply the guess by the transition matrix</dt><dd><p>until convergence is below conv.</p>
</dd>
</dl>
</li>
</ol>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p>self.q</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>conv</strong> (<em>numerical</em>) – Convergence criteria for committor calculation. Calculation stops when the total difference between q_p and q
is less than this.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.fpt"></span><p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">MatrixFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class for calculating FPTs using transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculting mean-first passave time for at transition matrix</p>
<p>Derived class will implement this function differently.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.directional_mfpt">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">directional_mfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_probs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.directional_mfpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.directional_mfpt" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mean-first passage time in a single direction using a recursive procedure</p>
<p>This method is useful when there is no B-&gt;A ensemble but only A-&gt;B transitions,
for instance when B is absorbing.</p>
<p>transition_matrix:  Numpy 2D array</p>
<dl class="simple">
<dt>stateA, stateB:     List of integers</dt><dd><p>Both states are a list of indexes.</p>
</dd>
<dt>ini_probs:          List of float, default is None</dt><dd><p>initial probabilities in stateA</p>
</dd>
<dt>lag_time:           integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage time from A-&gt;B</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mfpts_to_target_microstate">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">mfpts_to_target_microstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mfpts_to_target_microstate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mfpts_to_target_microstate" title="Permalink to this definition"></a></dt>
<dd><p>Computes all the mean-first passage to a target microstate (k)</p>
<p>Returns a list where the i-element is mfpt(i-&gt;k). This function is
useful to compute the mfpt matrix.</p>
<p>transition_matrix:  Numpy 2D array</p>
<dl class="simple">
<dt>target:             Integer number that specifies the index of the state. The indexes</dt><dd><p>should be consistent with the transition matrix and python
(i.e. starting from 0)</p>
</dd>
<dt>lag_time:           Integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>a list where the i-element is mfpt(i-&gt;k). This function is</em></p></li>
<li><p><em>useful to compute the mfpt matrix.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mfpts_matrix">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">mfpts_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mfpts_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mfpts_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculate MFPT matrix, i.e., the matrix where the ij-element is MFPT(i-&gt;j)</p>
<p>transition_matrix:  Numpy 2D array</p>
<dl class="simple">
<dt>lag_time:           Integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage time matrix with ij-element of MFPT(i-&gt;j)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.min_commute_time">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">min_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix_of_mfpts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.min_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.min_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Calculate minimum commuting time (round trip time) between all pairs</p>
<p>of microstates from the matrix of mfpts. It also returns the indexes
of the pair of microstates involved.</p>
<dl class="simple">
<dt>matrix_of_mfpts:    Numpy 2D array</dt><dd><p>matrix of MFPTs with ij-element of MFPT(i-&gt;j)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Minimum commuting time (round trip time) between all pairs</em></p></li>
<li><p><em>of microstates and the indexes of the pair of microstates involved.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.max_commute_time">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">max_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix_of_mfpts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.max_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.max_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Calculate maximum commuting time (round trip time) between all pairs</p>
<p>of microstates from the matrix of mfpts. It also returns the indexes
of the pair of microstates involved.</p>
<dl class="simple">
<dt>matrix_of_mfpts:    Numpy 2D array</dt><dd><p>matrix of MFPTs with ij-element of MFPT(i-&gt;j)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>Maximum commuting time (round trip time) between all pairs</em></p></li>
<li><p><em>of microstates and the indexes of the pair of microstates involved.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.fpt_distribution">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">fpt_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_distrib</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_lags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_recycling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.fpt_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.fpt_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Calculated distribution of first passage times from transition matrix</p>
<p>t_matrix:           Numpy 2D array</p>
<p>initial_state,
final_states:       List of integer numbers</p>
<blockquote>
<div><p>Specifies the indexes of initial and final states.</p>
</div></blockquote>
<dl class="simple">
<dt>ini_probs:          List of float, default is None</dt><dd><p>initial probabilities for initial states</p>
</dd>
</dl>
<p>min_power,
max_power:          Integer</p>
<blockquote>
<div><p>The minimum and maximum power when the FPT distribution is
shown in logscale such as (10^min_power, 10^max_power)*lag_time*dt.</p>
</div></blockquote>
<dl class="simple">
<dt>max_n_lags:         Integer</dt><dd><p>maximum number of lags when the FPT distribution is shown in linear
scale such as (0, max_n_logs)*lag_time*dt. When in logscale, this is number
of points to shown in the range of (10^min_power, 10^max_power)*lag_time*dt.</p>
</dd>
<dt>lag_time:           Integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
<dt>dt:                 Float</dt><dd><p>Time step</p>
</dd>
<dt>clean_recycling:    Bool</dt><dd><p>Cleaning the recycling of steady state simulation if True</p>
</dd>
<dt>logscale:           Bool</dt><dd><p>Option to use logscale for FPT time in the distribution</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Distributions of first passage times</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">MarkovFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT" title="Permalink to this definition"></a></dt>
<dd><p>Derived a class for calculating FPTs using Markovian transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">markov_tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Computes mean first passage times using Markovian transition matrix</p>
<p>in both directions A-&gt;B and B-&gt;A from a markov model. The MFPTs computed
in this way are directly comparable with the values obtained by a long back
and forth simulation between the target states.</p>
<dl class="simple">
<dt>markov_matrix:      Numpy 2D array</dt><dd><p>Markovian transition matrix</p>
</dd>
<dt>stateA, stateB:     List of integers</dt><dd><p>Both states are a list of indexes.</p>
</dd>
<dt>lag_time:           integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage times from A-&gt;B and B-&gt;A</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT.markov_commute_time">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">markov_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT.markov_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT.markov_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Computing commute time for Markovian Model</p>
<dl class="simple">
<dt>transition_matrix:  Numpy 2D array</dt><dd><p>Markovian transition matrix</p>
</dd>
<dt>stateA, stateB:     List of integers</dt><dd><p>Both states are a list of indexes.</p>
</dd>
<dt>lag_time:           integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Commute time from mean-first passage times</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.NonMarkovFPT">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">NonMarkovFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#NonMarkovFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.NonMarkovFPT" title="Permalink to this definition"></a></dt>
<dd><p>Derived a class for calculating FPTs using Non Markov transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.NonMarkovFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nm_transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#NonMarkovFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.NonMarkovFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mean first passage times from a non-markovian model</p>
<p>in both directions of A-&gt;B and B-&gt;A. The shape of the transition matrix
should be (2*n_states, 2*n_states).
Parameters:
———–
nm_transition_matrix:   Numpy 2D array</p>
<blockquote>
<div><p>Non-Markovian transition matrix</p>
</div></blockquote>
<dl class="simple">
<dt>stateA, stateB:         List of integers</dt><dd><p>Both states are a list of indexes.</p>
</dd>
<dt>lag_time:               integer</dt><dd><p>Lag time used, the trajectory is “observed” every lag_time
time steps</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage times from A-&gt;B and B-&gt;A</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.ensembles"></span><p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">Ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class to store a list of space-continuous trajectories</p>
<blockquote>
<div><p>e.g.: [ trajectory1, trajectory2,…], each trajectory is just a matrix</p>
</div></blockquote>
<p>where each row is a snapshot, and each column represents the evolution
of the corresponding variable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.add_trajectory">
<span class="sig-name descname"><span class="pre">add_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.add_trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.add_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Add a single trajectory to the ensemble</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.empirical_mfpts">
<span class="sig-name descname"><span class="pre">empirical_mfpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.empirical_mfpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.empirical_mfpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculate mean first passage time using direct counting method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.empirical_corr_function">
<span class="sig-name descname"><span class="pre">empirical_corr_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.empirical_corr_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.empirical_corr_function" title="Permalink to this definition"></a></dt>
<dd><p>Calculate correlation function for trajectories</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.PathEnsemble">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">PathEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#PathEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.PathEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Derive a class to store trajectories for path analysis</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.PathEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#PathEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.PathEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a PathEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">DiscreteEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class to store a list of space-discrete trajectories</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a DiscreteEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble.from_transition_matrix">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble.from_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble.from_transition_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates a DiscreteEnsemble from the transition matrix</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">DiscretePathEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Derive a class to store a list of discrete trajectories for path analysis</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.from_transition_matrix">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_paths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_pops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.from_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.from_transition_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Construct a path ensemble from a transition matrix</p>
<p>stateA:     list, intitial state</p>
<p>stateB:     list, final state</p>
<dl>
<dt>n_paths:    integer, with default value of 1000</dt><dd><p>number of paths to generate</p>
</dd>
<dt>ini_pops:   list or label, probability distribution over the</dt><dd><p>initial state used to generate the path</p>
<p>a) None
Use a uniform distribution over the states in stateA
c) list
A list with the explicit values of the populations in stateA
that should be used to generate the ensemble</p>
</dd>
<dt>max_iters:  integer, with default value of 1000000000</dt><dd><p>maximum of iterations for generating path trajectories</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a DiscreteEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.nm_mfpt">
<span class="sig-name descname"><span class="pre">nm_mfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ini_probs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.nm_mfpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.nm_mfpt" title="Permalink to this definition"></a></dt>
<dd><p>Compute the mean-first passage time from the transition matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.weighted_fundamental_sequences">
<span class="sig-name descname"><span class="pre">weighted_fundamental_sequences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.weighted_fundamental_sequences"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.weighted_fundamental_sequences" title="Permalink to this definition"></a></dt>
<dd><p>Generate sorted fundamental sequences with weights</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.nmm"></span><p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.nmm.</span></span><span class="sig-name descname"><span class="pre">NonMarkovModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sliding_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markovian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coarse_macrostates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel" title="Permalink to this definition"></a></dt>
<dd><p>Define a class for analyzing MD trajectories using Markovian or non-Markovian Model</p>
<p>from a list of 1D trajectories of integers representing macrostates</p>
<p>For example:</p>
<p>trajectories = [ [1 , 2, 0, …], [2, 2, 1, …], [3, 1, 2, …], …]</p>
<p>If only one sequence is given in trajectories, the format is the same:</p>
<p>trajectories = [ [1 , 2, 0, …] ]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>integer</strong> (<em>lag_time</em>) – Lag time of the model.</p></li>
<li><p><strong>default</strong> – Lag time of the model.</p></li>
<li><p><strong>(</strong><strong>boolean</strong><strong>)</strong> (<em>sliding_window</em>) – Use a sliding window of length lag_time to compute the count matrix</p></li>
<li><p><strong>stateA</strong> – Define the initial and final macrostates in form of python lists
for example: stateA=[0,2,5], stateB = [1]</p></li>
<li><p><strong>lists</strong><strong>)</strong> (<em>stateB</em><em> (</em><em>python</em>) – Define the initial and final macrostates in form of python lists
for example: stateA=[0,2,5], stateB = [1]</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.n_states">
<span class="sig-name descname"><span class="pre">n_states</span></span><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.n_states" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.nm_cmatrix">
<span class="sig-name descname"><span class="pre">nm_cmatrix</span></span><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.nm_cmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Stores the number of transitions between states, the i,j element cij
stores the number of transitions observed from i to j.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, with shape (2 n_states, 2 n_states)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.populations">
<span class="sig-name descname"><span class="pre">populations</span></span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.populations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.populations" title="Permalink to this definition"></a></dt>
<dd><p>Equilibrium population, the steady state solution of of the
transition matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (n_states,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits the non-Markovian model from a list of sequences</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.from_nm_tmatrix">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.from_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.from_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates a discrete ensemble from the transition matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.empirical_mfpts">
<span class="sig-name descname"><span class="pre">empirical_mfpts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.empirical_mfpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.empirical_mfpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculate mean first passage time using direct counting method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.corr_function">
<span class="sig-name descname"><span class="pre">corr_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.corr_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.corr_function" title="Permalink to this definition"></a></dt>
<dd><p>Compute the correlation function for a set of times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>integers</strong><strong>)</strong> (<em>times</em><em> (</em><em>list of</em>) – List of dt values used to compute the correlation function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List of floats with the correlation values for the dt given in times</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.nmm.MarkovPlusColorModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.nmm.</span></span><span class="sig-name descname"><span class="pre">MarkovPlusColorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sliding_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#MarkovPlusColorModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.MarkovPlusColorModel" title="Permalink to this definition"></a></dt>
<dd><p>Define a class for analyzing MD trajectories using Markovian Plus Color Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.MarkovPlusColorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#MarkovPlusColorModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.MarkovPlusColorModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits the markov plus color model from a list of sequences</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.phat"></span><dl class="py class">
<dt class="sig sig-object py" id="msm_we.phat.PathwayClassifier">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">PathwayClassifier</span></span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayClassifier" title="Permalink to this definition"></a></dt>
<dd><p>Base class for parametrized pathway classifiers.</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayClassifier.classify">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayClassifier.classify"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayClassifier.classify" title="Permalink to this definition"></a></dt>
<dd><p>Return the pathway class of a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>object</em>) – An object (e.g., a time series) representing a sample path
of a stochastic process.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The pathway class of the trajectory.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>hashable object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayClassifier.histogram">
<span class="sig-name descname"><span class="pre">histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayClassifier.histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayClassifier.histogram" title="Permalink to this definition"></a></dt>
<dd><p>Return a pathway histogram filled with the given trajectory data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectories</strong> (<em>iterable</em>) – Trajectories to be classified.</p></li>
<li><p><strong>weights</strong> (<em>iterable of float</em><em>, </em><em>optional</em>) – The weight of each trajectory. By default, each trajectory
has weight 1. Weights are paired with trajectories in the
order they are iterated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pathway histogram of the given data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#msm_we.phat.PathwayHistogram" title="msm_we.phat.PathwayHistogram">PathwayHistogram</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.phat.FundamentalSequenceClassifier">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">FundamentalSequenceClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#FundamentalSequenceClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.FundamentalSequenceClassifier" title="Permalink to this definition"></a></dt>
<dd><p>Fundamental sequence (FS) classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>(</em><em>N</em><em>, </em><em>N</em><em>) </em><em>array_like</em>) – Transition matrix of a discrete time Markov chain. Must be
a stochastic matrix with row sums equal to one.</p></li>
<li><p><strong>states</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array_like</em><em>, </em><em>optional</em>) – State labels of the Markov chain. Values must be hashable.
Default is <code class="docutils literal notranslate"><span class="pre">range(N)</span></code>.</p></li>
<li><p><strong>symmetrized</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, classify paths by symmetrized FS.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.FundamentalSequenceClassifier.graph">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">graph</span></span><a class="headerlink" href="#msm_we.phat.FundamentalSequenceClassifier.graph" title="Permalink to this definition"></a></dt>
<dd><p>Surprisal graph of the underlying Markov chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>nx.Graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.FundamentalSequenceClassifier.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discrete_trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#FundamentalSequenceClassifier.classify"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.FundamentalSequenceClassifier.classify" title="Permalink to this definition"></a></dt>
<dd><p>Return the pathway class of a discrete trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>discrete_trajectory</strong> (<em>sequence</em>) – A node path in <a class="reference internal" href="#msm_we.phat.FundamentalSequenceClassifier.graph" title="msm_we.phat.FundamentalSequenceClassifier.graph"><code class="xref py py-attr docutils literal notranslate"><span class="pre">graph</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The fundamental sequence of <cite>discrete_trajectory</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.phat.VoronoiPathwayClassifier">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">VoronoiPathwayClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#VoronoiPathwayClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.VoronoiPathwayClassifier" title="Permalink to this definition"></a></dt>
<dd><p>A classifier based on a Voronoi partition of trajectory space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>centers</strong> (<em>iterable</em>) – Trajectories to be used as Voronoi centers.</p></li>
<li><p><strong>distance</strong> (<em>callable</em><em>, </em><em>optional</em>) – A function that takes two trajectories and returns their distance.
The default distance between two trajectories <cite>s</cite> and <cite>q</cite> is the
symmetric difference cardinality <code class="docutils literal notranslate"><span class="pre">len(set(s)</span> <span class="pre">^</span> <span class="pre">set(q))</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.VoronoiPathwayClassifier.centers">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">centers</span></span><a class="headerlink" href="#msm_we.phat.VoronoiPathwayClassifier.centers" title="Permalink to this definition"></a></dt>
<dd><p>Voronoi centers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>sequence</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.VoronoiPathwayClassifier.distance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">distance</span></span><a class="headerlink" href="#msm_we.phat.VoronoiPathwayClassifier.distance" title="Permalink to this definition"></a></dt>
<dd><p>Distance function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.VoronoiPathwayClassifier.classify">
<span class="sig-name descname"><span class="pre">classify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#VoronoiPathwayClassifier.classify"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.VoronoiPathwayClassifier.classify" title="Permalink to this definition"></a></dt>
<dd><p>Return the pathway class of a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>object</em>) – An object (e.g., a time series) representing a sample path
of a stochastic process.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The zero-based index of the closest Voronoi center. Ties are
broken according to the ordering of <a class="reference internal" href="#msm_we.phat.VoronoiPathwayClassifier.centers" title="msm_we.phat.VoronoiPathwayClassifier.centers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">centers</span></code></a>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.phat.WeightedSample">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">WeightedSample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#WeightedSample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.WeightedSample" title="Permalink to this definition"></a></dt>
<dd><p>A sequence of (observation, weight) pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observations</strong> (<em>iterable</em><em>, </em><em>default</em><em> (</em><em>)</em>) – A sequence of observations.</p></li>
<li><p><strong>weights</strong> (<em>iterable of floats</em><em>, </em><em>optional</em>) – The weight of each observation. By default, each observation
has weight 1. Weights are paired with observations in the
order they are iterated.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.WeightedSample.observations">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">observations</span></span><a class="headerlink" href="#msm_we.phat.WeightedSample.observations" title="Permalink to this definition"></a></dt>
<dd><p>Iterator over the observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.WeightedSample.weights">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">weights</span></span><a class="headerlink" href="#msm_we.phat.WeightedSample.weights" title="Permalink to this definition"></a></dt>
<dd><p>Iterator over the weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.WeightedSample.total_weight">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">total_weight</span></span><a class="headerlink" href="#msm_we.phat.WeightedSample.total_weight" title="Permalink to this definition"></a></dt>
<dd><p>Sum of the weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">PathwayHistogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram" title="Permalink to this definition"></a></dt>
<dd><p>A pathway histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>classifier</strong> (<em>callable</em>) – A function that takes a single trajectory as input and returns a
hashable value representing the pathway class of the trajectory.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.classifier">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">classifier</span></span><a class="headerlink" href="#msm_we.phat.PathwayHistogram.classifier" title="Permalink to this definition"></a></dt>
<dd><p>Mapping from trajectories to pathway classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.data">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#msm_we.phat.PathwayHistogram.data" title="Permalink to this definition"></a></dt>
<dd><p>Read-only view of histogram data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>types.MappingProxyType</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.classes">
<span class="sig-name descname"><span class="pre">classes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram.classes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram.classes" title="Permalink to this definition"></a></dt>
<dd><p>Iterable[Hashable]: Pathway classes (block labels).</p>
<p>Alias self.data.keys().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.blocks">
<span class="sig-name descname"><span class="pre">blocks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram.blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram.blocks" title="Permalink to this definition"></a></dt>
<dd><p>Iterable[WeightedSample]: Data belonging to each class.</p>
<p>Alias self.data.values().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram.add" title="Permalink to this definition"></a></dt>
<dd><p>Add a trajectory to the histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>object</em>) – Trajectory to be classified.</p></li>
<li><p><strong>weight</strong> (<em>float</em><em>, </em><em>default 1.0</em>) – The weight of the trajectory.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram.fill"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram.fill" title="Permalink to this definition"></a></dt>
<dd><p>Fill the histogram with data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectories</strong> (<em>iterable</em>) – Trajectories to be classified.</p></li>
<li><p><strong>weights</strong> (<em>iterable of float</em><em>, </em><em>optional</em>) – The weight of each trajectory. By default, each trajectory
has weight 1. Weights are paired with trajectories in the
order they are iterated.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, retain any existing data in the histogram. If False,
clear the histogram before filling with the given data.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.phat.PathwayHistogram.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#PathwayHistogram.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.PathwayHistogram.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all data from the histogram.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.phat.pathway_histogram">
<span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">pathway_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#pathway_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.pathway_histogram" title="Permalink to this definition"></a></dt>
<dd><p>Construct a pathway histogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classifier</strong> (<a class="reference internal" href="#msm_we.phat.PathwayClassifier" title="msm_we.phat.PathwayClassifier"><em>PathwayClassifier</em></a>) – A function that maps a trajectory to its pathway class.</p></li>
<li><p><strong>trajectories</strong> (<em>iterable</em>) – Trajectories to be classified.</p></li>
<li><p><strong>weights</strong> (<em>iterable of float</em><em>, </em><em>optional</em>) – The weight of each trajectory. By default, each trajectory
has weight 1. Weights are paired with trajectories in the
order they are iterated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pathway histogram of the given data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#msm_we.phat.PathwayHistogram" title="msm_we.phat.PathwayHistogram">PathwayHistogram</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.phat.surprisal_graph">
<span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">surprisal_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stationary_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#surprisal_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.surprisal_graph" title="Permalink to this definition"></a></dt>
<dd><p>Return the surprisal graph of a discrete-time Markov chain.</p>
<blockquote>
<div><dl class="simple">
<dt>transition_matrix<span class="classifier">(N, N) array_like</span></dt><dd><dl class="simple">
<dt>Transition matrix of a discrete-time Markov chain. Must be</dt><dd><p>a stochastic matrix with row sums equal to one.</p>
</dd>
</dl>
</dd>
<dt>states<span class="classifier">(N,) array_like, optional</span></dt><dd><p>State labels of the Markov chain. Values must be unique and
hashable. Default is <code class="docutils literal notranslate"><span class="pre">range(N)</span></code>.</p>
</dd>
<dt>symmetrized<span class="classifier">bool, default True</span></dt><dd><p>If True, edge weights are round-trip distances. If False, weights
are one-way distances. See Notes for details.</p>
</dd>
<dt>stationary_distribution<span class="classifier">(N,) array_like, optional</span></dt><dd><p>Stationary distribution of <cite>transition_matrix</cite>. Ignored when
<cite>symmetrized</cite> is False. If <cite>symmetrized</cite> is True and the
stationary distribution has already been computed, this parameter
can be passed to avoid redundant computation.</p>
</dd>
</dl>
<dl class="simple">
<dt>graph<span class="classifier">nx.DiGraph</span></dt><dd><p>The (symmetrized) surprisal graph of the Markov chain. The weight
of edge <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> is given by <code class="docutils literal notranslate"><span class="pre">graph[x][y]['surprisal']</span></code>.</p>
</dd>
</dl>
<p>The <em>surprisal graph</em> of a Markov chain with state space
<span class="math notranslate nohighlight">\(V\)</span> and transition matrix <span class="math notranslate nohighlight">\(T \colon V   imes V  o [0, 1]\)</span>
is the weighted directed graph <span class="math notranslate nohighlight">\((V, E, \delta)\)</span> with edges</p>
<div class="math notranslate nohighlight">
\[E = \{ (x, y) : T(x, y) &gt; 0       ext{ and } x\]</div>
</div></blockquote>
<p>e y }</p>
<blockquote>
<div><p>and weights <span class="math notranslate nohighlight">\(\delta \colon E  o [0, \infty)\)</span> given by</p>
<div class="math notranslate nohighlight">
\[\delta(x, y) = -\log T(x, y).\]</div>
<p>The edge weight <span class="math notranslate nohighlight">\(\delta(x, y)\)</span> is the
<a class="reference external" href="https://en.wikipedia.org/wiki/Information_content">information content</a>,
or <em>surprisal</em>, of a one-step transition from <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>For a reversible Markov chain, the <em>symmetrized</em> surprisal graph is
the graph <span class="math notranslate nohighlight">\((V, E, \delta^*)\)</span> with edge weights</p>
<div class="math notranslate nohighlight">
\[\delta^*(x, y) = \delta(x, y) + \delta(y, x).\]</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.phat.fundamental_sequence">
<span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">fundamental_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'surprisal'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#fundamental_sequence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.fundamental_sequence" title="Permalink to this definition"></a></dt>
<dd><p>Return the fundamental sequence of a path (walk).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>nx.Graph</em>) – A NetworkX graph.</p></li>
<li><p><strong>path</strong> (<em>sequence</em>) – A node path in <cite>graph</cite>.</p></li>
<li><p><strong>weight_attr</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>default 'surprisal'</em>) – Name of the edge attribute to use as a weight/distance/cost.
If None, all edges have equal weight.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The fundamental sequence of <cite>path</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.phat.loop_erasure">
<span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">loop_erasure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#loop_erasure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.loop_erasure" title="Permalink to this definition"></a></dt>
<dd><p>Return the loop-erasure of a discrete sample path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>sequence</em>) – A sequence of hashable values.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The loop erasure of <cite>path</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.phat.symmetric_difference_cardinality">
<span class="sig-prename descclassname"><span class="pre">msm_we.phat.</span></span><span class="sig-name descname"><span class="pre">symmetric_difference_cardinality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/phat.html#symmetric_difference_cardinality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.phat.symmetric_difference_cardinality" title="Permalink to this definition"></a></dt>
<dd><p>Return the cardinality of the symmetric difference of two sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>iterable</em>) – Elements of the first set. Values must be hashable.</p></li>
<li><p><strong>q</strong> (<em>iterable</em>) – Elements of the second set. Values must be hashable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">len(set(s)</span> <span class="pre">^</span> <span class="pre">set(q))</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-msm_we.utils"></span><p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.utils.Interval">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">Interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_variables</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#Interval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.Interval" title="Permalink to this definition"></a></dt>
<dd><p>Intervals are in general defined as half-open interval [start,end).</p>
<p>in any case, in each dimension the interval is specified using a list [a,b]
where a &lt; b</p>
<ul>
<li><p>For 1D (single) interval a single list in the form [a,b] has to be given</p></li>
<li><dl class="simple">
<dt>The union of multiple (1D) intervals can be specified as:</dt><dd><p>[[a,b],[c,d],…]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A list of lists [[a,b],[c,d],…] are used for a n-dimensional</dt><dd><p>intervals, one for each dimension, i.e, len(interval) = n_variables</p>
</dd>
</dl>
</li>
<li><dl>
<dt>A list-of-lists-of-lists for the mathematical union of n-dimensional</dt><dd><p>intervals’</p>
<p>[ [[a,b],[c,d],…],  [[e,f],[g,h],…], … ]</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.reverse_sort_lists">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">reverse_sort_lists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#reverse_sort_lists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.reverse_sort_lists" title="Permalink to this definition"></a></dt>
<dd><p>Reverse sorting two list based on the first one</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.weighted_choice">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">weighted_choice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#weighted_choice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.weighted_choice" title="Permalink to this definition"></a></dt>
<dd><p>Select an element from a list with probability from weights</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.get_shape">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">get_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#get_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.get_shape" title="Permalink to this definition"></a></dt>
<dd><p>Get the shape of a trajectory array in tuple (n_snapshots, n_variables)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.num_of_nonzero_elements">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">num_of_nonzero_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#num_of_nonzero_elements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.num_of_nonzero_elements" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of non-zero elements in a vector</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.normalize_markov_matrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">normalize_markov_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#normalize_markov_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.normalize_markov_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Transform a matrix of positive elements to a markov-like matrix</p>
<p>by dividing each row by the sum of the elements of the row.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.normalize">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.normalize" title="Permalink to this definition"></a></dt>
<dd><p>Normalize a vector</p>
<p>by dividing each element by the total sum of all its elements</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.random_markov_matrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">random_markov_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#random_markov_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.random_markov_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random transition markov matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.check_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">check_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_null_rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#check_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.check_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Check if the given matrix is actually a row-stochastic transition matrix</p>
<blockquote>
<div><p>i.e, all the elements are non-negative and the rows add to one.</p>
</div></blockquote>
<p>If the keyword argument accept_null_rows is True, is going
to accept rows where all the elements are zero. Those “problematic”
states are going to be removed later if necessary by clean_tmatrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.clean_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">clean_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rm_absorbing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#clean_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.clean_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Removes the states/indexes with no transitions and that are absorbing</p>
<p>if the the keyword argument rm_absorbing is true
Returns the “clean” transition matrix and a list with the
removed states/indexes (clean_tmatrix, removed_states)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pops_from_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pops_from_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pops_from_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pops_from_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the eigen values and eigen vectors of the transposed transition matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transition_matrix</strong> (<em>ndarray with shape =</em><em> (</em><em>n_states</em><em>, </em><em>n_states</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>the solution, p, of K.T p = p where K.T is the transposed transition matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pops_from_nm_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pops_from_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pops_from_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pops_from_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the populations of the real/physical states</p>
<p>from a non-Markovian transtion matrix with shape (2*n_states, 2*n_states)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.map_to_integers">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">map_to_integers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#map_to_integers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.map_to_integers" title="Permalink to this definition"></a></dt>
<dd><p>Map a sequence of elements to a sequence of integers
for intance, maps [1, ‘a’, 1, ‘b’, 2.2] to [0, 1, 0, 2, 3]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pseudo_nm_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pseudo_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">markovian_tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pseudo_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pseudo_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Obtain a pseudo non-Markovian transition matrix from a Markovian transiton matrix</p>
<p>The pseudo Markovian matrix has a shape of (2 n_states, 2 n_states)</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="readme.html" class="btn btn-neutral float-left" title="msm_we" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="stubs/msm_we.msm_we.modelWE.html" class="btn btn-neutral float-right" title="msm_we.msm_we.modelWE" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, John Russo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>