<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Documentation &mdash; msm_we 0.1.4 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="TODOs" href="code_todos.html" />
    <link rel="prev" title="Trp-cage WE Optimization" href="_examples/optimization.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> msm_we
          </a>
              <div class="version">
                0.1.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">msm_we</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Installation/Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#hamsm-model-building-and-analysis-msm-we-modelwe">haMSM model building and analysis (msm_we.modelWE)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.modelWE"><code class="docutils literal notranslate"><span class="pre">modelWE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#construction">Construction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.build_analyze_model"><code class="docutils literal notranslate"><span class="pre">modelWE.build_analyze_model()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.initialize"><code class="docutils literal notranslate"><span class="pre">modelWE.initialize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_coordSet"><code class="docutils literal notranslate"><span class="pre">modelWE.get_coordSet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.dimReduce"><code class="docutils literal notranslate"><span class="pre">modelWE.dimReduce()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.cluster_coordinates"><code class="docutils literal notranslate"><span class="pre">modelWE.cluster_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_fluxMatrix"><code class="docutils literal notranslate"><span class="pre">modelWE.get_fluxMatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.organize_fluxMatrix"><code class="docutils literal notranslate"><span class="pre">modelWE.organize_fluxMatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.do_block_validation"><code class="docutils literal notranslate"><span class="pre">modelWE.do_block_validation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#analysis">Analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_Tmatrix"><code class="docutils literal notranslate"><span class="pre">modelWE.get_Tmatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_steady_state"><code class="docutils literal notranslate"><span class="pre">modelWE.get_steady_state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_steady_state_target_flux"><code class="docutils literal notranslate"><span class="pre">modelWE.get_steady_state_target_flux()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_committor"><code class="docutils literal notranslate"><span class="pre">modelWE.get_committor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_flux"><code class="docutils literal notranslate"><span class="pre">modelWE.get_flux()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.get_cluster_centers"><code class="docutils literal notranslate"><span class="pre">modelWE.get_cluster_centers()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#plotting">Plotting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.plot_flux"><code class="docutils literal notranslate"><span class="pre">modelWE.plot_flux()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.plot_flux_committor"><code class="docutils literal notranslate"><span class="pre">modelWE.plot_flux_committor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.modelWE.plot_flux_committor_pcoordcolor"><code class="docutils literal notranslate"><span class="pre">modelWE.plot_flux_committor_pcoordcolor()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-msm_we.optimization">Optimization (msm_we.optimization)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.optimization.solve_discrepancy"><code class="docutils literal notranslate"><span class="pre">solve_discrepancy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.optimization.get_uniform_mfpt_bins"><code class="docutils literal notranslate"><span class="pre">get_uniform_mfpt_bins()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.optimization.get_clustered_mfpt_bins"><code class="docutils literal notranslate"><span class="pre">get_clustered_mfpt_bins()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.optimization.OptimizedBinMapper"><code class="docutils literal notranslate"><span class="pre">OptimizedBinMapper</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.optimization.OptimizedBinMapper.create_new"><code class="docutils literal notranslate"><span class="pre">OptimizedBinMapper.create_new()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-msm_we.westpa_plugins.augmentation_driver">WESTPA Plugins (msm_we.westpa_plugins)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver"><code class="docutils literal notranslate"><span class="pre">MDAugmentationDriver</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver.augment_coordinates"><code class="docutils literal notranslate"><span class="pre">MDAugmentationDriver.augment_coordinates()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.westpa_plugins.hamsm_driver.HAMSMDriver"><code class="docutils literal notranslate"><span class="pre">HAMSMDriver</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.hamsm_driver.HAMSMDriver.construct_hamsm"><code class="docutils literal notranslate"><span class="pre">HAMSMDriver.construct_hamsm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver"><code class="docutils literal notranslate"><span class="pre">RestartDriver</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.get_original_bins"><code class="docutils literal notranslate"><span class="pre">RestartDriver.get_original_bins()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.cur_iter"><code class="docutils literal notranslate"><span class="pre">RestartDriver.cur_iter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.is_last_iteration"><code class="docutils literal notranslate"><span class="pre">RestartDriver.is_last_iteration</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_extension_run"><code class="docutils literal notranslate"><span class="pre">RestartDriver.prepare_extension_run()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_new_we"><code class="docutils literal notranslate"><span class="pre">RestartDriver.prepare_new_we()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.do_optimization"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.do_optimization()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_allocation_optimizer"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.default_allocation_optimizer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_allocation"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.compute_optimized_allocation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_bin_optimizer"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.default_bin_optimizer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_bins"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.compute_optimized_bins()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_new_pcoord_map"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.compute_new_pcoord_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.update_westpa_pcoord"><code class="docutils literal notranslate"><span class="pre">OptimizationDriver.update_westpa_pcoord()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fpt-calculations">FPT Calculations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-msm_we.fpt">msm_we.fpt</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.fpt.MatrixFPT"><code class="docutils literal notranslate"><span class="pre">MatrixFPT</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.fpt.MarkovFPT"><code class="docutils literal notranslate"><span class="pre">MarkovFPT</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.fpt.NonMarkovFPT"><code class="docutils literal notranslate"><span class="pre">NonMarkovFPT</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-msm_we.ensembles">msm_we.ensembles</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.ensembles.Ensemble"><code class="docutils literal notranslate"><span class="pre">Ensemble</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.ensembles.PathEnsemble"><code class="docutils literal notranslate"><span class="pre">PathEnsemble</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.ensembles.DiscreteEnsemble"><code class="docutils literal notranslate"><span class="pre">DiscreteEnsemble</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.ensembles.DiscretePathEnsemble"><code class="docutils literal notranslate"><span class="pre">DiscretePathEnsemble</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-msm_we.nmm">msm_we.nmm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.nmm.NonMarkovModel"><code class="docutils literal notranslate"><span class="pre">NonMarkovModel</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.nmm.MarkovPlusColorModel"><code class="docutils literal notranslate"><span class="pre">MarkovPlusColorModel</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-msm_we.utils">msm_we.utils</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.find_connected_sets"><code class="docutils literal notranslate"><span class="pre">find_connected_sets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.is_connected"><code class="docutils literal notranslate"><span class="pre">is_connected()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.inverse_iteration"><code class="docutils literal notranslate"><span class="pre">inverse_iteration()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.Interval"><code class="docutils literal notranslate"><span class="pre">Interval</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.reverse_sort_lists"><code class="docutils literal notranslate"><span class="pre">reverse_sort_lists()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.weighted_choice"><code class="docutils literal notranslate"><span class="pre">weighted_choice()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.get_shape"><code class="docutils literal notranslate"><span class="pre">get_shape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.num_of_nonzero_elements"><code class="docutils literal notranslate"><span class="pre">num_of_nonzero_elements()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.normalize_markov_matrix"><code class="docutils literal notranslate"><span class="pre">normalize_markov_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.normalize"><code class="docutils literal notranslate"><span class="pre">normalize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.random_markov_matrix"><code class="docutils literal notranslate"><span class="pre">random_markov_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.check_tmatrix"><code class="docutils literal notranslate"><span class="pre">check_tmatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.clean_tmatrix"><code class="docutils literal notranslate"><span class="pre">clean_tmatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.pops_from_tmatrix"><code class="docutils literal notranslate"><span class="pre">pops_from_tmatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.pops_from_nm_tmatrix"><code class="docutils literal notranslate"><span class="pre">pops_from_nm_tmatrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.map_to_integers"><code class="docutils literal notranslate"><span class="pre">map_to_integers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#msm_we.utils.pseudo_nm_tmatrix"><code class="docutils literal notranslate"><span class="pre">pseudo_nm_tmatrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="code_todos.html">TODOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">msm_we</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading"></a></h1>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.modelWE</span></code></a></p></td>
<td><p>History-augmented Markov state model estimation from WE data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-msm_we.optimization" title="msm_we.optimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.optimization</span></code></a></p></td>
<td><p>Discrepancy calculations and WE binning/allocation optimization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-msm_we.fpt" title="msm_we.fpt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.fpt</span></code></a></p></td>
<td><p>First-passage time (FPT) calculations from trajectories or matrices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-msm_we.ensembles" title="msm_we.ensembles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.ensembles</span></code></a></p></td>
<td><p>Implements Ensemble class for managing trajectories</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-msm_we.nmm" title="msm_we.nmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.nmm</span></code></a></p></td>
<td><p>&quot;Non-Markovian&quot; trajectory analysis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-msm_we.utils" title="msm_we.utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.utils</span></code></a></p></td>
<td><p>Miscellaneous convenience functions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-msm_we.westpa_plugins.augmentation_driver" title="msm_we.westpa_plugins.augmentation_driver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.westpa_plugins.augmentation_driver</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-msm_we.westpa_plugins.hamsm_driver" title="msm_we.westpa_plugins.hamsm_driver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.westpa_plugins.hamsm_driver</span></code></a></p></td>
<td><p>Plugin for automated haMSM construction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#module-msm_we.westpa_plugins.restart_driver" title="msm_we.westpa_plugins.restart_driver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.westpa_plugins.restart_driver</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#module-msm_we.westpa_plugins.optimization_driver" title="msm_we.westpa_plugins.optimization_driver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">msm_we.westpa_plugins.optimization_driver</span></code></a></p></td>
<td><p>Plugin for automated WE hyperparameter optimization.</p></td>
</tr>
</tbody>
</table>
<section id="hamsm-model-building-and-analysis-msm-we-modelwe">
<h2>haMSM model building and analysis (msm_we.modelWE)<a class="headerlink" href="#hamsm-model-building-and-analysis-msm-we-modelwe" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.modelWE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.</span></span><span class="sig-name descname"><span class="pre">modelWE</span></span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.modelWE" title="Permalink to this definition"></a></dt>
<dd><p>History-augmented Markov state model estimation from WE data</p>
<p>Implementation of haMSM model building, particularly for steady-state estimation
from recycling WE sampling with basis (source) and target (sink) states.</p>
<p>Set up for typical west.h5 file structure, with coordinates to be stored in west.h5 /iterations/auxdata/coord and
basis and target definitions in progress coordinate space.</p>
<p class="rubric">References</p>
<p>Copperman and Zuckerman,
<em>Accelerated estimation of long-timescale kinetics by combining weighted ensemble simulation with Markov model
microstategs using non-Markovian theory</em>, <strong>arXiv</strong> (2020).</p>
</dd></dl>

<section id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Permalink to this heading"></a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.build_analyze_model">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">build_analyze_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_struct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_pcoord_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_pcoord_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimreduce_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_coord_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluxmatrix_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1,</span> <span class="pre">-1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluxmatrix_iters_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_validation_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_validation_blocks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_live_display</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_validation_failure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.build_analyze_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.modelWE.build_analyze_model" title="Permalink to this definition"></a></dt>
<dd><p>One-shot function to build the model and analyze all at once. This provides a convenient interface for running
the blockwise estimation.</p>
<p>This may not be desirable for very long workflows, or workflows still being debugged, where it might make sense
to run the individual steps one by one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_paths</strong> (<em>list</em>) – List of paths to H5 files to analyze.</p></li>
<li><p><strong>ref_struct</strong> (<em>string</em>) – Path to PDB file that defines topology.</p></li>
<li><p><strong>modelName</strong> (<em>string</em>) – Name to use in output filenames.</p></li>
<li><p><strong>basis_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the basis state</p></li>
<li><p><strong>target_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the target state</p></li>
<li><p><strong>dimreduce_method</strong> (<em>str</em>) – Dimensionality reduction method. “pca”, “vamp”, or “none”.</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</p></li>
<li><p><strong>n_clusters</strong> (<em>int</em>) – Number of clusters to use when clustering. This is clusters per bin for stratified, or total clusters for
aggregate.</p></li>
<li><p><strong>ray_kwargs</strong> (<em>dict</em>) – Keyword arguments passed to ray.init(). Useful for specifying num_cpus. You could also use this to connect
to an existing Ray cluster.</p></li>
<li><p><strong>max_coord_iter</strong> (<em>int</em><em>, </em><em>optional</em><em> (</em><em>Default = model.maxIter</em><em>, </em><em>so all</em><em>)</em>) – Last iteration to obtain coordinates from. Useful for excluding the end of some data.</p></li>
<li><p><strong>stratified</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>Default = True</em><em>)</em>) – Enables stratified clustering, where clustering is performed independently within each WE bin.</p></li>
<li><p><strong>streaming</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>Default = True</em><em>)</em>) – Enables streaming over input data, rather than batch processing. Substantially improves memory efficiency,
at a potential small performance hit.</p></li>
<li><p><strong>use_ray</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>Default = True</em><em>)</em>) – Enable parallelization, using Ray. This provides substantial speedup in discretization and fluxmatrix
calculations.</p></li>
<li><p><strong>fluxmatrix_iters</strong> (<em>list</em><em>, </em><em>optional</em><em> (</em><em>Default =</em><em> [</em><em>1</em><em>, </em><em>-1</em><em>]</em><em>)</em>) – List of [first, last] iteration to use when calculating fluxmatrix. Defaults to using all iterations.</p></li>
<li><p><strong>fluxmatrix_iters_to_use</strong> (<em>list</em><em>, </em><em>optional</em><em> (</em><em>Default = None</em><em>)</em>) – Specific range of iterations to use, as opposed to bounds like fluxmatrix_iters. Note that either this OR
fluxmatrix_iters</p></li>
<li><p><strong>cross_validation_groups</strong> (<em>int</em><em>, </em><em>optional</em><em> (</em><em>Default = 2</em><em>)</em>) – Number of independent models to build when doing cross-validation. Each group contains (blocks / groups)
blocks.</p></li>
<li><p><strong>cross_validation_blocks</strong> (<em>int</em><em>, </em><em>optional</em><em> (</em><em>Default = 4</em><em>)</em>) – Number of blocks to split your data into, before building the independent models.</p></li>
<li><p><strong>show_live_display</strong> – </p></li>
<li><p><strong>allow_validation_failure</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>Default = False</em><em>)</em>) – If True, then raise a warning but don’t fail if construction of a cross-validation model fails.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.initialize">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileSpecifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refPDBfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_pcoord_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_pcoord_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_reduce_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcoord_ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_suppress_boundary_warning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights_in_clustering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.modelWE.initialize" title="Permalink to this definition"></a></dt>
<dd><p>Initialize the model-builder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fileSpecifier</strong> (<em>list</em>) – List of paths to H5 files to analyze.</p></li>
<li><p><strong>refPDBfile</strong> (<em>string</em>) – Path to PDB file that defines topology.</p></li>
<li><p><strong>modelName</strong> (<em>string</em>) – Name to use in output filenames.</p></li>
<li><p><strong>basis_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the basis state</p></li>
<li><p><strong>target_pcoord_bounds</strong> (<em>list</em>) – List of [[pcoord0 lower bound, pcoord1 upper bound], [pcoord1 lower bound, pcoord1 upper bound], …]
in pcoord-space for the target state</p></li>
<li><p><strong>dim_reduce_method</strong> (<em>str</em><em>, </em><em>default=&quot;none&quot;</em>) – Dimensionality reduction method. “pca”, “vamp”, or “none”.</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</p></li>
<li><p><strong>pcoord_ndim</strong> (<em>int</em><em>, </em><em>default=1</em>) – Defaults to 1. Dimensionality of progress coordinates.</p></li>
<li><p><strong>auxpath</strong> (<em>str</em><em>, </em><em>default=&quot;coord&quot;</em>) – Augmented coordinates used for MSM construction are stored in west.h5 under auxdata/auxpath</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_coordSet">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_coordSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">last_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_coordSet" title="Permalink to this definition"></a></dt>
<dd><p>Loads all coordinates and progress coordinates into memory for later usage.</p>
<p>If streaming, then this only loads pcoords</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>last_iter</strong> – </p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.dimReduce">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">dimReduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_rough_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rough_stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fine_stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.dimReduce" title="Permalink to this definition"></a></dt>
<dd><p>Dimensionality reduction using the scheme specified in initialization.</p>
<p>This just defines the dimensionality reduction scheme and builds the model – it does NOT actually transform
the data!</p>
<dl class="simple">
<dt>Transforming the data is performed via reduceCoordinates(), which uses self.coordinates as set</dt><dd><p>by this.</p>
</dd>
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.coordinates</cite></p></li>
<li><p><cite>self.ndim</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.cluster_coordinates">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">cluster_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_cluster_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_validation_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_cluster_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.cluster_coordinates" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_fluxMatrix">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_fluxMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_lag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result_batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_fluxMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the matrix of fluxes at a given lag time, for a range of iterations.</p>
<p>Checks if a file has been written named
“&lt;<cite>self.modelName</cite>&gt;_s&lt;<cite>first_iter</cite>&gt;_e&lt;<cite>last_iter</cite>&gt;_lag&lt;<cite>n_lag</cite>&gt;_clust&lt;<cite>self.n_clusters</cite>&gt;.h5”.
If this file exists, load it and recalculate if it was calculated at an earlier iteration.
Otherwise, write it.</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.n_lag</cite></p></li>
<li><p><cite>self.errorWeight</cite></p></li>
<li><p><cite>self.errorCount</cite></p></li>
<li><p><cite>self.fluxMatrixRaw</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_lag</strong> (<em>int</em>) – Number of lags to use.</p></li>
<li><p><strong>first_iter</strong> (<em>int</em>) – First iteration to use.</p></li>
<li><p><strong>last_iter</strong> (<em>int</em>) – Last iteration to use.</p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.organize_fluxMatrix">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">organize_fluxMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_ray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.organize_fluxMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This cleaning step removes all clusters that aren’t in the largest connected set, then rediscretizes all the
trajectories according to the new reduced set of clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.do_block_validation">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">do_block_validation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cross_validation_groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_validation_blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/msm_we.html#modelWE.do_block_validation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.modelWE.do_block_validation" title="Permalink to this definition"></a></dt>
<dd><p>One way to estimate the uncertainty of your model is to split your data into blocks, compute models over
groups of the blocks, and assess consistency between the groups.</p>
<p>The procedure here chops your data up into uniform blocks, by iteration. For example, with 100 iterations and 4
blocks, the blocks consist of iterations <cite>[0-25), [25-50), [50-75), [75-100)</cite>.
If the above blocks were assigned to 2 groups, the groups would consist of iterations <cite>( [0-25), [50-75) )</cite> and
<cite>(  [25-50), [75-100) )</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cross_validation_groups</strong> (<em>int</em>) – Number of groups to assign blocks over</p></li>
<li><p><strong>cross_validation_blocks</strong> (<em>int</em>) – Number of blocks to split data into</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="analysis">
<h3>Analysis<a class="headerlink" href="#analysis" title="Permalink to this heading"></a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_Tmatrix">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_Tmatrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_Tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute the transition matrix from the flux matrix.
Corrects the “target” states to be true sink states.</p>
<dl class="simple">
<dt>More specifically:</dt><dd><ul class="simple">
<li><p>row-normalizes the flux matrix,</p></li>
<li><p>sets any states with 0 flux ot (i.e. sinks) to have 1.0</p></li>
<li><p>sets target bins to uniformly recycle into basis bins</p></li>
</ul>
</dd>
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.Tmatrix</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_steady_state">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flux_fractional_convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_steady_state" title="Permalink to this definition"></a></dt>
<dd><p>”
Get the steady-state distribution for the transition matrix.
Uses scipy eigensolver to obtain an initial guess, then refines that using inverse iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flux_fractional_convergence</strong> (<em>(</em><em>optional</em><em>, </em><em>default=1e-4</em><em>) </em><em>float</em>) – Convergence of the</p></li>
<li><p><strong>max_iters</strong> (<em>(</em><em>optional</em><em>, </em><em>default=100</em><em>) </em><em>int</em>) – </p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Transition matrices generated from WE data may have entries spanning many orders of magnitude, and may have
extremely high condition numbers.
Furthermore, the smallest entries may be those near the target state, which are also the most important
for computing target fluxes, meaning values near machine precision can’t just be truncated.
All this means that floating-point error may substantially affect the results of eigensolvers, and may produce
bad/negative/inaccurate values for small probability bins.</p>
<p>In order to obtain better estimates, sparse matrices are used to reduce the number of floating point operations
being performed.
A stationary distribution is first estimated using scipy’s eigensolver for sparse matrices.
This is then used as an initial guess for the inverse iteration method, to further refine it.
Convergence of the inverse iteration is determined using change in the flux estimate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_steady_state_target_flux">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_steady_state_target_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pSS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_steady_state_target_flux" title="Permalink to this definition"></a></dt>
<dd><p>Get the total flux into the target state(s).</p>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p><cite>self.lagtime</cite></p></li>
<li><p><cite>self.JtargetSS</cite></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pSS</strong> (<em>(</em><em>optional</em><em>) </em><em>array-like</em>) – Steady-state distribution. If nothing provided, then use self.pSS</p></li>
<li><p><strong>_set</strong> (<em>(</em><em>optional</em><em>) </em><em>boolean</em>) – If True, then update self.JtargetSS and self.lagtime. If False, then just return the value of JtargetSS.</p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_committor">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_committor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_committor" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively obtain an estimate of the committor.</p>
<ol class="arabic simple">
<li><p>Take the flux matrix, and normalize it into a transition matrix.</p></li>
<li><dl class="simple">
<dt>Apply two-sided absorbing boundary conditions by setting self-transition probabilities for the basis and</dt><dd><p>target states to 1.0, and all transitions out to 0.0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Starting with an initial committor “guess” of all 1s, iteratively multiply the guess by the transition matrix</dt><dd><p>until convergence is below conv.</p>
</dd>
</dl>
</li>
</ol>
<dl class="simple">
<dt>Updates:</dt><dd><ul class="simple">
<li><p>self.q</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conv</strong> (<em>numerical</em>) – Convergence criteria for committor calculation. Calculation stops when the total difference between q_p and q
is less than this.</p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_flux">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_flux</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_flux" title="Permalink to this definition"></a></dt>
<dd><p>Get the measured flux (i.e. from the flux matrix) into the target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.get_cluster_centers">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">get_cluster_centers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.get_cluster_centers" title="Permalink to this definition"></a></dt>
<dd><p>Standalone method to obtain average pcoords of all segments in each cluster.</p>
<p>This functionality is contained in organize_fluxMatrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

</section>
<section id="plotting">
<h3>Plotting<a class="headerlink" href="#plotting" title="Permalink to this heading"></a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.plot_flux">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">plot_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">custom_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_validation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_from_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_to_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcoord_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_plot_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.plot_flux" title="Permalink to this definition"></a></dt>
<dd><p>Make, and save, a plot of the fluxes along the RMSD.  get_flux() must be run before this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>custom_name</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – The name for the saved plot. Defaults to flux_s&lt;first iter&gt;_e&lt;last iter&gt;.png</p></li>
<li><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.plot_flux_committor">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">plot_flux_committor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nwin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_validation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_from_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_to_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_plot_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.plot_flux_committor" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.modelWE.plot_flux_committor_pcoordcolor">
<span class="sig-prename descclassname"><span class="pre">modelWE.</span></span><span class="sig-name descname"><span class="pre">plot_flux_committor_pcoordcolor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nwin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcoord_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">_plot_args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#msm_we.modelWE.plot_flux_committor_pcoordcolor" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>self</strong> (<a class="reference internal" href="#msm_we.modelWE" title="msm_we.modelWE"><em>modelWE</em></a>) – </p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-msm_we.optimization">
<span id="optimization-msm-we-optimization"></span><h2>Optimization (msm_we.optimization)<a class="headerlink" href="#module-msm_we.optimization" title="Permalink to this heading"></a></h2>
<p>Discrepancy calculations and WE binning/allocation optimization</p>
<dl class="py function">
<dt class="sig sig-object py" id="msm_we.optimization.solve_discrepancy">
<span class="sig-prename descclassname"><span class="pre">msm_we.optimization.</span></span><span class="sig-name descname"><span class="pre">solve_discrepancy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/optimization.html#solve_discrepancy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.optimization.solve_discrepancy" title="Permalink to this definition"></a></dt>
<dd><p>Given a transition matrix, solves for the discrepancy function.</p>
<p>The Poisson equation for the discrepancy function is</p>
<div class="math notranslate nohighlight">
\[(I - K)h = 1_B - \pi(B), \:\: h \cdot \pi = 0\]</div>
<p>however, since <span class="math notranslate nohighlight">\(I-K\)</span> is singular, we instead solve</p>
<div class="math notranslate nohighlight">
\[(I - K + \pi \pi^T / || \pi ||^2_2)h = 1_B - \pi(B), \:\: h \cdot \pi = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(h\)</span> is a volumn vector, <cite>1_B</cite> is an indicator function which is 1 in B and 0 everywhere
else, <span class="math notranslate nohighlight">\(\pi\)</span> is the steady-state solution of <span class="math notranslate nohighlight">\(K\)</span>, and <cite>pi(B)</cite> is a column vector with
the steady-state value of <span class="math notranslate nohighlight">\(\pi(B)\)</span> in every element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tmatrix</strong> (<em>2D array-like</em><em>,</em>) – Transition matrix</p></li>
<li><p><strong>pi</strong> (<em>array-like</em><em>,</em>) – Steady-state distribution for the input transition matrix</p></li>
<li><p><strong>B</strong> (<em>array-like</em><em>,</em>) – Indices of target states B</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(discrepancy, variance)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.optimization.get_uniform_mfpt_bins">
<span class="sig-prename descclassname"><span class="pre">msm_we.optimization.</span></span><span class="sig-name descname"><span class="pre">get_uniform_mfpt_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrepancy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steady_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_desired_we_bins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/optimization.html#get_uniform_mfpt_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.optimization.get_uniform_mfpt_bins" title="Permalink to this definition"></a></dt>
<dd><p>Implements the MFPT-binning strategy described in [1], where bins are groups of microstates that are uniformly
spaced in the integral of pi * v</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variance</strong> (<em>Variance function</em>) – </p></li>
<li><p><strong>array-like</strong> (<em>Steady-state distribution</em>) – </p></li>
<li><p><strong>discrepancy</strong> (<em>Discrepancy function</em>) – </p></li>
<li><p><strong>array-like</strong> – </p></li>
<li><p><strong>steady_state</strong> (<em>Steady-state distribution</em>) – </p></li>
<li><p><strong>array-like</strong> – </p></li>
<li><p><strong>int</strong> (<em>n_desired_we_bins</em>) – less any recycling or basis bins</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Aristoff, D., Copperman, J., Simpson, G., Webber, R. J. &amp; Zuckerman, D. M.
Weighted ensemble: Recent mathematical developments. Arxiv (2022).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.optimization.get_clustered_mfpt_bins">
<span class="sig-prename descclassname"><span class="pre">msm_we.optimization.</span></span><span class="sig-name descname"><span class="pre">get_clustered_mfpt_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrepancy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steady_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_desired_we_bins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/optimization.html#get_clustered_mfpt_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.optimization.get_clustered_mfpt_bins" title="Permalink to this definition"></a></dt>
<dd><p>Implements the MFPT-binning strategy described in [1], where bins are groups of microstates that are uniformly
spaced in the integral of pi * v</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variance</strong> (<em>Variance function</em>) – </p></li>
<li><p><strong>array-like</strong> (<em>Steady-state distribution</em>) – </p></li>
<li><p><strong>discrepancy</strong> (<em>Discrepancy function</em>) – </p></li>
<li><p><strong>array-like</strong> – </p></li>
<li><p><strong>steady_state</strong> (<em>Steady-state distribution</em>) – </p></li>
<li><p><strong>array-like</strong> – </p></li>
<li><p><strong>int</strong> (<em>n_desired_we_bins</em>) – less any recycling or basis bins</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Aristoff, D., Copperman, J., Simpson, G., Webber, R. J. &amp; Zuckerman, D. M.
Weighted ensemble: Recent mathematical developments. Arxiv (2022).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.optimization.OptimizedBinMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.optimization.</span></span><span class="sig-name descname"><span class="pre">OptimizedBinMapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/optimization.html#OptimizedBinMapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.optimization.OptimizedBinMapper" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="msm_we.optimization.OptimizedBinMapper.create_new">
<span class="sig-name descname"><span class="pre">create_new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_original_pcoord_dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_pcoord_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_pcoord_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_binmapper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">microstate_mapper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratified_clusterer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_on_pcoord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/optimization.html#OptimizedBinMapper.create_new"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.optimization.OptimizedBinMapper.create_new" title="Permalink to this definition"></a></dt>
<dd><p>Creates an OptimizedBinMapper, suitable for use with the optimization workflow</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbins</strong> (<em>int</em><em>, </em><em>Number</em><em> of </em><em>WE bins</em>) – </p></li>
<li><p><strong>n_original_pcoord_dims</strong> (<em>int</em><em>, </em><em>Number</em><em> of </em><em>dimensions in the original user-supplied progress coordinate</em>) – </p></li>
<li><p><strong>microstate_mapper</strong> (<em>dict</em><em>, </em><em>Mapping</em><em> of </em><em>microstates to WE bins</em>) – </p></li>
<li><p><strong>stratified_clusterer</strong> (<em>StratifiedClusters</em>) – </p></li>
<li><p><strong>cluster_on_pcoord</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-msm_we.westpa_plugins.augmentation_driver">
<span id="westpa-plugins-msm-we-westpa-plugins"></span><h2>WESTPA Plugins (msm_we.westpa_plugins)<a class="headerlink" href="#module-msm_we.westpa_plugins.augmentation_driver" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.westpa_plugins.augmentation_driver.</span></span><span class="sig-name descname"><span class="pre">MDAugmentationDriver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_manager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plugin_config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/augmentation_driver.html#MDAugmentationDriver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver" title="Permalink to this definition"></a></dt>
<dd><p>WESTPA plugin to augment west.h5 with auxiliary coordinates.</p>
<p>After each iteration, appends coordinates to iter_XXX/auxdata/coord, for later usage with haMSM construction.</p>
<p>Can be used by including the following entries in your west.cfg:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">west</span><span class="p">:</span>
    <span class="n">plugins</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">plugin</span><span class="p">:</span> <span class="n">msm_we</span><span class="o">.</span><span class="n">westpa_plugins</span><span class="o">.</span><span class="n">augmentation_driver</span><span class="o">.</span><span class="n">MDAugmentationDriver</span>
          <span class="n">topology_file</span><span class="p">:</span> <span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">topology</span><span class="o">.</span><span class="n">pdb</span>
          <span class="n">child_traj_filename</span><span class="p">:</span> <span class="n">name</span> <span class="n">of</span> <span class="n">segment</span> <span class="n">trajectory</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">traj_segs</span><span class="o">/&lt;</span><span class="nb">iter</span><span class="o">&gt;/&lt;</span><span class="n">seg</span><span class="o">&gt;/</span>
          <span class="n">parent_traj_filename</span><span class="p">:</span> <span class="n">name</span> <span class="n">of</span> <span class="n">parent</span> <span class="n">trajectory</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">traj_segs</span><span class="o">/&lt;</span><span class="nb">iter</span><span class="o">&gt;/&lt;</span><span class="n">seg</span><span class="o">&gt;/</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver.augment_coordinates">
<span class="sig-name descname"><span class="pre">augment_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/augmentation_driver.html#MDAugmentationDriver.augment_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver.augment_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>After propagation completes in a WE iteration, this populates auxdata/coord with the coordinates.</p>
<p>Looks for parent/child trajectory files in the segment data_ref path defined in west.cfg,
named according to parent_traj_filename and child_traj_filename in the plugin config.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.westpa_plugins.hamsm_driver"></span><p>Plugin for automated haMSM construction.</p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.hamsm_driver.HAMSMDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.westpa_plugins.hamsm_driver.</span></span><span class="sig-name descname"><span class="pre">HAMSMDriver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_manager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plugin_config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/hamsm_driver.html#HAMSMDriver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.hamsm_driver.HAMSMDriver" title="Permalink to this definition"></a></dt>
<dd><p>WESTPA plugin to construct an haMSM.</p>
<p>Can be used by including the following entries in your west.cfg:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>west:
    plugins:
    # - plugin: An augmentation plugin is also required, such as
    #           msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver
    - plugin: msm_we.westpa_plugins.hamsm_driver.HAMSMDriver
          model_name: Name for the model
          n_clusters: Number of clusters to place in each WE bin (see stratified clustering for more details)
          tau: WESTPA resampling time in physical units
          basis_pcoord_bounds: [[pcoord dim 0 lower bound, upper bound], [pcoord dim 1 lower, upper], ...]
          target_pcoord_bounds: [[pcoord dim 0 lower bound, upper bound], [pcoord dim 1 lower, upper], ...]
          dim_reduce_method: A string specifying a dimensionality reduction method for
            :meth:`msm_we.msm_we.modelWE.dimReduce`
          featurization: An importable python method implementing a featurization
            for :meth:`msm_we.msm_we.modelWE.processCoordinates`
          n_cpus: Number of CPUs to use with Ray
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.hamsm_driver.HAMSMDriver.construct_hamsm">
<span class="sig-name descname"><span class="pre">construct_hamsm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/hamsm_driver.html#HAMSMDriver.construct_hamsm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.hamsm_driver.HAMSMDriver.construct_hamsm" title="Permalink to this definition"></a></dt>
<dd><p>Build an haMSM, for use with later plugins. The final constructed haMSM is stored on the data manager.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.westpa_plugins.restart_driver"></span><dl class="py class">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.westpa_plugins.restart_driver.</span></span><span class="sig-name descname"><span class="pre">RestartDriver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_manager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plugin_config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/restart_driver.html#RestartDriver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver" title="Permalink to this definition"></a></dt>
<dd><p>WESTPA plugin to automatically handle estimating steady-state from a WE run, re-initializing a new WE run in that
steady-state, and then running that initialized WE run.</p>
<p>Data from the previous run will be stored in the restart&lt;restart_number&gt;/ subdirectory of $WEST_SIM_ROOT.</p>
<p>This plugin depends on having the start-states implementation in the main WESTPA code, which allows initializing
a WE run using states that are NOT later used for recycling.</p>
<p>These are used so that when the new WE run is initialized, initial structure selection is chosen by w_init, using
weights assigned to the start-states based on MSM bin weight and WE segment weight.</p>
<p>Since it closes out the current WE run and starts a new one, this plugin should run LAST, after all other plugins.</p>
<p>Can be used by including the following entries in your west.cfg:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>west:
    plugins:
    # - plugin: An augmentation plugin is also required, such as
    #           msm_we.westpa_plugins.augmentation_driver.MDAugmentationDriver
    - plugin: msm_we.westpa_plugins.restart_driver.RestartDriver
          n_restarts: Number of total restarts to do
          extension_iters: Amount of iterations to extend runs by if no runs have reached the target by the
            first restart.
          n_runs: Number of runs to do between restarts
          n_restarts_to_use: Number of restarts to use. Can be a fraction, to use the last fraction amount, or
            a negative integer, to use the last N.
          initialization_file: restart_initialization.json
          model_name: Name for the model
          n_clusters: Number of clusters to place in each WE bin (see stratified clustering for more details)
          basis_pcoord_bounds: [[pcoord dim 0 lower bound, upper bound], [pcoord dim 1 lower, upper], ...]
          target_pcoord_bounds: [[pcoord dim 0 lower bound, upper bound], [pcoord dim 1 lower, upper], ...]
          dim_reduce_method: A string specifying a dimensionality reduction method for
            :meth:`msm_we.msm_we.modelWE.dimReduce`
          featurization: A python module implementing a featurization
            for msm_we.msm_we.modelWE.processCoordinates
          n_cpus: Number of CPUs to use with Ray
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver.get_original_bins">
<span class="sig-name descname"><span class="pre">get_original_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/restart_driver.html#RestartDriver.get_original_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.get_original_bins" title="Permalink to this definition"></a></dt>
<dd><p>Obtains the WE bins and their probabilities at the end of the previous iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>bins</strong> (<em>np.ndarray</em>) – Array of WE bins</p></li>
<li><p><strong>binprobs</strong> (<em>np.ndarray</em>) – WE bin weights</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver.cur_iter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cur_iter</span></span><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.cur_iter" title="Permalink to this definition"></a></dt>
<dd><p>Get the current WE iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>int</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The current iteration. Subtract one, because in finalize_run the iter has been incremented</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver.is_last_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_last_iteration</span></span><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.is_last_iteration" title="Permalink to this definition"></a></dt>
<dd><p>Get whether this is, or is past, the last iteration in this WE run.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>bool</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Whether the current iteration is the final iteration</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_extension_run">
<span class="sig-name descname"><span class="pre">prepare_extension_run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restart_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_extension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/restart_driver.html#RestartDriver.prepare_extension_run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_extension_run" title="Permalink to this definition"></a></dt>
<dd><p>Copy the necessary files for an extension run  (versus initializing a fresh run)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>run_number</strong> (<em>int</em>) – The index of this run (should be 1-indexed!)</p></li>
<li><p><strong>restart_state</strong> (<em>dict</em>) – Dictionary holding the current state of the restarting procedure</p></li>
<li><p><strong>first_extension</strong> (<em>bool</em>) – True if this is the first run of an extension set. If True, then back up west.cfg, and write the extended
west.cfg file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_new_we">
<span class="sig-name descname"><span class="pre">prepare_new_we</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/restart_driver.html#RestartDriver.prepare_new_we"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.restart_driver.RestartDriver.prepare_new_we" title="Permalink to this definition"></a></dt>
<dd><p>This function prepares a new WESTPA simulation using haMSM analysis to accelerate convergence.</p>
<p>The marathon functionality does re-implement some of the functionality of w_multi_west.
However, w_multi_west merges independent WE simulations, which may or may not be desirable.
I think for the purposes of this, it’s good to keep the runs completely independent until haMSM model building.
Either that, or I’m just justifying not having known about w_multi_west when I wrote this. TBD.</p>
<p>The algorithm is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Check to see if we’ve just completed the final iteration</p></li>
<li><p>Handle launching multiple runs, if desired</p></li>
<li><p>Build haMSM</p></li>
<li><p>Obtain structures for each haMSM bin</p></li>
<li><p>Make each structure a start-state, with probability set by (MSM-bin SS prob / # structures in bin)</p></li>
<li><p>Potentially some renormalization?</p></li>
<li><p>Start new WE simulation</p></li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<span class="target" id="module-msm_we.westpa_plugins.optimization_driver"></span><p>Plugin for automated WE hyperparameter optimization.</p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.westpa_plugins.optimization_driver.</span></span><span class="sig-name descname"><span class="pre">OptimizationDriver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_manager</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plugin_config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver" title="Permalink to this definition"></a></dt>
<dd><p>WESTPA plugin to automatically handle performing optimization.</p>
<p>Using an haMSM, updates binning and allocation according to user-specified optimization algorithms.
An OptimizedBinMapper is constructed from the optimized binning and allocation, and WE is continued with the new
mapper.</p>
<p>Can be used by including the following entries in your west.cfg:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">west</span><span class="p">:</span>
    <span class="n">plugins</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">plugin</span><span class="p">:</span> <span class="n">msm_we</span><span class="o">.</span><span class="n">westpa_plugins</span><span class="o">.</span><span class="n">optimization_driver</span><span class="o">.</span><span class="n">OptimizationDriver</span>
      <span class="n">full_coord_map</span><span class="p">:</span> <span class="n">A</span> <span class="n">pickled</span> <span class="n">dictionary</span> <span class="n">mapping</span> <span class="n">discrete</span> <span class="n">states</span> <span class="n">to</span> <span class="n">full</span><span class="o">-</span><span class="n">coordinate</span> <span class="n">structures</span>
      <span class="n">max_iters</span><span class="p">:</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">total</span> <span class="n">iterations</span><span class="o">.</span> <span class="n">WE</span> <span class="n">will</span> <span class="n">run</span> <span class="k">for</span> <span class="n">west</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">max_iters</span><span class="p">,</span> <span class="n">perform</span> <span class="n">optimization</span><span class="p">,</span> <span class="ow">and</span>
                <span class="k">continue</span> <span class="k">for</span> <span class="n">another</span> <span class="n">west</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">max_iters</span><span class="p">,</span> <span class="n">up</span> <span class="n">to</span> <span class="n">this</span> <span class="n">value</span><span class="o">.</span>
      <span class="c1"># The following parameters are optional, and provided as an example.</span>
      <span class="n">binning_strategy</span><span class="p">:</span> <span class="n">An</span> <span class="n">arbitrary</span> <span class="n">python</span> <span class="n">function</span> <span class="n">defining</span> <span class="n">a</span> <span class="nb">bin</span> <span class="n">optimization</span> <span class="n">scheme</span><span class="o">.</span>
            <span class="n">Takes</span> <span class="ow">in</span> <span class="n">an</span> <span class="n">msm_we</span><span class="o">.</span><span class="n">msm_we</span><span class="o">.</span><span class="n">modelWE</span> <span class="ow">and</span> <span class="n">returns</span> <span class="n">an</span> <span class="n">array</span><span class="o">-</span><span class="n">like</span> <span class="n">of</span> <span class="n">length</span> <span class="n">n_msm_states</span><span class="p">,</span> <span class="n">where</span> <span class="n">each</span>
            <span class="n">element</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">WE</span> <span class="nb">bin</span> <span class="n">that</span> <span class="n">MSM</span> <span class="n">state</span> <span class="n">will</span> <span class="n">be</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">by</span> <span class="n">the</span> <span class="n">OptimizedMapper</span><span class="o">.</span>
      <span class="n">allocation_strategy</span><span class="p">:</span> <span class="n">An</span> <span class="n">arbitrary</span> <span class="n">python</span> <span class="n">function</span> <span class="n">defining</span> <span class="n">an</span> <span class="n">allocation</span> <span class="n">optimization</span> <span class="n">scheme</span><span class="o">.</span>
            <span class="n">Takes</span> <span class="ow">in</span> <span class="n">an</span> <span class="n">msm_we</span><span class="o">.</span><span class="n">msm_we</span><span class="o">.</span><span class="n">modelWE</span> <span class="ow">and</span> <span class="n">returns</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">walker</span> <span class="n">allocations</span> <span class="k">for</span> <span class="n">the</span> <span class="n">WE</span> <span class="n">bins</span><span class="o">.</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.do_optimization">
<span class="sig-name descname"><span class="pre">do_optimization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.do_optimization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.do_optimization" title="Permalink to this definition"></a></dt>
<dd><p>Update WESTPA with an optimized bin mapper, bin allocation, and extend the progress coordinate. Then, continue
the WE for more iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_allocation_optimizer">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_allocation_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.default_allocation_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_allocation_optimizer" title="Permalink to this definition"></a></dt>
<dd><p>A (trivial) example allocation optimization function, which returns an array with the target number of
walkers in each bin.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_allocation">
<span class="sig-name descname"><span class="pre">compute_optimized_allocation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.compute_optimized_allocation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_allocation" title="Permalink to this definition"></a></dt>
<dd><p>Compute the optimal allocation.</p>
<p>If <cite>plugin.allocation_strategy</cite> is None or not provided, the allocation is not updated.</p>
<p>Otherwise, the constructed haMSM is passed to an arbitrary function that returns an array-like describing the
new walker allocation over the WE bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_bin_optimizer">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_bin_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.default_bin_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.default_bin_optimizer" title="Permalink to this definition"></a></dt>
<dd><p>Example bin optimization function, which assigns microstates to WE bins.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_bins">
<span class="sig-name descname"><span class="pre">compute_optimized_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.compute_optimized_bins"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_optimized_bins" title="Permalink to this definition"></a></dt>
<dd><p>Computes discrepancy and variance, and returns the resulting optimized bin mapper.</p>
<p>If <cite>plugin.binning_strategy</cite> is None or not provided, <code class="code docutils literal notranslate"><span class="pre">optimization.get_clustered_mfpt_bins()</span></code> is used.</p>
<p>Otherwise, the constructed haMSM is passed to an arbitrary function that returns an array-like with the WE bin
index of all MSM microbins excluding the basis/target (model.indBasis and model.indTargets).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An OptimizedBinMapper</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_new_pcoord_map">
<span class="sig-name descname"><span class="pre">compute_new_pcoord_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.compute_new_pcoord_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.compute_new_pcoord_map" title="Permalink to this definition"></a></dt>
<dd><p>SynD specific: Compute a new progress coordinate mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>A dictionary of {state indices</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>extended progress coordinates}</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.westpa_plugins.optimization_driver.OptimizationDriver.update_westpa_pcoord">
<span class="sig-name descname"><span class="pre">update_westpa_pcoord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_pcoord_map</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/westpa_plugins/optimization_driver.html#OptimizationDriver.update_westpa_pcoord"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.westpa_plugins.optimization_driver.OptimizationDriver.update_westpa_pcoord" title="Permalink to this definition"></a></dt>
<dd><p>Changing a progress coordinate during a WE run requires a number of changes in WESTPA’s internal state.
This handles making those, so you can call w_run and continue with the new, changed pcoord</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_pcoord_map</strong> (<em>A dictionary mapping discrete states to the new</em><em>, </em><em>extended pcoord</em>) – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="fpt-calculations">
<h2>FPT Calculations<a class="headerlink" href="#fpt-calculations" title="Permalink to this heading"></a></h2>
<section id="module-msm_we.fpt">
<span id="msm-we-fpt"></span><h3>msm_we.fpt<a class="headerlink" href="#module-msm_we.fpt" title="Permalink to this heading"></a></h3>
<p>First-passage time (FPT) calculations from trajectories or matrices</p>
<p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">MatrixFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class for calculating FPTs using transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculting mean-first passave time for at transition matrix</p>
<p>Derived class will implement this function differently.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.directional_mfpt">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">directional_mfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_probs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.directional_mfpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.directional_mfpt" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mean-first passage time in a single direction using a recursive procedure</p>
<p>This method is useful when there is no B-&gt;A ensemble but only A-&gt;B transitions,
for instance when B is absorbing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>Numpy 2D array</em>) – </p></li>
<li><p><strong>stateA</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>stateB</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>ini_probs</strong> (<em>List</em><em> of </em><em>float</em><em>, </em><em>default is None</em>) – initial probabilities in stateA</p></li>
<li><p><strong>lag_time</strong> (<em>integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage time from A-&gt;B</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mfpts_to_target_microstate">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mfpts_to_target_microstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mfpts_to_target_microstate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mfpts_to_target_microstate" title="Permalink to this definition"></a></dt>
<dd><p>Computes all the mean-first passage to a target microstate (k)</p>
<p>Returns a list where the i-element is mfpt(i-&gt;k). This function is
useful to compute the mfpt matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>Numpy 2D array</em>) – </p></li>
<li><p><strong>target</strong> (<em>Integer number that specifies the index</em><em> of </em><em>the state. The indexes</em>) – should be consistent with the transition matrix and python
(i.e. starting from 0)</p></li>
<li><p><strong>lag_time</strong> (<em>Integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>a list where the i-element is mfpt(i-&gt;k). This function is</em></p></li>
<li><p><em>useful to compute the mfpt matrix.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.mfpts_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mfpts_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.mfpts_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.mfpts_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculate MFPT matrix, i.e., the matrix where the ij-element is MFPT(i-&gt;j)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>Numpy 2D array</em>) – </p></li>
<li><p><strong>lag_time</strong> (<em>Integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage time matrix with ij-element of MFPT(i-&gt;j)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.min_commute_time">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix_of_mfpts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.min_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.min_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Calculate minimum commuting time (round trip time) between all pairs</p>
<p>of microstates from the matrix of mfpts. It also returns the indexes
of the pair of microstates involved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix_of_mfpts</strong> (<em>Numpy 2D array</em>) – matrix of MFPTs with ij-element of MFPT(i-&gt;j)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Minimum commuting time (round trip time) between all pairs</em></p></li>
<li><p><em>of microstates and the indexes of the pair of microstates involved.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.max_commute_time">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix_of_mfpts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.max_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.max_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Calculate maximum commuting time (round trip time) between all pairs</p>
<p>of microstates from the matrix of mfpts. It also returns the indexes
of the pair of microstates involved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix_of_mfpts</strong> (<em>Numpy 2D array</em>) – matrix of MFPTs with ij-element of MFPT(i-&gt;j)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Maximum commuting time (round trip time) between all pairs</em></p></li>
<li><p><em>of microstates and the indexes of the pair of microstates involved.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.fpt_distribution">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fpt_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_distrib</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_lags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_recycling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.fpt_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.fpt_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Calculated distribution of first passage times from transition matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_matrix</strong> (<em>Numpy 2D array</em>) – </p></li>
<li><p><strong>initial_state</strong> (<em>List</em><em> of </em><em>integer numbers</em>) – Specifies the indexes of initial and final states.</p></li>
<li><p><strong>final_state</strong> (<em>List</em><em> of </em><em>integer numbers</em>) – Specifies the indexes of initial and final states.</p></li>
<li><p><strong>initial_distrib</strong> (<em>List</em><em> of </em><em>float</em><em>, </em><em>default is None</em>) – initial probabilities for initial states</p></li>
<li><p><strong>min_power</strong> (<em>Integer</em>) – The minimum and maximum power when the FPT distribution is
shown in logscale such as (10^min_power, 10^max_power)*lag_time*dt.</p></li>
<li><p><strong>max_power</strong> (<em>Integer</em>) – The minimum and maximum power when the FPT distribution is
shown in logscale such as (10^min_power, 10^max_power)*lag_time*dt.</p></li>
<li><p><strong>max_n_lags</strong> (<em>Integer</em>) – maximum number of lags when the FPT distribution is shown in linear
scale such as (0, max_n_logs)*lag_time*dt. When in logscale, this is number
of points to shown in the range of (10^min_power, 10^max_power)*lag_time*dt.</p></li>
<li><p><strong>lag_time</strong> (<em>Integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
<li><p><strong>dt</strong> (<em>Float</em>) – Time step</p></li>
<li><p><strong>clean_recycling</strong> (<em>Bool</em>) – Cleaning the recycling of steady state simulation if True</p></li>
<li><p><strong>logscale</strong> (<em>Bool</em>) – Option to use logscale for FPT time in the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Distributions of first passage times</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MatrixFPT.adaptive_fpt_distribution">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adaptive_fpt_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fine_increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relevant_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explicit_renormalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MatrixFPT.adaptive_fpt_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MatrixFPT.adaptive_fpt_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Adaptively computes a first-passage time distribution.</p>
<p>Starting at t=tau, compute the probability flowing into the target at t.
Then, increment t by multiplying it by the coarse increment.
When relevant_thresh probability has entered the target state, step back to the previous coarse state, and
swap over to incrementing with the fine increment.
This allows you to efficiently sweep log-space.</p>
<p>Procedurally, this starts probability in specified <cite>initial_states</cite> according to <cite>initial_state_probs</cite>, and then
propagates that probability through the transition matrix.
The FPT distribution is measured by tracking new probability entering the target state at each time.</p>
<p>Note that absorbing boundary conditions are stripped from the transition matrix – if this is not done, then
the result is like a probability CDF, not a probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Tmatrix</strong> (<em>array-like</em>) – Transition matrix</p></li>
<li><p><strong>initial_states</strong> (<em>array-like</em><em> of </em><em>ints</em>) – List of initial states to start probability in</p></li>
<li><p><strong>initial_state_probs</strong> (<em>array-like</em>) – Probability distribution across the initial states.</p></li>
<li><p><strong>target_states</strong> (<em>array-like</em>) – Target states for MFPT.</p></li>
<li><p><strong>tau</strong> – </p></li>
<li><p><strong>increment</strong> (<em>float</em>) – Multiplicative increment for coarse steps</p></li>
<li><p><strong>fine_increment</strong> (<em>float</em>) – Multiplicative increment for fine steps, once the minimum probability in the target has been reached.</p></li>
<li><p><strong>relevant_thresh</strong> (<em>float</em>) – Amount of probability that must be in the target before switching to fine increments.</p></li>
<li><p><strong>max_steps</strong> (<em>int</em>) – Maximum number of steps to run</p></li>
<li><p><strong>max_time</strong> (<em>float</em>) – Maximum time to run to</p></li>
<li><p><strong>explicit_renormalization</strong> (<em>bool</em>) – Whether to explicitly renormalize the transition matrix. This should not be necessary – if it is, there’s
probably some numerical instability you should be careful of.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Produce verbose text output.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>FPT distribution,</em></p></li>
<li><p><em>probability distribution at each time,</em></p></li>
<li><p><em>last step index,</em></p></li>
<li><p><em>times at which FPT distribution was evaluated</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">MarkovFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT" title="Permalink to this definition"></a></dt>
<dd><p>Derived a class for calculating FPTs using Markovian transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">markov_tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Computes mean first passage times using Markovian transition matrix</p>
<p>in both directions A-&gt;B and B-&gt;A from a markov model. The MFPTs computed
in this way are directly comparable with the values obtained by a long back
and forth simulation between the target states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>markov_matrix</strong> (<em>Numpy 2D array</em>) – Markovian transition matrix</p></li>
<li><p><strong>stateA</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>stateB</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>lag_time</strong> (<em>integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mean-first passage times from A-&gt;B and B-&gt;A</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.MarkovFPT.markov_commute_time">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">markov_commute_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#MarkovFPT.markov_commute_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.MarkovFPT.markov_commute_time" title="Permalink to this definition"></a></dt>
<dd><p>Computing commute time for Markovian Model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transition_matrix</strong> (<em>Numpy 2D array</em>) – Markovian transition matrix</p></li>
<li><p><strong>stateA</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>stateB</strong> (<em>List</em><em> of </em><em>integers</em>) – Both states are a list of indexes.</p></li>
<li><p><strong>lag_time</strong> (<em>integer</em>) – Lag time used, the trajectory is “observed” every lag_time
time steps</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Commute time from mean-first passage times</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.fpt.NonMarkovFPT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.fpt.</span></span><span class="sig-name descname"><span class="pre">NonMarkovFPT</span></span><a class="reference internal" href="_modules/msm_we/fpt.html#NonMarkovFPT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.NonMarkovFPT" title="Permalink to this definition"></a></dt>
<dd><p>Derived a class for calculating FPTs using Non Markov transition matrix</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.fpt.NonMarkovFPT.mean_fpts">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean_fpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nm_transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/fpt.html#NonMarkovFPT.mean_fpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.fpt.NonMarkovFPT.mean_fpts" title="Permalink to this definition"></a></dt>
<dd><p>Computes the mean first passage times from a non-markovian model</p>
<p>in both directions of A-&gt;B and B-&gt;A. The shape of the transition matrix
should be (2*n_states, 2*n_states).
:param nm_transition_matrix: Non-Markovian transition matrix
:type nm_transition_matrix: Numpy 2D array
:param stateA: Both states are a list of indexes.
:type stateA: List of integers
:param stateB: Both states are a list of indexes.
:type stateB: List of integers
:param lag_time: Lag time used, the trajectory is “observed” every lag_time time steps
:type lag_time: integer</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean-first passage times from A-&gt;B and B-&gt;A</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-msm_we.ensembles">
<span id="msm-we-ensembles"></span><h3>msm_we.ensembles<a class="headerlink" href="#module-msm_we.ensembles" title="Permalink to this heading"></a></h3>
<p>Implements Ensemble class for managing trajectories</p>
<p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">Ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class to store a list of space-continuous trajectories</p>
<dl class="simple">
<dt>e.g.: [ trajectory1, trajectory2,…], each trajectory is just a matrix</dt><dd><p>where each row is a snapshot, and each column represents the evolution
of the corresponding variable.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.add_trajectory">
<span class="sig-name descname"><span class="pre">add_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.add_trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.add_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Add a single trajectory to the ensemble</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.empirical_mfpts">
<span class="sig-name descname"><span class="pre">empirical_mfpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.empirical_mfpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.empirical_mfpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculate mean first passage time using direct counting method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.Ensemble.empirical_corr_function">
<span class="sig-name descname"><span class="pre">empirical_corr_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#Ensemble.empirical_corr_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.Ensemble.empirical_corr_function" title="Permalink to this definition"></a></dt>
<dd><p>Calculate correlation function for trajectories</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.PathEnsemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">PathEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#PathEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.PathEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Derive a class to store trajectories for path analysis</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.PathEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#PathEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.PathEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a PathEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">DiscreteEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Define a base class to store a list of space-discrete trajectories</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a DiscreteEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscreteEnsemble.from_transition_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscreteEnsemble.from_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscreteEnsemble.from_transition_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates a DiscreteEnsemble from the transition matrix</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.ensembles.</span></span><span class="sig-name descname"><span class="pre">DiscretePathEnsemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discrete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble" title="Permalink to this definition"></a></dt>
<dd><p>Derive a class to store a list of discrete trajectories for path analysis</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.from_transition_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_paths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ini_pops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.from_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.from_transition_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Construct a path ensemble from a transition matrix</p>
<p>stateA:     list, intitial state</p>
<p>stateB:     list, final state</p>
<dl>
<dt>n_paths:    integer, with default value of 1000</dt><dd><p>number of paths to generate</p>
</dd>
<dt>ini_pops:   list or label, probability distribution over the</dt><dd><p>initial state used to generate the path</p>
<p>possible values:
a) None
Use a uniform distribution over the states in stateA
c) list
A list with the explicit values of the populations in stateA
that should be used to generate the ensemble</p>
</dd>
<dt>max_iters:  integer, with default value of 1000000000</dt><dd><p>maximum of iterations for generating path trajectories</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.from_ensemble">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.from_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.from_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Build a DiscreteEnsemble from an ensemble object or a set of trajectories</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.nm_mfpt">
<span class="sig-name descname"><span class="pre">nm_mfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ini_probs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.nm_mfpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.nm_mfpt" title="Permalink to this definition"></a></dt>
<dd><p>Compute the mean-first passage time from the transition matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.ensembles.DiscretePathEnsemble.weighted_fundamental_sequences">
<span class="sig-name descname"><span class="pre">weighted_fundamental_sequences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/ensembles.html#DiscretePathEnsemble.weighted_fundamental_sequences"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.ensembles.DiscretePathEnsemble.weighted_fundamental_sequences" title="Permalink to this definition"></a></dt>
<dd><p>Generate sorted fundamental sequences with weights</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-msm_we.nmm">
<span id="msm-we-nmm"></span><h3>msm_we.nmm<a class="headerlink" href="#module-msm_we.nmm" title="Permalink to this heading"></a></h3>
<p>“Non-Markovian” trajectory analysis</p>
<p>Adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.nmm.</span></span><span class="sig-name descname"><span class="pre">NonMarkovModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sliding_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markovian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coarse_macrostates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel" title="Permalink to this definition"></a></dt>
<dd><p>Define a class for analyzing MD trajectories using Markovian or non-Markovian Model</p>
<p>from a list of 1D trajectories of integers representing macrostates</p>
<p>For example:</p>
<p>trajectories = [ [1 , 2, 0, …], [2, 2, 1, …], [3, 1, 2, …], …]</p>
<p>If only one sequence is given in trajectories, the format is the same:</p>
<p>trajectories = [ [1 , 2, 0, …] ]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>integer</strong> (<em>lag_time</em>) – Lag time of the model.</p></li>
<li><p><strong>default</strong> – Lag time of the model.</p></li>
<li><p><strong>(</strong><strong>boolean</strong><strong>)</strong> (<em>sliding_window</em>) – Use a sliding window of length lag_time to compute the count matrix</p></li>
<li><p><strong>stateA</strong> – Define the initial and final macrostates in form of python lists
for example: stateA=[0,2,5], stateB = [1]</p></li>
<li><p><strong>lists</strong><strong>)</strong> (<em>stateB</em><em> (</em><em>python</em>) – Define the initial and final macrostates in form of python lists
for example: stateA=[0,2,5], stateB = [1]</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.n_states">
<span class="sig-name descname"><span class="pre">n_states</span></span><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.n_states" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.nm_cmatrix">
<span class="sig-name descname"><span class="pre">nm_cmatrix</span></span><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.nm_cmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Stores the number of transitions between states, the i,j element cij
stores the number of transitions observed from i to j.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, with shape (2 n_states, 2 n_states)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.populations">
<span class="sig-name descname"><span class="pre">populations</span></span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.populations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.populations" title="Permalink to this definition"></a></dt>
<dd><p>Equilibrium population, the steady state solution of of the
transition matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (n_states,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits the non-Markovian model from a list of sequences</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.from_nm_tmatrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.from_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.from_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates a discrete ensemble from the transition matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.empirical_mfpts">
<span class="sig-name descname"><span class="pre">empirical_mfpts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.empirical_mfpts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.empirical_mfpts" title="Permalink to this definition"></a></dt>
<dd><p>Calculate mean first passage time using direct counting method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.NonMarkovModel.corr_function">
<span class="sig-name descname"><span class="pre">corr_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#NonMarkovModel.corr_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.NonMarkovModel.corr_function" title="Permalink to this definition"></a></dt>
<dd><p>Compute the correlation function for a set of times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>integers</strong><strong>)</strong> (<em>times</em><em> (</em><em>list of</em>) – List of dt values used to compute the correlation function.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List of floats with the correlation values for the dt given in times</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.nmm.MarkovPlusColorModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.nmm.</span></span><span class="sig-name descname"><span class="pre">MarkovPlusColorModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sliding_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#MarkovPlusColorModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.MarkovPlusColorModel" title="Permalink to this definition"></a></dt>
<dd><p>Define a class for analyzing MD trajectories using Markovian Plus Color Model</p>
<dl class="py method">
<dt class="sig sig-object py" id="msm_we.nmm.MarkovPlusColorModel.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/nmm.html#MarkovPlusColorModel.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.nmm.MarkovPlusColorModel.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits the markov plus color model from a list of sequences</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-msm_we.utils">
<span id="msm-we-utils"></span><h3>msm_we.utils<a class="headerlink" href="#module-msm_we.utils" title="Permalink to this heading"></a></h3>
<p>Miscellaneous convenience functions</p>
<p>Some functionality was adapted from the original NMpathAnalysis package,
<a class="reference external" href="https://github.com/ZuckermanLab/NMpathAnalysis">https://github.com/ZuckermanLab/NMpathAnalysis</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.find_connected_sets">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">find_connected_sets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#find_connected_sets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.find_connected_sets" title="Permalink to this definition"></a></dt>
<dd><p>This implementation is taken from msmtools.estimation.sparse.connectivity, at commit 9312660.
See the original at <a class="reference external" href="https://github.com/markovmodel/msmtools/blob/devel/msmtools/estimation/sparse/connectivity.py#L30">https://github.com/markovmodel/msmtools/blob/devel/msmtools/estimation/sparse/connectivity.py#L30</a></p>
<p>Compute connected components for a directed graph with weights
represented by the given count matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>scipy.sparse matrix</em><em> or </em><em>numpy ndarray</em>) – square matrix specifying edge weights.</p></li>
<li><p><strong>directed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute connected components for a directed  or
undirected graph. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cc</strong> – Each entry is an array containing all vertices (states) in
the corresponding connected component.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of arrays of integers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.is_connected">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#is_connected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.is_connected" title="Permalink to this definition"></a></dt>
<dd><p>Check for connectivity between two states.
If directed is True, then checks for directional connectivity from source_states to target_states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>np.array</em><em>, </em><em>NxN</em>) – Transition matrix</p></li>
<li><p><strong>source_states</strong> (<em>array-like</em><em>, </em><em>N</em>) – Source states</p></li>
<li><p><strong>target_states</strong> (<em>array-like</em><em>, </em><em>N</em>) – Target states</p></li>
<li><p><strong>directed</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Compute directional connectivity</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.inverse_iteration">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">inverse_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">guess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#inverse_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.inverse_iteration" title="Permalink to this definition"></a></dt>
<dd><p>Do one iteration of inverse iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>guess</strong> (<em>array-like</em><em>  (</em><em>N elements</em><em>)</em>) – Vector of weights to be used as the initial guess.</p></li>
<li><p><strong>matrix</strong> (<em>array-like</em><em> (</em><em>NxN elements</em><em>)</em>) – Transition matrix to use for inverse iteration.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The new vector of weights after one iteration of inverse iteration.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="msm_we.utils.Interval">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">Interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_variables</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#Interval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.Interval" title="Permalink to this definition"></a></dt>
<dd><p>Intervals are in general defined as half-open interval [start,end).</p>
<p>in any case, in each dimension the interval is specified using a list [a,b]
where a &lt; b</p>
<ul>
<li><p>For 1D (single) interval a single list in the form [a,b] has to be given</p></li>
<li><dl class="simple">
<dt>The union of multiple (1D) intervals can be specified as:</dt><dd><p>[[a,b],[c,d],…]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A list of lists [[a,b],[c,d],…] are used for a n-dimensional</dt><dd><p>intervals, one for each dimension, i.e, len(interval) = n_variables</p>
</dd>
</dl>
</li>
<li><dl>
<dt>A list-of-lists-of-lists for the mathematical union of n-dimensional</dt><dd><p>intervals’</p>
<p>[ [[a,b],[c,d],…],  [[e,f],[g,h],…], … ]</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.reverse_sort_lists">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">reverse_sort_lists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#reverse_sort_lists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.reverse_sort_lists" title="Permalink to this definition"></a></dt>
<dd><p>Reverse sorting two list based on the first one</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.weighted_choice">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">weighted_choice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#weighted_choice"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.weighted_choice" title="Permalink to this definition"></a></dt>
<dd><p>Select an element from a list with probability from weights</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.get_shape">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">get_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#get_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.get_shape" title="Permalink to this definition"></a></dt>
<dd><p>Get the shape of a trajectory array in tuple (n_snapshots, n_variables)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.num_of_nonzero_elements">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">num_of_nonzero_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#num_of_nonzero_elements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.num_of_nonzero_elements" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of non-zero elements in a vector</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.normalize_markov_matrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">normalize_markov_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reversible</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#normalize_markov_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.normalize_markov_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Transform a matrix of positive elements to a markov-like matrix</p>
<p>by dividing each row by the sum of the elements of the row.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.normalize">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.normalize" title="Permalink to this definition"></a></dt>
<dd><p>Normalize a vector</p>
<p>by dividing each element by the total sum of all its elements</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.random_markov_matrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">random_markov_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#random_markov_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.random_markov_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random transition markov matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.check_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">check_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_null_rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#check_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.check_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Check if the given matrix is actually a row-stochastic transition matrix</p>
<dl class="simple">
<dt>i.e, all the elements are non-negative and the rows add to one.</dt><dd><p>If the keyword argument accept_null_rows is True, is going
to accept rows where all the elements are zero. Those “problematic”
states are going to be removed later if necessary by clean_tmatrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.clean_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">clean_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rm_absorbing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#clean_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.clean_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Removes the states/indexes with no transitions and that are absorbing</p>
<p>if the the keyword argument rm_absorbing is true
Returns the “clean” transition matrix and a list with the
removed states/indexes (clean_tmatrix, removed_states)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pops_from_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pops_from_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pops_from_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pops_from_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the eigen values and eigen vectors of the transposed transition matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transition_matrix</strong> (<em>ndarray with shape =</em><em> (</em><em>n_states</em><em>, </em><em>n_states</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>the solution, p, of K.T p = p where K.T is the transposed transition matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pops_from_nm_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pops_from_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transition_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pops_from_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pops_from_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Computes the populations of the real/physical states</p>
<p>from a non-Markovian transtion matrix with shape (2*n_states, 2*n_states)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.map_to_integers">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">map_to_integers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#map_to_integers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.map_to_integers" title="Permalink to this definition"></a></dt>
<dd><p>Map a sequence of elements to a sequence of integers
for intance, maps [1, ‘a’, 1, ‘b’, 2.2] to [0, 1, 0, 2, 3]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="msm_we.utils.pseudo_nm_tmatrix">
<span class="sig-prename descclassname"><span class="pre">msm_we.utils.</span></span><span class="sig-name descname"><span class="pre">pseudo_nm_tmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">markovian_tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msm_we/utils.html#pseudo_nm_tmatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#msm_we.utils.pseudo_nm_tmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Obtain a pseudo non-Markovian transition matrix from a Markovian transiton matrix</p>
<p>The pseudo Markovian matrix has a shape of (2 n_states, 2 n_states)</p>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="_examples/optimization.html" class="btn btn-neutral float-left" title="Trp-cage WE Optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="code_todos.html" class="btn btn-neutral float-right" title="TODOs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, John Russo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>